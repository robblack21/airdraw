Object.defineProperty(exports, '__esModule', { value: true });

var clientFetch = require('@hey-api/client-fetch');

// This file is auto-generated by @hey-api/openapi-ts
const client = clientFetch.createClient(clientFetch.createConfig({
    baseUrl: 'https://lichess.org'
}));

// This file is auto-generated by @hey-api/openapi-ts
/**
 * Get real-time users status
 * Read the `online`, `playing` and `streaming` flags of several users.
 * This API is very fast and cheap on lichess side.
 * So you can call it quite often (like once every 5 seconds).
 * Use it to track players and know when they're connected on lichess and playing games.
 *
 */ const apiUsersStatus = (options)=>{
    return (options.client ?? client).get({
        url: '/api/users/status',
        ...options
    });
};
/**
 * Get all top 10
 * Get the top 10 players for each speed and variant.
 * See <https://lichess.org/player>.
 *
 */ const player = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/player',
        ...options
    });
};
/**
 * Get one leaderboard
 * Get the leaderboard for a single speed or variant (a.k.a. `perfType`).
 * There is no leaderboard for correspondence or puzzles.
 * See <https://lichess.org/player/top/200/bullet>.
 *
 */ const playerTopNbPerfType = (options)=>{
    return (options.client ?? client).get({
        url: '/api/player/top/{nb}/{perfType}',
        ...options
    });
};
/**
 * Get user public data
 * Read public data of a user.
 *
 */ const apiUser = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/user/{username}',
        ...options
    });
};
/**
 * Get rating history of a user
 * Read rating history of a user, for all perf types.
 * There is at most one entry per day.
 * Format of an entry is `[year, month, day, rating]`.
 * `month` starts at zero (January).
 *
 */ const apiUserRatingHistory = (options)=>{
    return (options.client ?? client).get({
        url: '/api/user/{username}/rating-history',
        ...options
    });
};
/**
 * Get performance statistics of a user
 * Read performance statistics of a user, for a single performance.
 * Similar to the [performance pages on the website](https://lichess.org/@/thibault/perf/bullet).
 *
 */ const apiUserPerf = (options)=>{
    return (options.client ?? client).get({
        url: '/api/user/{username}/perf/{perf}',
        ...options
    });
};
/**
 * Get user activity
 * Read data to generate the activity feed of a user.
 *
 */ const apiUserActivity = (options)=>{
    return (options.client ?? client).get({
        url: '/api/user/{username}/activity',
        ...options
    });
};
/**
 * Get the daily puzzle
 * Get the daily Lichess puzzle in JSON format.
 * Alternatively, you can [post it in your slack workspace](https://lichess.org/daily-puzzle-slack).
 *
 */ const apiPuzzleDaily = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/puzzle/daily',
        ...options
    });
};
/**
 * Get a puzzle by its ID
 * Get a single Lichess puzzle in JSON format.
 */ const apiPuzzleId = (options)=>{
    return (options.client ?? client).get({
        url: '/api/puzzle/{id}',
        ...options
    });
};
/**
 * Get a new puzzle
 * Get a random Lichess puzzle in JSON format.
 *
 * If authenticated, only returns puzzles that the user has never seen before.
 *
 * **DO NOT** use this endpoint to enumerate puzzles for mass download. Instead, download the [full public puzzle database](https://database.lichess.org/#puzzles).
 *
 */ const apiPuzzleNext = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/puzzle/next',
        ...options
    });
};
/**
 * Get your puzzle activity
 * Download your puzzle activity in [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Puzzle activity is sorted by reverse chronological order (most recent first)
 * We recommend streaming the response, for it can be very long.
 *
 */ const apiPuzzleActivity = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/puzzle/activity',
        ...options
    });
};
/**
 * Get puzzles to replay
 * Gets the puzzle IDs of remaining puzzles to re-attempt in JSON format.
 */ const apiPuzzleReplay = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/puzzle/replay/{days}/{theme}',
        ...options
    });
};
/**
 * Get your puzzle dashboard
 * Download your [puzzle dashboard](https://lichess.org/training/dashboard/30/dashboard) as JSON.
 * Also includes all puzzle themes played, with aggregated results.
 * Allows re-creating the [improvement/strengths](https://lichess.org/training/dashboard/30/improvementAreas) interfaces.
 *
 */ const apiPuzzleDashboard = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/puzzle/dashboard/{days}',
        ...options
    });
};
/**
 * Get the storm dashboard of a player
 * Download the [storm dashboard](https://lichess.org/storm/dashboard/mrbasso) of any player as JSON.
 * Contains the aggregated highscores, and the history of storm runs aggregated by days.
 * Use `?days=0` if you only care about the highscores.
 *
 */ const apiStormDashboard = (options)=>{
    return (options.client ?? client).get({
        url: '/api/storm/dashboard/{username}',
        ...options
    });
};
/**
 * Create and join a puzzle race
 * Create a new private [puzzle race](https://lichess.org/racer).
 * The Lichess user who creates the race must join the race page,
 * and manually start the race when enough players have joined.
 * - <https://lichess.org/racer>
 *
 */ const racerPost = (options)=>{
    return (options?.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/racer',
        ...options
    });
};
/**
 * Get users by ID
 * Get up to 300 users by their IDs. Users are returned in the same order as the IDs.
 * The method is `POST` to allow a longer list of IDs to be sent in the request body.
 * Please do not try to download all the Lichess users with this endpoint, or any other endpoint.
 * An API is not a way to fully export a website. We do not provide a full download of the Lichess users.
 * This endpoint is limited to 8,000 users every 10 minutes, and 120,000 every day.
 *
 */ const apiUsers = (options)=>{
    return (options.client ?? client).post({
        bodySerializer: null,
        url: '/api/users',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};
/**
 * Get my profile
 * Public information about the logged in user.
 *
 */ const accountMe = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account',
        ...options
    });
};
/**
 * Get my email address
 * Read the email address of the logged in user.
 *
 */ const accountEmail = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account/email',
        ...options
    });
};
/**
 * Get my preferences
 * Read the preferences of the logged in user.
 * - <https://lichess.org/account/preferences/game-display>
 * - <https://github.com/ornicar/lila/blob/master/modules/pref/src/main/Pref.scala>
 *
 */ const account = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account/preferences',
        ...options
    });
};
/**
 * Get my kid mode status
 * Read the kid mode status of the logged in user.
 * - <https://lichess.org/account/kid>
 *
 */ const accountKid = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account/kid',
        ...options
    });
};
/**
 * Set my kid mode status
 * Set the kid mode status of the logged in user.
 * - <https://lichess.org/account/kid>
 *
 */ const accountKidPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account/kid',
        ...options
    });
};
/**
 * Get my timeline
 * Get the timeline events of the logged in user.
 *
 */ const timeline = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/timeline',
        ...options
    });
};
/**
 * Export one game
 * Download one game in either PGN or JSON format.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 *
 */ const gamePgn = (options)=>{
    return (options.client ?? client).get({
        url: '/game/export/{gameId}',
        ...options
    });
};
/**
 * Export ongoing game of a user
 * Download the ongoing game, or the last game played, of a user.
 * Available in either PGN or JSON format.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 *
 */ const apiUserCurrentGame = (options)=>{
    return (options.client ?? client).get({
        url: '/api/user/{username}/current-game',
        ...options
    });
};
/**
 * Export games of a user
 * Download all games of any user in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by reverse chronological order (most recent first).
 * We recommend streaming the response, for it can be very long.
 * <https://lichess.org/@/german11> for instance has more than 500,000 games.
 * The game stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 games per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
 * - Authenticated, downloading your own games: 60 games per second
 *
 */ const apiGamesUser = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/games/user/{username}',
        ...options
    });
};
/**
 * Export games by IDs
 * Download games by IDs in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
 * Games are sorted by reverse chronological order (most recent first)
 * The method is `POST` so a longer list of IDs can be sent in the request body.
 * 300 IDs can be submitted.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 *
 */ const gamesExportIds = (options)=>{
    return (options.client ?? client).post({
        bodySerializer: null,
        url: '/api/games/export/_ids',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};
/**
 * Stream games of users
 * Stream the games played between a list of users, in real time.
 * Only games where **both players** are part of the list are included.
 * The stream emits an event each time a game is started or finished.
 * To also get all current ongoing games at the beginning of the stream, use the `withCurrentGames` flag.
 * Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Maximum number of users: 300.
 * The method is `POST` so a longer list of IDs can be sent in the request body.
 *
 */ const gamesByUsers = (options)=>{
    return (options.client ?? client).post({
        bodySerializer: null,
        url: '/api/stream/games-by-users',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};
/**
 * Stream games by IDs
 * Creates a stream of games from an arbitrary streamId, and a list of game IDs.
 * The stream first outputs the games that already exists, then emits an event each time a game is started or finished.
 * Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Maximum number of games: 500 for anonymous requests, or 1000 for [OAuth2 authenticated](#section/Introduction/Authentication) requests.
 * While the stream is open, it is possible to [add new game IDs to watch](#operation/gamesByIdsAdd).
 *
 */ const gamesByIds = (options)=>{
    return (options.client ?? client).post({
        bodySerializer: null,
        url: '/api/stream/games/{streamId}',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};
/**
 * Add game IDs to stream
 * Add new game IDs for [an existing stream](#operation/gamesByIds) to watch.
 * The stream will immediately outputs the games that already exists, then emit an event each time a game is started or finished.
 *
 */ const gamesByIdsAdd = (options)=>{
    return (options.client ?? client).post({
        bodySerializer: null,
        url: '/api/stream/games/{streamId}/add',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};
/**
 * Get my ongoing games
 * Get the ongoing games of the current user.
 * Real-time and correspondence games are included.
 * The most urgent games are listed first.
 *
 */ const apiAccountPlaying = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account/playing',
        ...options
    });
};
/**
 * Stream moves of a game
 * Stream positions and moves of any ongoing game, in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * A description of the game is sent as a first message.
 * Then a message is sent each time a move is played.
 * Finally a description of the game is sent when it finishes, and the stream is closed.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 * No more than 8 game streams can be opened at the same time from the same IP address.
 *
 */ const streamGame = (options)=>{
    return (options.client ?? client).get({
        url: '/api/stream/game/{id}',
        ...options
    });
};
/**
 * Import one game
 * Import a game from PGN. See <https://lichess.org/paste>.
 * Rate limiting: 200 games per hour for OAuth requests, 100 games per hour for anonymous requests.
 * To broadcast ongoing games, consider [pushing to a broadcast instead](#operation/broadcastPush).
 * To analyse a position or a line, just construct an analysis board URL:
 * [https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+](https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+)
 *
 */ const gameImport = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/import',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Export your imported games
 * Download all games imported by you. Games are exported in PGN format.
 */ const apiImportedGamesUser = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/games/export/imports',
        ...options
    });
};
/**
 * Export your bookmarked games
 * Download all games bookmarked by you, in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by reverse chronological order (most recent first).
 * We recommend streaming the response, for it can be very long.
 *
 */ const apiExportBookmarks = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/games/export/bookmarks',
        ...options
    });
};
/**
 * Get current TV games
 * Get basic info about the best games being played for each speed and variant,
 * but also computer games and bot games.
 * See [lichess.org/tv](https://lichess.org/tv).
 *
 */ const tvChannels = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/tv/channels',
        ...options
    });
};
/**
 * Stream current TV game
 * Stream positions and moves of the current [TV game](https://lichess.org/tv) in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Try it with `curl https://lichess.org/api/tv/feed`.
 *
 */ const tvFeed = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/tv/feed',
        ...options
    });
};
/**
 * Stream current TV game of a TV channel
 * Stream positions and moves of a current [TV channel's game](https://lichess.org/tv/rapid) in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Try it with `curl https://lichess.org/api/tv/rapid/feed`.
 *
 */ const tvChannelFeed = (options)=>{
    return (options.client ?? client).get({
        url: '/api/tv/{channel}/feed',
        ...options
    });
};
/**
 * Get best ongoing games of a TV channel
 * Get a list of ongoing games for a given TV channel. Similar to [lichess.org/games](https://lichess.org/games).
 * Available in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
 *
 */ const tvChannelGames = (options)=>{
    return (options.client ?? client).get({
        url: '/api/tv/{channel}',
        ...options
    });
};
/**
 * Get current tournaments
 * Get recently active and finished tournaments.
 * This API is used to display the [Lichess tournament schedule](https://lichess.org/tournament).
 *
 */ const apiTournament = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/tournament',
        ...options
    });
};
/**
 * Create a new Arena tournament
 * Create a public or private Arena tournament.
 * This endpoint mirrors the form on <https://lichess.org/tournament/new>.
 * You can create up to 12 public tournaments per day, or 24 private tournaments.
 * A team battle can be created by specifying the `teamBattleByTeam` argument.
 * Additional restrictions:
 * - clockTime + clockIncrement > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 * - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150
 *
 */ const apiTournamentPost = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Get info about an Arena tournament
 * Get detailed info about recently finished, current, or upcoming tournament's duels, player standings, and other info.
 *
 */ const tournament = (options)=>{
    return (options.client ?? client).get({
        url: '/api/tournament/{id}',
        ...options
    });
};
/**
 * Update an Arena tournament
 * Update an Arena tournament.
 * Be mindful not to make important changes to ongoing tournaments.
 * Can be used to update a team battle.
 * Additional restrictions:
 * - clockTime + clockIncrement > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 * - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150
 *
 */ const apiTournamentUpdate = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Join an Arena tournament
 * Join an Arena tournament, possibly with a password and/or a team.
 * Also unpauses if you had previously [paused](#operation/apiTournamentWithdraw) the tournament.
 *
 */ const apiTournamentJoin = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament/{id}/join',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Pause or leave an Arena tournament
 * Leave a future Arena tournament, or take a break on an ongoing Arena tournament.
 * It's possible to join again later. Points and streaks are preserved.
 *
 */ const apiTournamentWithdraw = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament/{id}/withdraw',
        ...options
    });
};
/**
 * Terminate an Arena tournament
 * Terminate an Arena tournament
 *
 */ const apiTournamentTerminate = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament/{id}/terminate',
        ...options
    });
};
/**
 * Update a team battle
 * Set the teams and number of leaders of a team battle.
 * To update the other attributes of a team battle, use the [tournament update endpoint](#operation/apiTournamentUpdate).
 *
 */ const apiTournamentTeamBattlePost = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament/team-battle/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Export games of an Arena tournament
 * Download games of a tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by reverse chronological order (most recent first).
 * The game stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 games per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
 *
 */ const gamesByTournament = (options)=>{
    return (options.client ?? client).get({
        url: '/api/tournament/{id}/games',
        ...options
    });
};
/**
 * Get results of an Arena tournament
 * Players of an Arena tournament, with their score and performance, sorted by rank (best first).
 * **Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON)**, i.e. one JSON object per line.
 * If called on an ongoing tournament, results can be inconsistent
 * due to ranking changes while the players are being streamed.
 * Use on finished tournaments for guaranteed consistency.
 *
 */ const resultsByTournament = (options)=>{
    return (options.client ?? client).get({
        url: '/api/tournament/{id}/results',
        ...options
    });
};
/**
 * Get team standing of a team battle
 * Teams of a team battle tournament, with top players, sorted by rank (best first).
 *
 */ const teamsByTournament = (options)=>{
    return (options.client ?? client).get({
        url: '/api/tournament/{id}/teams',
        ...options
    });
};
/**
 * Get tournaments created by a user
 * Get all tournaments created by a given user.
 * Tournaments are sorted by reverse chronological order of start date (last starting first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * The stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 tournaments per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 tournaments per second
 * - Authenticated, downloading your own tournaments: 50 games per second
 *
 */ const apiUserNameTournamentCreated = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/user/{username}/tournament/created',
        ...options
    });
};
/**
 * Get tournaments played by a user
 * Get all tournaments played by a given user.
 * Tournaments are sorted by reverse chronological order of start date (last played first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * The stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 tournaments per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 tournaments per second
 * - Authenticated, downloading your own tournaments: 50 games per second
 *
 */ const apiUserNameTournamentPlayed = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/user/{username}/tournament/played',
        ...options
    });
};
/**
 * Create a new Swiss tournament
 * Create a Swiss tournament for your team.
 * This endpoint mirrors the Swiss tournament form from your team pagee.
 * You can create up to 12 tournaments per day.
 * Additional restrictions:
 * - clock.limit + clock.increment > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 *
 */ const apiSwissNew = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/new/{teamId}',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Get info about a Swiss tournament
 * Get detailed info about a Swiss tournament.
 *
 */ const swiss = (options)=>{
    return (options.client ?? client).get({
        url: '/api/swiss/{id}',
        ...options
    });
};
/**
 * Update a Swiss tournament
 * Update a Swiss tournament.
 * Be mindful not to make important changes to ongoing tournaments.
 * Additional restrictions:
 * - clock.limit + clock.increment > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 *
 */ const apiSwissUpdate = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/{id}/edit',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Manually schedule the next round
 * Manually schedule the next round date and time of a Swiss tournament.
 * This sets the `roundInterval` field to `99999999`, i.e. manual scheduling.
 * All further rounds will need to be manually scheduled, unless the `roundInterval` field is changed back to automatic scheduling.
 *
 */ const apiSwissScheduleNextRound = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/{id}/schedule-next-round',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Join a Swiss tournament
 * Join a Swiss tournament, possibly with a password.
 *
 */ const apiSwissJoin = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/{id}/join',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Pause or leave a swiss tournament
 * Leave a future Swiss tournament, or take a break on an ongoing Swiss tournament.
 * It's possible to join again later. Points are preserved.
 *
 */ const apiSwissWithdraw = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/{id}/withdraw',
        ...options
    });
};
/**
 * Terminate a Swiss tournament
 * Terminate a Swiss tournament
 *
 */ const apiSwissTerminate = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/{id}/terminate',
        ...options
    });
};
/**
 * Export TRF of a Swiss tournament
 * Download a tournament in the Tournament Report File format, the FIDE standard.
 * Documentation: <https://www.fide.com/FIDE/handbook/C04Annex2_TRF16.pdf>
 * Example: <https://lichess.org/swiss/j8rtJ5GL.trf>
 *
 */ const swissTrf = (options)=>{
    return (options.client ?? client).get({
        url: '/swiss/{id}.trf',
        ...options
    });
};
/**
 * Export games of a Swiss tournament
 * Download games of a swiss tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by chronological order.
 * The game stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 games per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
 *
 */ const gamesBySwiss = (options)=>{
    return (options.client ?? client).get({
        url: '/api/swiss/{id}/games',
        ...options
    });
};
/**
 * Get results of a swiss tournament
 * Players of a swiss tournament, with their score and performance, sorted by rank (best first).
 * Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * If called on an ongoing tournament, results can be inconsistent
 * due to ranking changes while the players are being streamed.
 * Use on finished tournaments for guaranteed consistency.
 *
 */ const resultsBySwiss = (options)=>{
    return (options.client ?? client).get({
        url: '/api/swiss/{id}/results',
        ...options
    });
};
/**
 * Get team swiss tournaments
 * Get all swiss tournaments of a team.
 * Tournaments are sorted by reverse chronological order of start date (last starting first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */ const apiTeamSwiss = (options)=>{
    return (options.client ?? client).get({
        url: '/api/team/{teamId}/swiss',
        ...options
    });
};
/**
 * Export one study chapter
 * Download one study chapter in PGN format.
 *
 */ const studyChapterPgn = (options)=>{
    return (options.client ?? client).get({
        url: '/api/study/{studyId}/{chapterId}.pgn',
        ...options
    });
};
/**
 * Export all chapters
 * Download all chapters of a study in PGN format.
 *
 */ const studyAllChaptersPgn = (options)=>{
    return (options.client ?? client).get({
        url: '/api/study/{studyId}.pgn',
        ...options
    });
};
/**
 * Study metadata
 * Only get the study headers, including `Last-Modified`.
 *
 */ const studyAllChaptersHead = (options)=>{
    return (options.client ?? client).head({
        url: '/api/study/{studyId}.pgn',
        ...options
    });
};
/**
 * Import PGN into a study
 * Imports arbitrary PGN into an existing [study](https://lichess.org/study). Creates a new chapter in the study.
 * If the PGN contains multiple games (separated by 2 or more newlines)
 * then multiple chapters will be created within the study.
 * Note that a study can contain at most 64 chapters.
 *
 */ const apiStudyImportPgn = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/study/{studyId}/import-pgn',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Export all studies of a user
 * Download all chapters of all studies of a user in PGN format.
 * If authenticated, then all public, unlisted, and private studies are included.
 * If not, only public (non-unlisted) studies are included.
 *
 */ const studyExportAllPgn = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/study/by/{username}/export.pgn',
        ...options
    });
};
/**
 * List studies of a user
 * Get metadata (name and dates) of all studies of a user.
 * If authenticated, then all public, unlisted, and private studies are included.
 * If not, only public (non-unlisted) studies are included.
 * Studies are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */ const studyListMetadata = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/study/by/{username}',
        ...options
    });
};
/**
 * Delete a study chapter
 * Delete a chapter of a study you own. This is definitive.
 * A study must have at least one chapter; so if you delete the last chapter,
 * an empty one will be automatically created to replace it.
 *
 */ const apiStudyStudyIdChapterIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/study/{studyId}/{chapterId}',
        ...options
    });
};
/**
 * Get official broadcasts
 * Get all incoming, ongoing, and finished official broadcasts.
 * The broadcasts are sorted by start date, most recent first.
 * Broadcasts are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */ const broadcastsOfficial = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/broadcast',
        ...options
    });
};
/**
 * Get paginated top broadcast previews
 * The same data, in the same order, as can be seen on [https://lichess.org/broadcast](/broadcast).
 *
 */ const broadcastsTop = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/broadcast/top',
        ...options
    });
};
/**
 * Get broadcasts created by a user
 * Get all incoming, ongoing, and finished official broadcasts.
 * The broadcasts are sorted by created date, most recent first.
 *
 */ const broadcastsByUser = (options)=>{
    return (options.client ?? client).get({
        url: '/api/broadcast/by/{username}',
        ...options
    });
};
/**
 * Create a broadcast tournament
 * Create a new broadcast tournament to relay external games.
 * This endpoint accepts the same form data as the [web form](https://lichess.org/broadcast/new).
 *
 */ const broadcastTourCreate = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/broadcast/new',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Get a broadcast tournament
 * Get information about a broadcast tournament.
 *
 */ const broadcastTourGet = (options)=>{
    return (options.client ?? client).get({
        url: '/api/broadcast/{broadcastTournamentId}',
        ...options
    });
};
/**
 * Get players of a broadcast
 * Get the list of players of a broadcast tournament, if available.
 *
 */ const broadcastPlayersGet = (options)=>{
    return (options.client ?? client).get({
        url: '/broadcast/{broadcastTournamentId}/players',
        ...options
    });
};
/**
 * Update your broadcast tournament
 * Update information about a broadcast tournament that you created.
 * This endpoint accepts the same form data as the web form.
 * All fields must be populated with data. Missing fields will override the broadcast with empty data.
 *
 */ const broadcastTourUpdate = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/broadcast/{broadcastTournamentId}/edit',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Create a broadcast round
 * Create a new broadcast round to relay external games.
 * This endpoint accepts the same form data as the web form.
 *
 * Choose one between `syncUrl`, `syncUrls`, `syncIds` and `syncUsers`, if it is missing, the broadcast needs to be fed by [pushing PGN to it](#operation/broadcastPush)
 *
 */ const broadcastRoundCreate = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/broadcast/{broadcastTournamentId}/new',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Get a broadcast round
 * Get information about a broadcast round.
 *
 */ const broadcastRoundGet = (options)=>{
    return (options.client ?? client).get({
        url: '/api/broadcast/{broadcastTournamentSlug}/{broadcastRoundSlug}/{broadcastRoundId}',
        ...options
    });
};
/**
 * Update a broadcast round
 * Update information about a broadcast round.
 * This endpoint accepts the same form data as the web form.
 * All fields must be populated with data. Missing fields will override the broadcast with empty data.
 * For instance, if you omit `startDate`, then any pre-existing start date will be removed.
 *
 */ const broadcastRoundUpdate = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/broadcast/round/{broadcastRoundId}/edit',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Reset a broadcast round
 * Remove any games from the broadcast round and reset it to its initial state.
 *
 */ const broadcastRoundReset = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/broadcast/round/{broadcastRoundId}/reset',
        ...options
    });
};
/**
 * Push PGN to a broadcast round
 * Update a broadcast with new PGN.
 * Only for broadcasts without a source URL.
 *
 */ const broadcastPush = (options)=>{
    return (options.client ?? client).post({
        bodySerializer: null,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/broadcast/round/{broadcastRoundId}/push',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};
/**
 * Stream an ongoing broadcast tournament as PGN
 * This streaming endpoint first sends all games of a broadcast tournament in PGN format.
 * Then, it waits for new moves to be played. As soon as it happens, the entire PGN of the game is sent to the stream.
 * The stream will also send PGNs when games are added to the tournament.
 * This is the best way to get updates about an ongoing tournament. Streaming means no polling,
 * and no pollings means no latency, and minimum impact on the server.
 *
 */ const broadcastStreamRoundPgn = (options)=>{
    return (options.client ?? client).get({
        url: '/api/stream/broadcast/round/{broadcastRoundId}.pgn',
        ...options
    });
};
/**
 * Export one round as PGN
 * Download all games of a single round of a broadcast tournament in PGN format.
 * You *could* poll this endpoint to get updates about a tournament, but it would be slow,
 * and very inefficient.
 * Instead, consider [streaming the tournament](#operation/broadcastStreamRoundPgn) to get
 * a new PGN every time a game is updated, in real-time.
 *
 */ const broadcastRoundPgn = (options)=>{
    return (options.client ?? client).get({
        url: '/api/broadcast/round/{broadcastRoundId}.pgn',
        ...options
    });
};
/**
 * Export all rounds as PGN
 * Download all games of all rounds of a broadcast in PGN format.
 * If a `study:read` [OAuth token](#tag/OAuth) is provided,
 * the private rounds where the user is a contributor will be available.
 * You may want to [download only the games of a single round](#operation/broadcastRoundPgn) instead.
 *
 */ const broadcastAllRoundsPgn = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/broadcast/{broadcastTournamentId}.pgn',
        ...options
    });
};
/**
 * Get your broadcast rounds
 * Stream all broadcast rounds you are a member of.
 * Also includes broadcasts rounds you did not create, but were invited to.
 * Also includes broadcasts rounds where you're a non-writing member. See the `writeable` flag in the response.
 * Rounds are ordered by rank, which is roughly chronological, most recent first, slightly pondered with popularity.
 *
 */ const broadcastMyRoundsGet = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/broadcast/my-rounds',
        ...options
    });
};
/**
 * Get a FIDE player
 * Get information about a FIDE player.
 *
 */ const fidePlayerGet = (options)=>{
    return (options.client ?? client).get({
        url: '/api/fide/player/{playerId}',
        ...options
    });
};
/**
 * Search FIDE players
 * List of FIDE players search results for a query.
 *
 */ const fidePlayerSearch = (options)=>{
    return (options.client ?? client).get({
        url: '/api/fide/player',
        ...options
    });
};
/**
 * Get current simuls
 * Get recently created, started, finished, simuls.
 * Created and finished simul lists are not exhaustives, only those with
 * strong enough host will be listed, the same filter is used to display simuls on https://lichess.org/simul.
 * When [authenticated with OAuth2](#section/Introduction/Authentication), the pending list will be populated with your created, but unstarted simuls.
 *
 */ const apiSimul = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/simul',
        ...options
    });
};
/**
 * Get a single team
 * Public info about a team. Includes the list of publicly visible leaders.
 */ const teamShow = (options)=>{
    return (options.client ?? client).get({
        url: '/api/team/{teamId}',
        ...options
    });
};
/**
 * Get popular teams
 * Paginator of the most popular teams.
 *
 */ const teamAll = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/team/all',
        ...options
    });
};
/**
 * Teams of a player
 * All the teams a player is a member of.
 *
 */ const teamOfUsername = (options)=>{
    return (options.client ?? client).get({
        url: '/api/team/of/{username}',
        ...options
    });
};
/**
 * Search teams
 * Paginator of team search results for a keyword.
 *
 */ const teamSearch = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/team/search',
        ...options
    });
};
/**
 * Get members of a team
 * Members are sorted by reverse chronological order of joining the team (most recent first).
 * OAuth is only required if the list of members is private.
 * Up to 5,000 users are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */ const teamIdUsers = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/team/{teamId}/users',
        ...options
    });
};
/**
 * Get team Arena tournaments
 * Get all Arena tournaments relevant to a team.
 * Tournaments are sorted by reverse chronological order of start date (last starting first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */ const apiTeamArena = (options)=>{
    return (options.client ?? client).get({
        url: '/api/team/{teamId}/arena',
        ...options
    });
};
/**
 * Join a team
 * Join a team.
 * If the team requires a password but the `password` field is incorrect,
 * then the call fails with `403 Forbidden`.
 * Similarly, if the team join policy requires a confirmation but the
 * `message` parameter is not given, then the call fails with
 * `403 Forbidden`.
 *
 */ const teamIdJoin = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/team/{teamId}/join',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Leave a team
 * Leave a team.
 * - <https://lichess.org/team>
 *
 */ const teamIdQuit = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/team/{teamId}/quit',
        ...options
    });
};
/**
 * Get join requests
 * Get pending join requests of your team
 */ const teamRequests = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/team/{teamId}/requests',
        ...options
    });
};
/**
 * Accept join request
 * Accept someone's request to join your team
 */ const teamRequestAccept = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/team/{teamId}/request/{userId}/accept',
        ...options
    });
};
/**
 * Decline join request
 * Decline someone's request to join your team
 */ const teamRequestDecline = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/team/{teamId}/request/{userId}/decline',
        ...options
    });
};
/**
 * Kick a user from your team
 * Kick a member out of one of your teams.
 * - <https://lichess.org/team>
 *
 */ const teamIdKickUserId = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/team/{teamId}/kick/{userId}',
        ...options
    });
};
/**
 * Message all members
 * Send a private message to all members of a team.
 * You must be a team leader with the "Messages" permission.
 *
 */ const teamIdPmAll = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/team/{teamId}/pm-all',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Get live streamers
 * Get basic info about currently streaming users.
 * This API is very fast and cheap on lichess side.
 * So you can call it quite often (like once every 5 seconds).
 *
 */ const streamerLive = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/streamer/live',
        ...options
    });
};
/**
 * Get crosstable
 * Get total number of games, and current score, of any two users.
 * If the `matchup` flag is provided, and the users are currently playing, also gets the current match game number and scores.
 *
 */ const apiCrosstable = (options)=>{
    return (options.client ?? client).get({
        url: '/api/crosstable/{user1}/{user2}',
        ...options
    });
};
/**
 * Autocomplete usernames
 * Provides autocompletion options for an incomplete username.
 *
 */ const apiPlayerAutocomplete = (options)=>{
    return (options.client ?? client).get({
        url: '/api/player/autocomplete',
        ...options
    });
};
/**
 * Get notes for a user
 * Get the private notes that you have added for a user.
 *
 */ const readNote = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/user/{username}/note',
        ...options
    });
};
/**
 * Add a note for a user
 * Add a private note available only to you about this account.
 *
 */ const writeNote = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/user/{username}/note',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Get users followed by the logged in user
 * Users are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */ const apiUserFollowing = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/rel/following',
        ...options
    });
};
/**
 * Follow a player
 * Follow a player, adding them to your list of Lichess friends.
 *
 */ const followUser = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/rel/follow/{username}',
        ...options
    });
};
/**
 * Unfollow a player
 * Unfollow a player, removing them from your list of Lichess friends.
 *
 */ const unfollowUser = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/rel/unfollow/{username}',
        ...options
    });
};
/**
 * Block a player
 * Block a player, adding them to your list of blocked Lichess users.
 *
 */ const blockUser = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/rel/block/{username}',
        ...options
    });
};
/**
 * Unblock a player
 * Unblock a player, removing them from your list of blocked Lichess users.
 *
 */ const unblockUser = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/rel/unblock/{username}',
        ...options
    });
};
/**
 * Stream incoming events
 * Stream the events reaching a lichess user in real time as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 * An empty line is sent every 6 seconds for keep alive purposes.
 *
 * Each non-empty line is a JSON object containing a `type` field. Possible values are:
 * - `gameStart` Start of a game
 * - `gameFinish` Completion of a game
 * - `challenge` A player sends you a challenge or you challenge someone
 * - `challengeCanceled` A player cancels their challenge to you
 * - `challengeDeclined` The opponent declines your challenge
 *
 * When the stream opens, all current challenges and games are sent.
 *
 */ const apiStreamEvent = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/stream/event',
        ...options
    });
};
/**
 * Create a seek
 * Create a public seek, to start a game with a random player.
 *
 * ### Real-time seek
 *
 * Specify the `time` and `increment` clock values.
 * The response is streamed but doesn't contain any information.
 *
 * **Keep the connection open to keep the seek active**.
 *
 * If the client closes the connection, the seek is canceled. This way, if the client terminates, the user won't be paired in a game they wouldn't play.
 * When the seek is accepted, or expires, the server closes the connection.
 *
 * **Make sure to also have an [Event stream](#operation/apiStreamEvent) open**, to be notified when a game starts.
 * We recommend opening the [Event stream](#operation/apiStreamEvent) first, then the seek stream. This way,
 * you won't miss the game event if the seek is accepted immediately.
 *
 * ### Correspondence seek
 *
 * Specify the `days` per turn value.
 * The response is not streamed, it immediately completes with the seek ID. The seek remains active on the server until it is joined by someone.
 *
 */ const apiBoardSeek = (options)=>{
    return (options?.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/seek',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Stream Board game state
 * Stream the state of a game being played with the Board API, as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 * Use this endpoint to get updates about the game in real-time, with a single request.
 *
 * Each line is a JSON object containing a `type` field. Possible values are:
 * - `gameFull` Full game data. All values are immutable, except for the `state` field.
 * - `gameState` Current state of the game. Immutable values not included. Sent when a move is played, a draw is offered, or when the game ends.
 * - `chatLine` Chat message sent by a user in the `room` "player" or "spectator".
 * - `opponentGone` Whether the opponent has left the game, and how long before you can claim a win or draw.
 *
 * The first line is always of type `gameFull`.
 *
 * The server closes the stream when the game ends, or if the game has already ended.
 *
 */ const boardGameStream = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/stream/{gameId}',
        ...options
    });
};
/**
 * Make a Board move
 * Make a move in a game being played with the Board API.
 * The move can also contain a draw offer/agreement.
 *
 */ const boardGameMove = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/move/{move}',
        ...options
    });
};
/**
 * Fetch the game chat
 * Get the messages posted in the game chat
 *
 */ const boardGameChatGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/chat',
        ...options
    });
};
/**
 * Write in the chat
 * Post a message to the player or spectator chat, in a game being played with the Board API.
 *
 */ const boardGameChatPost = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/chat',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Abort a game
 * Abort a game being played with the Board API.
 *
 */ const boardGameAbort = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/abort',
        ...options
    });
};
/**
 * Resign a game
 * Resign a game being played with the Board API.
 *
 */ const boardGameResign = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/resign',
        ...options
    });
};
/**
 * Handle draw offers
 * Create/accept/decline draw offers.
 * - `yes`: Offer a draw, or accept the opponent's draw offer.
 * - `no`: Decline a draw offer from the opponent.
 *
 */ const boardGameDraw = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/draw/{accept}',
        ...options
    });
};
/**
 * Handle takeback offers
 * Create/accept/decline takebacks.
 * - `yes`: Propose a takeback, or accept the opponent's takeback offer.
 * - `no`: Decline a takeback offer from the opponent.
 *
 */ const boardGameTakeback = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/takeback/{accept}',
        ...options
    });
};
/**
 * Claim victory of a game
 * Claim victory when the opponent has left the game for a while.
 *
 */ const boardGameClaimVictory = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/claim-victory',
        ...options
    });
};
/**
 * Berserk a tournament game
 * Go berserk on an arena tournament game. Halves the clock time, grants an extra point upon winning.
 * Only available in arena tournaments that allow berserk, and before each player has made a move.
 *
 */ const boardGameBerserk = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/berserk',
        ...options
    });
};
/**
 * Get online bots
 * Stream the [online bot users](https://lichess.org/player/bots), as [ndjson](#section/Introduction/Streaming-with-ND-JSON). Throttled to 50 bot users per second.
 */ const apiBotOnline = (options)=>{
    return (options?.client ?? client).get({
        url: '/api/bot/online',
        ...options
    });
};
/**
 * Upgrade to Bot account
 * Upgrade a lichess player account into a Bot account. Only Bot accounts can use the Bot API.
 * The account **cannot have played any game** before becoming a Bot account. The upgrade is **irreversible**. The account will only be able to play as a Bot.
 * To upgrade an account to Bot, use the [official lichess-bot client](https://github.com/lichess-bot-devs/lichess-bot), or follow these steps:
 * - Create an [API access token](https://lichess.org/account/oauth/token/create?scopes[]=bot:play) with "Play bot moves" permission.
 * - `curl -d '' https://lichess.org/api/bot/account/upgrade -H "Authorization: Bearer <yourTokenHere>"`
 * To know if an account has already been upgraded, use the [Get my profile API](#operation/accountMe):
 * the `title` field should be set to `BOT`.
 *
 */ const botAccountUpgrade = (options)=>{
    return (options?.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/account/upgrade',
        ...options
    });
};
/**
 * Stream Bot game state
 * Stream the state of a game being played with the Bot API, as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Use this endpoint to get updates about the game in real-time, with a single request.
 * Each line is a JSON object containing a `type` field. Possible values are:
 * - `gameFull` Full game data. All values are immutable, except for the `state` field.
 * - `gameState` Current state of the game. Immutable values not included.
 * - `chatLine` Chat message sent by a user (or the bot itself) in the `room` "player" or "spectator".
 * - `opponentGone` Whether the opponent has left the game, and how long before you can claim a win or draw.
 * The first line is always of type `gameFull`.
 *
 */ const botGameStream = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/stream/{gameId}',
        ...options
    });
};
/**
 * Make a Bot move
 * Make a move in a game being played with the Bot API.
 * The move can also contain a draw offer/agreement.
 *
 */ const botGameMove = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/move/{move}',
        ...options
    });
};
/**
 * Fetch the game chat
 * Get the messages posted in the game chat
 *
 */ const botGameChatGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/chat',
        ...options
    });
};
/**
 * Write in the chat
 * Post a message to the player or spectator chat, in a game being played with the Bot API.
 *
 */ const botGameChat = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/chat',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Abort a game
 * Abort a game being played with the Bot API.
 *
 */ const botGameAbort = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/abort',
        ...options
    });
};
/**
 * Resign a game
 * Resign a game being played with the Bot API.
 *
 */ const botGameResign = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/resign',
        ...options
    });
};
/**
 * Handle draw offers
 * Create/accept/decline draw offers with the Bot API.
 * - `yes`: Offer a draw, or accept the opponent's draw offer.
 * - `no`: Decline a draw offer from the opponent.
 *
 */ const botGameDraw = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/draw/{accept}',
        ...options
    });
};
/**
 * Handle takeback offers
 * Create/accept/decline takebacks with the Bot API.
 * - `yes`: Propose a takeback, or accept the opponent's takeback offer.
 * - `no`: Decline a takeback offer from the opponent.
 *
 */ const botGameTakeback = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/takeback/{accept}',
        ...options
    });
};
/**
 * Claim victory of a game
 * Claim victory when the opponent has left the game for a while.
 *
 */ const botGameClaimVictory = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/claim-victory',
        ...options
    });
};
/**
 * List your challenges
 * Get a list of challenges created by or targeted at you.
 *
 */ const challengeList = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge',
        ...options
    });
};
/**
 * Create a challenge
 * Challenge someone to play. The targeted player can choose to accept or decline.
 * If the challenge is accepted, you will be notified on the [event stream](#operation/apiStreamEvent)
 * that a new game has started. The game ID will be the same as the challenge ID.
 * Challenges for realtime games (not correspondence) expire after 20s if not accepted.
 * To prevent that, use the `keepAliveStream` flag described below.
 *
 */ const challengeCreate = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{username}',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Show one challenge
 * Get details about a challenge, even if it has been recently accepted, canceled or declined.
 *
 */ const challengeShow = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{challengeId}/show',
        ...options
    });
};
/**
 * Accept a challenge
 * Accept an incoming challenge.
 * You should receive a `gameStart` event on the [incoming events stream](#operation/apiStreamEvent).
 *
 */ const challengeAccept = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{challengeId}/accept',
        ...options
    });
};
/**
 * Decline a challenge
 * Decline an incoming challenge.
 *
 */ const challengeDecline = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{challengeId}/decline',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Cancel a challenge
 * Cancel a challenge you sent, or aborts the game if the challenge was accepted, but the game was not yet played.
 * Note that the ID of a game is the same as the ID of the challenge that created it.
 * Works for user challenges and open challenges alike.
 *
 */ const challengeCancel = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{challengeId}/cancel',
        ...options
    });
};
/**
 * Challenge the AI
 * Start a game with Lichess AI.
 * You will be notified on the [event stream](#operation/apiStreamEvent) that a new game has started.
 *
 */ const challengeAi = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/ai',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Open-ended challenge
 * Create a challenge that any 2 players can join.
 * Share the URL of the challenge. the first 2 players to click it will be paired for a game.
 * The response body also contains `whiteUrl` and `blackUrl`.
 * You can control which color each player gets by giving them these URLs,
 * instead of the main challenge URL.
 * Open challenges expire after 24h.
 * If the challenge creation is [authenticated with OAuth2](#section/Introduction/Authentication),
 * then you can use the [challenge cancel endpoint](#operation/challengeCancel) to cancel it.
 * To directly pair 2 known players, use [this endpoint](#operation/bulkPairingList) instead.
 *
 */ const challengeOpen = (options)=>{
    return (options?.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        url: '/api/challenge/open',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Start clocks of a game
 * Start the clocks of a game immediately, even if a player has not yet made a move.
 * Requires the OAuth tokens of both players with `challenge:write` scope.
 * If the clocks have already started, the call will have no effect.
 *
 * For AI games with only one player, omit the `token2` parameter.
 *
 */ const challengeStartClocks = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{gameId}/start-clocks',
        ...options
    });
};
/**
 * View your bulk pairings
 * Get a list of bulk pairings you created.
 *
 */ const bulkPairingList = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing',
        ...options
    });
};
/**
 * Create a bulk pairing
 * Schedule many games at once, up to 24h in advance.
 * OAuth tokens are required for all paired players, with the `challenge:write` scope.
 * You can schedule up to 500 games every 10 minutes. [Contact us](mailto:contact@lichess.org) if you need higher limits.
 * If games have a real-time clock, each player must have only one pairing.
 * For correspondence games, players can have multiple pairings within the same bulk.
 *
 * **The entire bulk is rejected if:**
 * - a token is missing
 * - a token is present more than once (except in correspondence)
 * - a token lacks the `challenge:write` scope
 * - a player account is closed
 * - a player is paired more than once (except in correspondence)
 * - a bulk is already scheduled to start at the same time with the same player
 * - you have 20 scheduled bulks
 * - you have 1000 scheduled games
 *
 * Partial bulks are never created. Either it all fails, or it all succeeds.
 * When it fails, it does so with an error message explaining the issue.
 * Failed bulks are not counted in the rate limiting, they are free.
 * Fix the issues, manually or programmatically, then retry to schedule the bulk.
 * A successful bulk creation returns a JSON bulk document. Its ID can be used for further operations.
 *
 */ const bulkPairingCreate = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Manually start clocks
 * Immediately start all clocks of the games of a bulk pairing.
 * This overrides the `startClocksAt` value of an existing bulk pairing.
 * If the games have not yet been created (`bulk.pairAt` is in the future), then this does nothing.
 * If the clocks have already started (`bulk.startClocksAt` is in the past), then this does nothing.
 *
 */ const bulkPairingStartClocks = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing/{id}/start-clocks',
        ...options
    });
};
/**
 * Cancel a bulk pairing
 * Cancel and delete a bulk pairing that is scheduled in the future.
 * If the games have already been created, then this does nothing.
 * Canceling a bulk pairing does not refund the rate limit cost of that bulk pairing.
 *
 */ const bulkPairingDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing/{id}',
        ...options
    });
};
/**
 * Show a bulk pairing
 * Get a single bulk pairing by its ID.
 *
 */ const bulkPairingGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing/{id}',
        ...options
    });
};
/**
 * Export games of a bulk pairing
 * Download games of a bulk in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
 *
 */ const bulkPairingIdGamesGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing/{id}/games',
        ...options
    });
};
/**
 * Add time to the opponent clock
 * Add seconds to the opponent's clock. Can be used to create games with time odds.
 *
 */ const roundAddTime = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/round/{gameId}/add-time/{seconds}',
        ...options
    });
};
/**
 * Admin challenge tokens
 * **This endpoint can only be used by Lichess administrators. It will not work if you do not have the appropriate permissions.** Tournament organizers should instead use [OAuth](#tag/OAuth) to obtain `challenge:write` tokens from users in order to perform bulk pairing.*
 * Create and obtain `challenge:write` tokens for multiple users.
 * If a similar token already exists for a user, it is reused. This endpoint is idempotent.
 *
 */ const adminChallengeTokens = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/token/admin-challenge',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Send a private message
 * Send a private message to another player.
 *
 */ const inboxUsername = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/inbox/{username}',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Get cloud evaluation of a position.
 * Get the cached evaluation of a position, if available.
 * Opening positions have more chances of being available. There are about 15 million positions in the database.
 * Up to 5 variations may be available. Variants are supported.
 * Use this endpoint to fetch a few positions here and there.
 * If you want to download a lot of positions, [get the full list](https://database.lichess.org/#evals) from our exported database.
 *
 */ const apiCloudEval = (options)=>{
    return (options.client ?? client).get({
        url: '/api/cloud-eval',
        ...options
    });
};
/**
 * List external engines
 * Lists all external engines that have been registered for the user,
 * and the credentials required to use them.
 *
 */ const apiExternalEngineList = (options)=>{
    return (options?.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/external-engine',
        ...options
    });
};
/**
 * Create external engine
 * Registers a new external engine for the user. It can then be selected
 * and used on the analysis board.
 * After registering, the provider should start waiting for analyis requests.
 *
 */ const apiExternalEngineCreate = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/external-engine',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
/**
 * Delete external engine
 * Unregisters an external engine.
 *
 */ const apiExternalEngineDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/external-engine/{id}',
        ...options
    });
};
/**
 * Get external engine
 * Get properties and credentials of an external engine.
 *
 */ const apiExternalEngineGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/external-engine/{id}',
        ...options
    });
};
/**
 * Update external engine
 * Updates the properties of an external engine.
 *
 */ const apiExternalEnginePut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/external-engine/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
/**
 * Analyse with external engine
 * **Endpoint: `https://engine.lichess.ovh/api/external-engine/{id}/analyse`**
 * Request analysis from an external engine.
 * Response content is streamed as [newline delimited JSON](#section/Introduction/Streaming-with-ND-JSON).
 * The properties are based on the [UCI specification](https://backscattering.de/chess/uci/#engine).
 * Analysis stops when the client goes away, the requested limit
 * is reached, or the provider goes away.
 *
 */ const apiExternalEngineAnalyse = (options)=>{
    return (options.client ?? client).post({
        url: '/api/external-engine/{id}/analyse',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
/**
 * Acquire analysis request
 * **Endpoint: `https://engine.lichess.ovh/api/external-engine/work`**
 * Wait for an analysis requests to any of the external engines that
 * have been registered with the given `secret`.
 * Uses long polling.
 * After acquiring a request, the provider should immediately
 * [start streaming the results](#tag/External-engine/operation/apiExternalEngineSubmit).
 *
 */ const apiExternalEngineAcquire = (options)=>{
    return (options.client ?? client).post({
        url: '/api/external-engine/work',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
/**
 * Answer analysis request
 * **Endpoint: `https://engine.lichess.ovh/api/external-engine/work/{id}`**
 * Submit a stream of analysis as [UCI output](https://backscattering.de/chess/uci/#engine-info).
 * * The engine should always be in `UCI_Chess960` mode.
 * * `UCI_AnalyseMode` enabled if available.
 * * It produces `info` with at least:
 * - `depth`
 * - `multipv` (between 1 and 5)
 * - `score`
 * - `nodes`
 * - `time`
 * - `pv`
 * The server may close the connection at any time, indicating that
 * the requester has gone away and analysis should be stopped.
 *
 */ const apiExternalEngineSubmit = (options)=>{
    return (options.client ?? client).post({
        bodySerializer: null,
        url: '/api/external-engine/work/{id}',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};
/**
 * Request authorization code
 * OAuth2 authorization endpoint.
 * Start the OAuth2 Authorization Code Flow with PKCE by securely
 * generating two random strings unique to each authorization
 * request:
 *
 * * `code_verifier`
 * * `state`
 *
 * Store these in session storage. Make sure not to reveal `code_verifier`
 * to eavesdroppers. Do not show it in URLs, do not abuse `state` to store
 * it, do not send it over insecure connections. However it is fine if
 * the user themselves can extract `code_verifier`, which will always be
 * possible for fully client-side apps.
 * Then send the user to this endpoint. They will be prompted to grant
 * authorization and then be redirected back to the given `redirect_uri`.
 * If the authorization failed, the following query string parameters will
 * be appended to the redirection:
 *
 * * `error`, in particular with value `access_denied` if the user
 * cancelled authorization
 * * `error_description` to aid debugging
 * * `state`, exactly as passed in the `state` parameter
 *
 * If the authorization succeeded, the following query string parameters
 * will be appended to the redirection:
 *
 * * `code`, containing a fresh short-lived authorization code
 * * `state`, exactly as passed in the `state` parameter
 *
 * Next, to defend against cross site request forgery, check that the
 * returned `state` matches the `state` you originally generated.
 *
 * Finally, continue by using the authorization code to
 * [obtain an access token](#operation/apiToken).
 *
 */ const oauth = (options)=>{
    return (options.client ?? client).get({
        url: '/oauth',
        ...options
    });
};
/**
 * Revoke access token
 * Revokes the access token sent as Bearer for this request.
 */ const apiTokenDelete = (options)=>{
    return (options?.client ?? client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/token',
        ...options
    });
};
/**
 * Obtain access token
 * OAuth2 token endpoint. Exchanges an authorization code for an access token.
 *
 */ const apiToken = (options)=>{
    return (options.client ?? client).post({
        ...clientFetch.urlSearchParamsBodySerializer,
        url: '/api/token',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};
/**
 * Test multiple OAuth tokens
 * For up to 1000 OAuth tokens,
 * returns their associated user ID and scopes,
 * or `null` if the token is invalid.
 * The method is `POST` so a longer list of tokens can be sent in the request body.
 *
 */ const tokenTest = (options)=>{
    return (options.client ?? client).post({
        bodySerializer: null,
        url: '/api/token/test',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};
/**
 * Masters database
 * **Endpoint: <https://explorer.lichess.ovh/masters>**
 *
 * Example: `curl https://explorer.lichess.ovh/masters?play=d2d4,d7d5,c2c4,c7c6,c4d5`
 *
 */ const openingExplorerMaster = (options)=>{
    return (options?.client ?? client).get({
        url: '/masters',
        ...options
    });
};
/**
 * Lichess games
 * **Endpoint: <https://explorer.lichess.ovh/lichess>**
 *
 * Games sampled from all Lichess players.
 *
 * Example: `curl https://explorer.lichess.ovh/lichess?variant=standard&speeds=blitz,rapid,classical&ratings=2200,2500&fen=rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR%20w%20KQkq%20-%200%201`
 *
 */ const openingExplorerLichess = (options)=>{
    return (options?.client ?? client).get({
        url: '/lichess',
        ...options
    });
};
/**
 * Player games
 * **Endpoint: <https://explorer.lichess.ovh/player>**
 *
 * Games of a Lichess player.
 *
 * Responds with a stream of [newline delimited JSON](#section/Introduction/Streaming-with-ND-JSON). Will start indexing
 * on demand, immediately respond with the current results, and stream
 * more updates until indexing is complete. The stream is throttled
 * and deduplicated. Empty lines may be sent to avoid timeouts.
 *
 * Will index new games at most once per minute, and revisit previously
 * ongoing games at most once every day.
 *
 * Example: `curl https://explorer.lichess.ovh/player?player=revoof&color=white&play=d2d4,d7d5&recentGames=1`
 *
 */ const openingExplorerPlayer = (options)=>{
    return (options.client ?? client).get({
        url: '/player',
        ...options
    });
};
/**
 * OTB master game
 * **Endpoint: `https://explorer.lichess.ovh/masters/pgn/{gameId}`**
 *
 * Example: `curl https://explorer.lichess.ovh/masters/pgn/aAbqI4ey`
 *
 */ const openingExplorerMasterGame = (options)=>{
    return (options.client ?? client).get({
        url: '/master/pgn/{gameId}',
        ...options
    });
};
/**
 * Tablebase lookup
 * **Endpoint: <https://tablebase.lichess.ovh>**
 * Example: `curl http://tablebase.lichess.ovh/standard?fen=4k3/6KP/8/8/8/8/7p/8_w_-_-_0_1`
 *
 */ const tablebaseStandard = (options)=>{
    return (options.client ?? client).get({
        url: '/standard',
        ...options
    });
};
/**
 * Tablebase lookup for Atomic chess
 * **Endpoint: <https://tablebase.lichess.ovh>**
 *
 */ const tablebaseAtomic = (options)=>{
    return (options?.client ?? client).get({
        url: '/atomic',
        ...options
    });
};
/**
 * Tablebase lookup for Antichess
 * **Endpoint: <https://tablebase.lichess.ovh>**
 *
 */ const antichessAtomic = (options)=>{
    return (options?.client ?? client).get({
        url: '/antichess',
        ...options
    });
};

const initialize = (apiToken)=>{
    if (!apiToken) {
        throw new Error("Lichess API token is not set. If you don't have one, generate from https://lichess.org/account/oauth/token.\n" + 'For more information, see https://github.com/lichess-org/api/blob/master/example/README.md.');
    }
    client.setConfig({
        headers: {
            Authorization: `Bearer ${apiToken}`
        }
    });
};

exports.account = account;
exports.accountEmail = accountEmail;
exports.accountKid = accountKid;
exports.accountKidPost = accountKidPost;
exports.accountMe = accountMe;
exports.adminChallengeTokens = adminChallengeTokens;
exports.antichessAtomic = antichessAtomic;
exports.apiAccountPlaying = apiAccountPlaying;
exports.apiBoardSeek = apiBoardSeek;
exports.apiBotOnline = apiBotOnline;
exports.apiCloudEval = apiCloudEval;
exports.apiCrosstable = apiCrosstable;
exports.apiExportBookmarks = apiExportBookmarks;
exports.apiExternalEngineAcquire = apiExternalEngineAcquire;
exports.apiExternalEngineAnalyse = apiExternalEngineAnalyse;
exports.apiExternalEngineCreate = apiExternalEngineCreate;
exports.apiExternalEngineDelete = apiExternalEngineDelete;
exports.apiExternalEngineGet = apiExternalEngineGet;
exports.apiExternalEngineList = apiExternalEngineList;
exports.apiExternalEnginePut = apiExternalEnginePut;
exports.apiExternalEngineSubmit = apiExternalEngineSubmit;
exports.apiGamesUser = apiGamesUser;
exports.apiImportedGamesUser = apiImportedGamesUser;
exports.apiPlayerAutocomplete = apiPlayerAutocomplete;
exports.apiPuzzleActivity = apiPuzzleActivity;
exports.apiPuzzleDaily = apiPuzzleDaily;
exports.apiPuzzleDashboard = apiPuzzleDashboard;
exports.apiPuzzleId = apiPuzzleId;
exports.apiPuzzleNext = apiPuzzleNext;
exports.apiPuzzleReplay = apiPuzzleReplay;
exports.apiSimul = apiSimul;
exports.apiStormDashboard = apiStormDashboard;
exports.apiStreamEvent = apiStreamEvent;
exports.apiStudyImportPgn = apiStudyImportPgn;
exports.apiStudyStudyIdChapterIdDelete = apiStudyStudyIdChapterIdDelete;
exports.apiSwissJoin = apiSwissJoin;
exports.apiSwissNew = apiSwissNew;
exports.apiSwissScheduleNextRound = apiSwissScheduleNextRound;
exports.apiSwissTerminate = apiSwissTerminate;
exports.apiSwissUpdate = apiSwissUpdate;
exports.apiSwissWithdraw = apiSwissWithdraw;
exports.apiTeamArena = apiTeamArena;
exports.apiTeamSwiss = apiTeamSwiss;
exports.apiToken = apiToken;
exports.apiTokenDelete = apiTokenDelete;
exports.apiTournament = apiTournament;
exports.apiTournamentJoin = apiTournamentJoin;
exports.apiTournamentPost = apiTournamentPost;
exports.apiTournamentTeamBattlePost = apiTournamentTeamBattlePost;
exports.apiTournamentTerminate = apiTournamentTerminate;
exports.apiTournamentUpdate = apiTournamentUpdate;
exports.apiTournamentWithdraw = apiTournamentWithdraw;
exports.apiUser = apiUser;
exports.apiUserActivity = apiUserActivity;
exports.apiUserCurrentGame = apiUserCurrentGame;
exports.apiUserFollowing = apiUserFollowing;
exports.apiUserNameTournamentCreated = apiUserNameTournamentCreated;
exports.apiUserNameTournamentPlayed = apiUserNameTournamentPlayed;
exports.apiUserPerf = apiUserPerf;
exports.apiUserRatingHistory = apiUserRatingHistory;
exports.apiUsers = apiUsers;
exports.apiUsersStatus = apiUsersStatus;
exports.blockUser = blockUser;
exports.boardGameAbort = boardGameAbort;
exports.boardGameBerserk = boardGameBerserk;
exports.boardGameChatGet = boardGameChatGet;
exports.boardGameChatPost = boardGameChatPost;
exports.boardGameClaimVictory = boardGameClaimVictory;
exports.boardGameDraw = boardGameDraw;
exports.boardGameMove = boardGameMove;
exports.boardGameResign = boardGameResign;
exports.boardGameStream = boardGameStream;
exports.boardGameTakeback = boardGameTakeback;
exports.botAccountUpgrade = botAccountUpgrade;
exports.botGameAbort = botGameAbort;
exports.botGameChat = botGameChat;
exports.botGameChatGet = botGameChatGet;
exports.botGameClaimVictory = botGameClaimVictory;
exports.botGameDraw = botGameDraw;
exports.botGameMove = botGameMove;
exports.botGameResign = botGameResign;
exports.botGameStream = botGameStream;
exports.botGameTakeback = botGameTakeback;
exports.broadcastAllRoundsPgn = broadcastAllRoundsPgn;
exports.broadcastMyRoundsGet = broadcastMyRoundsGet;
exports.broadcastPlayersGet = broadcastPlayersGet;
exports.broadcastPush = broadcastPush;
exports.broadcastRoundCreate = broadcastRoundCreate;
exports.broadcastRoundGet = broadcastRoundGet;
exports.broadcastRoundPgn = broadcastRoundPgn;
exports.broadcastRoundReset = broadcastRoundReset;
exports.broadcastRoundUpdate = broadcastRoundUpdate;
exports.broadcastStreamRoundPgn = broadcastStreamRoundPgn;
exports.broadcastTourCreate = broadcastTourCreate;
exports.broadcastTourGet = broadcastTourGet;
exports.broadcastTourUpdate = broadcastTourUpdate;
exports.broadcastsByUser = broadcastsByUser;
exports.broadcastsOfficial = broadcastsOfficial;
exports.broadcastsTop = broadcastsTop;
exports.bulkPairingCreate = bulkPairingCreate;
exports.bulkPairingDelete = bulkPairingDelete;
exports.bulkPairingGet = bulkPairingGet;
exports.bulkPairingIdGamesGet = bulkPairingIdGamesGet;
exports.bulkPairingList = bulkPairingList;
exports.bulkPairingStartClocks = bulkPairingStartClocks;
exports.challengeAccept = challengeAccept;
exports.challengeAi = challengeAi;
exports.challengeCancel = challengeCancel;
exports.challengeCreate = challengeCreate;
exports.challengeDecline = challengeDecline;
exports.challengeList = challengeList;
exports.challengeOpen = challengeOpen;
exports.challengeShow = challengeShow;
exports.challengeStartClocks = challengeStartClocks;
exports.fidePlayerGet = fidePlayerGet;
exports.fidePlayerSearch = fidePlayerSearch;
exports.followUser = followUser;
exports.gameImport = gameImport;
exports.gamePgn = gamePgn;
exports.gamesByIds = gamesByIds;
exports.gamesByIdsAdd = gamesByIdsAdd;
exports.gamesBySwiss = gamesBySwiss;
exports.gamesByTournament = gamesByTournament;
exports.gamesByUsers = gamesByUsers;
exports.gamesExportIds = gamesExportIds;
exports.inboxUsername = inboxUsername;
exports.initialize = initialize;
exports.oauth = oauth;
exports.openingExplorerLichess = openingExplorerLichess;
exports.openingExplorerMaster = openingExplorerMaster;
exports.openingExplorerMasterGame = openingExplorerMasterGame;
exports.openingExplorerPlayer = openingExplorerPlayer;
exports.player = player;
exports.playerTopNbPerfType = playerTopNbPerfType;
exports.racerPost = racerPost;
exports.readNote = readNote;
exports.resultsBySwiss = resultsBySwiss;
exports.resultsByTournament = resultsByTournament;
exports.roundAddTime = roundAddTime;
exports.streamGame = streamGame;
exports.streamerLive = streamerLive;
exports.studyAllChaptersHead = studyAllChaptersHead;
exports.studyAllChaptersPgn = studyAllChaptersPgn;
exports.studyChapterPgn = studyChapterPgn;
exports.studyExportAllPgn = studyExportAllPgn;
exports.studyListMetadata = studyListMetadata;
exports.swiss = swiss;
exports.swissTrf = swissTrf;
exports.tablebaseAtomic = tablebaseAtomic;
exports.tablebaseStandard = tablebaseStandard;
exports.teamAll = teamAll;
exports.teamIdJoin = teamIdJoin;
exports.teamIdKickUserId = teamIdKickUserId;
exports.teamIdPmAll = teamIdPmAll;
exports.teamIdQuit = teamIdQuit;
exports.teamIdUsers = teamIdUsers;
exports.teamOfUsername = teamOfUsername;
exports.teamRequestAccept = teamRequestAccept;
exports.teamRequestDecline = teamRequestDecline;
exports.teamRequests = teamRequests;
exports.teamSearch = teamSearch;
exports.teamShow = teamShow;
exports.teamsByTournament = teamsByTournament;
exports.timeline = timeline;
exports.tokenTest = tokenTest;
exports.tournament = tournament;
exports.tvChannelFeed = tvChannelFeed;
exports.tvChannelGames = tvChannelGames;
exports.tvChannels = tvChannels;
exports.tvFeed = tvFeed;
exports.unblockUser = unblockUser;
exports.unfollowUser = unfollowUser;
exports.writeNote = writeNote;
