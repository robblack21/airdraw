import * as _hey_api_client_fetch from '@hey-api/client-fetch';
import { TDataShape, Options as Options$1, Client } from '@hey-api/client-fetch';

type Top10S = unknown;
type Leaderboard = unknown;
type Perf = {
    games?: number;
    rating?: number;
    rd?: number;
    prog?: number;
    /**
     * only appears if a user's perf rating are [provisional](https://lichess.org/faq#provisional)
     */
    prov?: boolean;
};
type PuzzleModePerf = {
    runs?: number;
    score?: number;
};
type Perfs = {
    chess960?: Perf;
    atomic?: Perf;
    racingKings?: Perf;
    ultraBullet?: Perf;
    blitz?: Perf;
    kingOfTheHill?: Perf;
    bullet?: Perf;
    correspondence?: Perf;
    horde?: Perf;
    puzzle?: Perf;
    classical?: Perf;
    rapid?: Perf;
    storm?: PuzzleModePerf;
    racer?: PuzzleModePerf;
    streak?: PuzzleModePerf;
};
/**
 * See [available flair list and images](https://github.com/lichess-org/lila/tree/master/public/flair)
 */
type Flair = string;
type Profile = {
    flag?: string;
    location?: string;
    bio?: string;
    realName?: string;
    /**
     * only appears if a user has set them
     */
    fideRating?: number;
    /**
     * only appears if a user has set them
     */
    uscfRating?: number;
    /**
     * only appears if a user has set them
     */
    ecfRating?: number;
    /**
     * only appears if a user has set them
     */
    cfcRating?: number;
    /**
     * only appears if a user has set them
     */
    dsbRating?: number;
    links?: string;
};
type PlayTime = {
    total?: number;
    tv?: number;
};
/**
 * only appears if the user is a titled player or a bot user
 */
type Title = 'GM' | 'WGM' | 'IM' | 'WIM' | 'FM' | 'WFM' | 'NM' | 'CM' | 'WCM' | 'WNM' | 'LM' | 'BOT';
type User = {
    id: string;
    username: string;
    perfs?: Perfs;
    flair?: Flair;
    createdAt?: number;
    /**
     * only appears if a user's account is closed
     */
    disabled?: boolean;
    /**
     * only appears if a user's account is marked for the violation of [Lichess TOS](https://lichess.org/terms-of-service)
     */
    tosViolation?: boolean;
    profile?: Profile;
    seenAt?: number;
    patron?: boolean;
    verified?: boolean;
    playTime?: PlayTime;
    title?: Title;
};
type Count = {
    all?: number;
    rated?: number;
    ai?: number;
    draw?: number;
    drawH?: number;
    loss?: number;
    lossH?: number;
    win?: number;
    winH?: number;
    bookmark?: number;
    playing?: number;
    import?: number;
    me?: number;
};
type UserExtended = User & {
    url?: string;
    playing?: string;
    count?: Count;
    streaming?: boolean;
    streamer?: {
        twitch?: {
            channel?: string;
        };
        youTube?: {
            channel?: string;
        };
    };
    /**
     * only appears if the request is [authenticated with OAuth2](#section/Introduction/Authentication)
     */
    followable?: boolean;
    /**
     * only appears if the request is [authenticated with OAuth2](#section/Introduction/Authentication)
     */
    following?: boolean;
    /**
     * only appears if the request is [authenticated with OAuth2](#section/Introduction/Authentication)
     */
    blocking?: boolean;
};
type RatingHistory = unknown;
type PerfType = 'ultraBullet' | 'bullet' | 'blitz' | 'rapid' | 'classical' | 'correspondence' | 'chess960' | 'crazyhouse' | 'antichess' | 'atomic' | 'horde' | 'kingOfTheHill' | 'racingKings' | 'threeCheck';
type PerfStat = unknown;
type UserActivityScore = {
    win: number;
    loss: number;
    draw: number;
    rp: {
        before?: number;
        after?: number;
    };
};
type VariantKey = 'standard' | 'chess960' | 'crazyhouse' | 'antichess' | 'atomic' | 'horde' | 'kingOfTheHill' | 'racingKings' | 'threeCheck' | 'fromPosition';
type UserActivityCorrespondenceGame = {
    id: string;
    color: 'white' | 'black';
    url: string;
    variant: VariantKey;
    speed: 'correspondence';
    perf: 'correspondence';
    rated: boolean;
    opponent: {
        user: string;
        rating: number;
    };
};
type UserActivityFollowList = {
    ids: Array<string>;
    nb?: number;
};
type UserActivity = {
    interval: {
        start: number;
        end: number;
    };
    games?: {
        chess960?: UserActivityScore;
        atomic?: UserActivityScore;
        racingKings?: UserActivityScore;
        ultraBullet?: UserActivityScore;
        blitz?: UserActivityScore;
        kingOfTheHill?: UserActivityScore;
        bullet?: UserActivityScore;
        correspondence?: UserActivityScore;
        horde?: UserActivityScore;
        puzzle?: UserActivityScore;
        classical?: UserActivityScore;
        rapid?: UserActivityScore;
    };
    puzzles?: {
        score?: UserActivityScore;
    };
    storm?: {
        runs?: number;
        score?: number;
    };
    racer?: {
        runs?: number;
        score?: number;
    };
    streak?: {
        runs?: number;
        score?: number;
    };
    tournaments?: {
        nb?: number;
        best?: Array<{
            tournament: {
                id: string;
                name: string;
            };
            nbGames: number;
            score: number;
            rank: number;
            rankPercent: number;
        }>;
    };
    practice?: Array<{
        url: string;
        name: string;
        nbPositions: number;
    }>;
    simuls?: Array<string>;
    correspondenceMoves?: {
        nb: number;
        games: Array<UserActivityCorrespondenceGame>;
    };
    correspondenceEnds?: {
        score: UserActivityScore;
        games: Array<UserActivityCorrespondenceGame>;
    };
    follows?: {
        in?: UserActivityFollowList;
        out?: UserActivityFollowList;
    };
    studies?: {
        [key: string]: unknown;
    };
    teams?: Array<{
        url: string;
        name: string;
    }>;
    posts?: Array<{
        topicUrl: string;
        topicName: string;
        posts: Array<{
            url: string;
            text: string;
        }>;
    }>;
    patron?: {
        months: number;
    };
    stream?: boolean;
};
type PuzzleAndGame = {
    game: {
        clock: string;
        id: string;
        perf: {
            key: PerfType;
            name: string;
        };
        pgn: string;
        players: Array<{
            color: string;
            flair?: Flair;
            id: string;
            name: string;
            patron?: boolean;
            rating: number;
            title?: Title;
        }>;
        rated: boolean;
    };
    puzzle: {
        id: string;
        initialPly: number;
        plays: number;
        rating: number;
        solution: Array<string>;
        themes: Array<string>;
    };
};
type PuzzleActivity = {
    date: number;
    puzzle: {
        fen: string;
        id: string;
        lastMove: string;
        plays: number;
        rating: number;
        solution: Array<string>;
        themes: Array<string>;
    };
    win: boolean;
};
type PuzzleReplay = {
    replay: {
        days: number;
        theme: string;
        nb: number;
        remaining: Array<string>;
    };
    angle: {
        key: string;
        name: string;
        desc: string;
    };
};
type PuzzlePerformance = {
    firstWins: number;
    nb: number;
    performance: number;
    puzzleRatingAvg: number;
    replayWins: number;
};
type PuzzleDashboard = {
    days: number;
    global: PuzzlePerformance;
    themes: {
        [key: string]: {
            results: PuzzlePerformance;
            theme: string;
        };
    };
};
type PuzzleStormDashboard = {
    days: Array<{
        _id: string;
        combo: number;
        errors: number;
        highest: number;
        moves: number;
        runs: number;
        score: number;
        time: number;
    }>;
    high: {
        allTime: number;
        day: number;
        month: number;
        week: number;
    };
};
type PuzzleRacer = {
    id: string;
    url: string;
};
type UserPreferences = {
    dark?: boolean;
    transp?: boolean;
    bgImg?: string;
    is3d?: boolean;
    theme?: 'blue' | 'blue2' | 'blue3' | 'blue-marble' | 'canvas' | 'wood' | 'wood2' | 'wood3' | 'wood4' | 'maple' | 'maple2' | 'brown' | 'leather' | 'green' | 'marble' | 'green-plastic' | 'grey' | 'metal' | 'olive' | 'newspaper' | 'purple' | 'purple-diag' | 'pink' | 'ic';
    pieceSet?: 'cburnett' | 'merida' | 'alpha' | 'pirouetti' | 'chessnut' | 'chess7' | 'reillycraig' | 'companion' | 'riohacha' | 'kosal' | 'leipzig' | 'fantasy' | 'spatial' | 'california' | 'pixel' | 'maestro' | 'fresca' | 'cardinal' | 'gioco' | 'tatiana' | 'staunty' | 'governor' | 'dubrovny' | 'icpieces' | 'shapes' | 'letter';
    theme3d?: 'Black-White-Aluminium' | 'Brushed-Aluminium' | 'China-Blue' | 'China-Green' | 'China-Grey' | 'China-Scarlet' | 'Classic-Blue' | 'Gold-Silver' | 'Light-Wood' | 'Power-Coated' | 'Rosewood' | 'Marble' | 'Wax' | 'Jade' | 'Woodi';
    pieceSet3d?: 'Basic' | 'Wood' | 'Metal' | 'RedVBlue' | 'ModernJade' | 'ModernWood' | 'Glass' | 'Trimmed' | 'Experimental' | 'Staunton' | 'CubesAndPi';
    soundSet?: 'silent' | 'standard' | 'piano' | 'nes' | 'sfx' | 'futuristic' | 'robot' | 'music' | 'speech';
    blindfold?: number;
    autoQueen?: number;
    autoThreefold?: number;
    takeback?: number;
    moretime?: number;
    clockTenths?: number;
    clockBar?: boolean;
    clockSound?: boolean;
    premove?: boolean;
    animation?: number;
    captured?: boolean;
    follow?: boolean;
    highlight?: boolean;
    destination?: boolean;
    coords?: number;
    replay?: number;
    challenge?: number;
    message?: number;
    coordColor?: number;
    submitMove?: number;
    confirmResign?: number;
    insightShare?: number;
    keyboardMove?: number;
    zen?: number;
    moveEvent?: number;
    rookCastle?: number;
};
type Ok = {
    ok?: boolean;
};
type TimelineEntryFollow = {
    type: 'follow';
    date: number;
    data: {
        u1: string;
        u2: string;
    };
};
type TimelineEntryTeamJoin = {
    type: 'team-join';
    date: number;
    data: {
        userId: string;
        teamId: string;
    };
};
type TimelineEntryTeamCreate = {
    type: 'team-create';
    date: number;
    data: {
        userId: string;
        teamId: string;
    };
};
type TimelineEntryForumPost = {
    type: 'forum-post';
    date: number;
    data: {
        userId: string;
        topicId: string;
        topicName: string;
        postId: string;
    };
};
type TimelineEntryBlogPost = {
    type: 'blog-post';
    date: number;
    data: {
        id: string;
        slug: string;
        title: string;
    };
};
type TimelineEntryUblogPost = {
    type: 'ublog-post';
    date: number;
    data: {
        userId: string;
        id: string;
        slug: string;
        title: string;
    };
};
type TimelineEntryTourJoin = {
    type: 'tour-join';
    date: number;
    data: {
        userId: string;
        tourId: string;
        tourName: string;
    };
};
type TimelineEntryGameEnd = {
    type: 'game-end';
    date: number;
    data: {
        fullId: string;
        opponent: string;
        win: boolean;
        perf: PerfType;
    };
};
type TimelineEntrySimul = {
    type: 'simul-create' | 'simul-join';
    date: number;
    data: {
        userId: string;
        simulId: string;
        simulName: string;
    };
};
type TimelineEntryStudyLike = {
    type: 'study-like';
    date: number;
    data: {
        userId: string;
        studyId: string;
        studyName: string;
    };
};
type TimelineEntryPlanStart = {
    type: 'plan-start';
    date: number;
    data: {
        userId: string;
    };
};
type TimelineEntryPlanRenew = {
    type: 'plan-renew';
    date: number;
    data: {
        userId: string;
        months: number;
    };
};
type TimelineEntryUblogPostLike = {
    type: 'ublog-post-like';
    date: number;
    data: {
        userId: string;
        id: string;
        title: string;
    };
};
type TimelineEntryStreamStart = {
    type: 'stream-start';
    date: number;
    data: {
        id: string;
        name?: string;
    };
};
type Timeline = {
    entries: Array<({
        type?: 'follow';
    } & TimelineEntryFollow) | ({
        type?: 'team-join';
    } & TimelineEntryTeamJoin) | ({
        type?: 'team-create';
    } & TimelineEntryTeamCreate) | ({
        type?: 'forum-post';
    } & TimelineEntryForumPost) | ({
        type?: 'blog-post';
    } & TimelineEntryBlogPost) | ({
        type?: 'ublog-post';
    } & TimelineEntryUblogPost) | ({
        type?: 'tour-join';
    } & TimelineEntryTourJoin) | ({
        type?: 'game-end';
    } & TimelineEntryGameEnd) | ({
        type?: 'simul-create';
    } & TimelineEntrySimul) | ({
        type?: 'study-like';
    } & TimelineEntryStudyLike) | ({
        type?: 'plan-start';
    } & TimelineEntryPlanStart) | ({
        type?: 'plan-renew';
    } & TimelineEntryPlanRenew) | ({
        type?: 'ublog-post-like';
    } & TimelineEntryUblogPostLike) | ({
        type?: 'stream-start';
    } & TimelineEntryStreamStart)>;
    users: {
        [key: string]: {
            id: string;
            name: string;
            title?: Title;
            patron?: boolean;
        };
    };
};
type GamePgn = string;
type Speed = 'ultraBullet' | 'bullet' | 'blitz' | 'rapid' | 'classical' | 'correspondence';
/**
 * Game status code. https://github.com/lichess-org/scalachess/blob/0a7d6f2c63b1ca06cd3c958ed3264e738af5c5f6/src/main/scala/Status.scala#L16-L28
 */
type GameStatus = 'created' | 'started' | 'aborted' | 'mate' | 'resign' | 'stalemate' | 'timeout' | 'draw' | 'outoftime' | 'cheat' | 'noStart' | 'unknownFinish' | 'variantEnd';
type LightUser = {
    id: string;
    name: string;
    title?: Title;
    patron?: boolean;
};
type GameUser = {
    user?: LightUser;
    rating?: number;
    ratingDiff?: number;
    name?: string;
    provisional?: boolean;
    aiLevel?: number;
    analysis?: {
        inaccuracy: number;
        mistake: number;
        blunder: number;
        acpl: number;
        accuracy?: number;
    };
    team?: string;
};
type GameMoveAnalysis = {
    /**
     * Evaluation in centipawns
     */
    eval?: number;
    /**
     * Number of moves until forced mate
     */
    mate?: number;
    /**
     * Best move in UCI notation (only if played move was inaccurate)
     */
    best?: string;
    /**
     * Best variation in SAN notation (only if played move was inaccurate)
     */
    variation?: string;
    /**
     * Judgment annotation (only if played move was inaccurate)
     */
    judgment?: {
        name?: 'Inaccuracy' | 'Mistake' | 'Blunder';
        comment?: string;
    };
};
type GameJson = {
    id: string;
    rated: boolean;
    variant: VariantKey;
    speed: Speed;
    perf: string;
    createdAt: number;
    lastMoveAt: number;
    status: GameStatus;
    players: {
        white: GameUser;
        black: GameUser;
    };
    initialFen?: string;
    winner?: 'white' | 'black';
    opening?: {
        eco?: string;
        name?: string;
        ply?: number;
    };
    moves?: string;
    pgn?: string;
    daysPerTurn?: number;
    analysis?: Array<GameMoveAnalysis>;
    tournament?: string;
    swiss?: string;
    clock?: {
        initial: number;
        increment: number;
        totalTime: number;
    };
    clocks?: Array<number>;
    division?: {
        /**
         * Ply at which the middlegame begins
         */
        middle?: number;
        /**
         * Ply at which the endgame begins
         */
        end?: number;
    };
};
type GameStream = unknown;
type GameSource = 'lobby' | 'friend' | 'ai' | 'api' | 'tournament' | 'position' | 'import' | 'importlive' | 'simul' | 'relay' | 'pool' | 'swiss';
type Variant = {
    key?: VariantKey;
    name?: string;
    short?: string;
};
type MoveStream = unknown;
type TvGame = {
    user: LightUser & {
        flair?: Flair;
    };
    rating: number;
    gameId: string;
    color: 'white' | 'black';
};
type TvFeed = {
    /**
     * The type of message.
     * A summary of the game is sent as the first message and when the featured game changes.
     * Subsequent messages are just the FEN, last move, and clocks.
     *
     */
    t: 'featured' | 'fen';
    /**
     * The data of the message
     */
    d: {
        /**
         * The game ID
         */
        id: string;
        orientation: 'white' | 'black';
        players: [
            {
                color: 'white' | 'black';
                user: {
                    name: string;
                    id: string;
                    title?: string;
                };
                rating: number;
                /**
                 * The player's remaining time in seconds
                 */
                seconds: number;
            },
            {
                color: 'white' | 'black';
                user: {
                    name: string;
                    id: string;
                    title?: string;
                };
                rating: number;
                /**
                 * The player's remaining time in seconds
                 */
                seconds: number;
            }
        ];
        /**
         * The FEN of the current position
         */
        fen: string;
    } | {
        /**
         * The FEN of the current position
         */
        fen: string;
        /**
         * The last move in UCI format
         */
        lm: string;
        /**
         * White's clock in seconds
         */
        wc: number;
        /**
         * Black's clock in seconds
         */
        bc: number;
    };
};
type Clock = {
    limit?: number;
    increment?: number;
};
/**
 * 10: created, 20: started, 30: finished
 *
 */
type ArenaStatus = 10 | 20 | 30;
type ArenaPerf = {
    key?: string;
    name?: string;
    position?: number;
    icon?: string;
};
type ArenaRatingObj = {
    perf?: PerfType;
    rating?: number;
};
type ArenaPosition = {
    eco?: string;
    name?: string;
    fen?: string;
    url?: string;
} | {
    name?: 'Custom position';
    fen?: string;
};
type ArenaTournament = {
    id?: string;
    createdBy?: string;
    system?: 'arena';
    minutes?: number;
    clock?: Clock;
    rated?: boolean;
    fullName?: string;
    nbPlayers?: number;
    variant?: Variant;
    startsAt?: number;
    finishesAt?: number;
    status?: ArenaStatus;
    perf?: ArenaPerf;
    secondsToStart?: number;
    hasMaxRating?: boolean;
    maxRating?: ArenaRatingObj;
    minRating?: ArenaRatingObj;
    minRatedGames?: {
        nb?: number;
    };
    botsAllowed?: boolean;
    minAccountAgeInDays?: number;
    onlyTitled?: boolean;
    teamMember?: string;
    private?: boolean;
    position?: ArenaPosition;
    schedule?: {
        freq?: string;
        speed?: string;
    };
    teamBattle?: {
        teams?: Array<string>;
        nbLeaders?: number;
    };
    winner?: {
        id?: string;
        name?: string;
        title?: Title;
    };
};
type ArenaTournaments = {
    created?: Array<ArenaTournament>;
    started?: Array<ArenaTournament>;
    finished?: Array<ArenaTournament>;
};
/**
 * Custom initial position (in FEN). Variant must be standard, fromPosition, or chess960 (if a valid 960 starting position), and the game cannot be rated.
 */
type FromPositionFen = string;
type Verdicts = {
    accepted: boolean;
    list: Array<{
        condition: string;
        verdict: string;
    }>;
};
type ArenaSheet = {
    scores: string;
    fire?: boolean;
};
type ArenaPlayerPerformance = {
    name?: string;
    rank?: number;
    title?: string;
    patron?: boolean;
    rating?: number;
    score?: number;
    flair?: Flair;
    sheet?: ArenaSheet;
    nb?: {
        game?: number;
        beserk?: number;
        win?: number;
    };
    performance?: number;
};
type ArenaTournamentFull = {
    id: string;
    fullName: string;
    rated?: boolean;
    spotlight?: {
        headline?: string;
    };
    berserkable?: boolean;
    onlyTitled?: boolean;
    clock: {
        increment: number;
        limit: number;
    };
    minutes?: number;
    createdBy?: string;
    system?: string;
    secondsToStart?: number;
    secondsToFinish?: number;
    isFinished: boolean;
    isRecentlyFinished?: boolean;
    pairingsClosed?: boolean;
    startsAt?: string;
    nbPlayers: number;
    verdicts?: Verdicts;
    /**
     * The quote displayed on the tournament page
     */
    quote?: {
        text?: string;
        author?: string;
    };
    /**
     * List of usernames allowed to join the tournament
     */
    allowList?: Array<string>;
    hasMaxRating?: boolean;
    maxRating?: ArenaRatingObj;
    minRating?: ArenaRatingObj;
    minRatedGames?: {
        nb?: number;
    };
    botsAllowed?: boolean;
    minAccountAgeInDays?: number;
    perf?: {
        icon: string;
        key: string;
        name: string;
    };
    schedule?: {
        freq: string;
        speed: string;
    };
    variant?: string;
    duels?: Array<{
        id?: string;
        p?: [
            {
                n?: string;
                r?: number;
                k?: number;
            },
            {
                n?: string;
                r?: number;
                k?: number;
            }
        ];
    }>;
    standing?: {
        page?: number;
        players?: Array<ArenaPlayerPerformance>;
    };
    featured?: {
        id?: string;
        fen?: string;
        orientation?: string;
        color?: string;
        lastMove?: string;
        white?: {
            name?: string;
            id?: string;
            rank?: number;
            rating?: number;
        };
        black?: {
            name?: string;
            id?: string;
            rank?: number;
            rating?: number;
        };
        c?: {
            /**
             * white's clock in seconds
             */
            white?: number;
            /**
             * black's clock in seconds
             */
            black?: number;
        };
    };
    podium?: Array<ArenaPlayerPerformance>;
    stats: {
        games: number;
        moves: number;
        whiteWins: number;
        blackWins: number;
        draws: number;
        berserks: number;
        averageRating: number;
    };
};
type _Error = {
    /**
     * The cause of the error.
     */
    error?: string;
};
type ArenaTournamentPlayed = {
    tournament?: ArenaTournament;
    player?: {
        games: number;
        score: number;
        rank: number;
        performance?: number;
    };
};
/**
 * Custom initial position (in FEN). Variant must be standard and the game cannot be rated.
 */
type SwissFromPositionFen = string;
/**
 * The current state of the swiss tournament
 */
type SwissStatus = 'created' | 'started' | 'finished';
type SwissTournament = {
    id: string;
    createdBy: string;
    startsAt: string;
    name: string;
    clock: {
        limit: number;
        increment: number;
    };
    variant: string;
    round: number;
    nbRounds: number;
    nbPlayers: number;
    nbOngoing: number;
    status: SwissStatus;
    stats: {
        games: number;
        whiteWins: number;
        blackWins: number;
        draws: number;
        byes: number;
        absences: number;
        averageRating: number;
    };
    rated: boolean;
    verdicts: Verdicts;
};
type SwissUnauthorisedEdit = {
    error?: string;
};
type StudyPgn = unknown;
type StudyImportPgnChapters = {
    chapters?: Array<{
        /**
         * The chapter ID
         */
        id?: string;
        /**
         * The chapter name
         */
        name?: string;
        players?: [
            {
                /**
                 * The player name
                 */
                name?: string | null;
                /**
                 * The player rating
                 */
                rating?: number;
            },
            {
                /**
                 * The player name
                 */
                name?: string | null;
                /**
                 * The player rating
                 */
                rating?: number;
            }
        ];
        /**
         * The chapter status
         */
        status?: string;
    }>;
};
type StudyMetadata = {
    /**
     * The study ID
     */
    id?: string;
    /**
     * The study name
     */
    name?: string;
    /**
     * The study creation date
     */
    createdAt?: number;
    /**
     * The study last update date
     */
    updatedAt?: number;
};
type BroadcastTour = {
    id: string;
    name: string;
    slug: string;
    createdAt: number;
    /**
     * Start and end dates of the tournament, as Unix timestamps in milliseconds
     */
    dates?: Array<number>;
    /**
     * Additional display information about the tournament
     */
    info?: {
        /**
         * Official website. External website URL
         */
        website?: string;
        /**
         * Featured players
         */
        players?: string;
        /**
         * Tournament location
         */
        location?: string;
        /**
         * Time control
         */
        tc?: string;
        /**
         * FIDE rating category
         */
        fideTc?: 'standard' | 'rapid' | 'blitz';
        /**
         * Timezone of the tournament. Example: `America/New_York`.
         * See [list of possible timezone identifiers](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for more.
         *
         */
        timeZone?: string;
        /**
         * Official standings website. External website URL
         */
        standings?: string;
        /**
         * Tournament format
         */
        format?: string;
    };
    /**
     * Used to designate featured tournaments on Lichess
     */
    tier?: number;
    image?: string;
    /**
     * Full tournament description in markdown format, or in HTML if the html=1 query parameter is set.
     */
    description?: string;
    leaderboard?: boolean;
    teamTable?: boolean;
    url: string;
};
type BroadcastGroupTour = {
    name?: string;
    id?: string;
};
type BroadcastGroup = {
    name?: string;
    tours?: Array<BroadcastGroupTour>;
};
type BroadcastRoundInfo = {
    id: string;
    name: string;
    slug: string;
    createdAt: number;
    ongoing?: boolean;
    startsAt?: number;
    /**
     * The start date/time is unknown and the round will start automatically when the previous round completes
     */
    startsAfterPrevious?: boolean;
    finishedAt?: number;
    url: string;
    delay?: number;
};
type BroadcastWithRounds = {
    tour: BroadcastTour;
    group?: BroadcastGroup;
    rounds: Array<BroadcastRoundInfo>;
};
type BroadcastWithLastRound = {
    group?: string;
    tour?: BroadcastTour;
    round?: BroadcastRoundInfo;
};
type BroadcastTop = {
    active?: Array<BroadcastWithLastRound>;
    past?: {
        currentPage?: number;
        maxPerPage?: number;
        currentPageResults?: Array<BroadcastWithLastRound>;
        previousPage?: number | null;
        nextPage?: number | null;
    };
};
type BroadcastByUser = {
    tour: BroadcastTour;
    round: BroadcastRoundInfo;
};
type BroadcastForm = {
    /**
     * Name of the broadcast tournament.
     *
     * Example: `Sinquefield Cup`
     *
     */
    name: string;
    /**
     * Tournament format.
     * Example: `"8-player round-robin" or "5-round Swiss"`
     *
     */
    'info.format'?: string;
    /**
     * Tournament Location
     *
     */
    'info.location'?: string;
    /**
     * Time control.
     * Example: `"Classical" or "Rapid" or "Rapid & Blitz"`
     *
     */
    'info.tc'?: string;
    /**
     * FIDE rating category. Which FIDE ratings to use
     *
     */
    'info.fideTc'?: 'standard' | 'rapid' | 'blitz';
    /**
     * Timezone of the tournament. Example: `America/New_York`.
     * See [list of possible timezone identifiers](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for more.
     *
     */
    'info.timeZone'?: string;
    /**
     * Mention up to 4 of the best players participating.
     *
     */
    'info.players'?: string;
    /**
     * Official website. External website URL
     *
     */
    'info.website'?: string;
    /**
     * Official Standings. External website URL, e.g. chess-results.com, info64.org
     *
     */
    'info.standings'?: string;
    /**
     * Optional long description of the broadcast. Markdown is supported.
     *
     */
    markdown?: string;
    /**
     * Show players scores based on game results
     *
     */
    showScores?: boolean;
    /**
     * Show player's rating diffs
     *
     */
    showRatingDiffs?: boolean;
    /**
     * Show a team leaderboard. Requires WhiteTeam and BlackTeam PGN tags.
     *
     */
    teamTable?: boolean;
    /**
     * Optional replace player names, ratings and titles.
     *
     * One line per player, formatted as such:
     *
     * ```txt
     * player name = FIDE ID
     * ```
     *
     * Example:
     *
     * ```txt
     * Magnus Carlsen = 1503014
     * ```
     *
     * Player names ignore case and punctuation, and match all possible combinations of 2 words: "Jorge Rick Vito" will match "Jorge Rick", "jorge vito", "Rick, Vito", etc.
     *
     * If the player is NM or WNM, you can:
     *
     * ```txt
     * Player Name = FIDE ID / Title
     * ```
     *
     * Alternatively, you may set tags manually, like so:
     *
     * ```txt
     * player name / rating / title / new name
     * ```
     *
     * All values are optional. Example:
     * ```txt
     * Magnus Carlsen / 2863 / GM
     * YouGotLittUp / 1890 / / Louis Litt
     * ```
     *
     */
    players?: string;
    /**
     * Optional: assign players to teams
     *
     * One line per player, formatted as such:
     * ```txt
     * Team name; Fide Id or Player name
     * ```
     *
     * Example:
     * ```txt
     * Team Cats ; 3408230
     * Team Dogs ; Scooby Doo
     * ```
     *
     * By default the PGN tags WhiteTeam and BlackTeam are used.
     *
     */
    teams?: string;
    /**
     * Optional, for Lichess admins only, used to feature on /broadcast.
     *
     * * `3` for Official: normal tier
     * * `4` for Official: high tier
     * * `5` for Official: best tier
     * * `-1` for Private
     *
     */
    tier?: 3 | 4 | 5 | -1;
};
type BroadcastPlayerEntry = {
    name?: string;
    score?: number;
    played?: number;
    rating?: number;
    ratingDiff?: number;
    performance?: number;
    title?: string;
    fideId?: number;
    fed?: string;
};
/**
 * Name of the broadcast round.
 * Example: `Round 1`
 *
 */
type BroadcastRoundFormName = string;
type BroadcastRoundForm = ({
    name: BroadcastRoundFormName;
} | {
    name: BroadcastRoundFormName;
    /**
     * URL that Lichess will poll to get updates about the games. It must be publicly accessible from the Internet.
     *
     * Example:
     * ```txt
     * https://myserver.org/myevent/round-10/games.pgn
     * ```
     *
     */
    syncUrl: string;
    /**
     * Filter games by round number
     *
     * Optional, only keep games from the source that match a round number.
     * It uses the PGN **Round** tag. These would match round 3:
     * ```txt
     * [Round "3"]
     * [Round "3.1"]
     * ```
     * If you set a round number, then games without a **Round** tag are dropped.
     *
     * It only works if you chose `syncUrl` or `syncUrls` as the source.
     *
     */
    onlyRound?: number;
    /**
     * Select slices of the games
     *
     * Optional. Select games based on their position in the source.
     * ```txt
     * 1           only select the first board
     * 1-4         only select the first 4 boards
     * 1,2,3,4     same as above, first 4 boards
     * 11-15,21-25 boards 11 to 15, and boards 21 to 25
     * 2,3,7-9     boards 2, 3, 7, 8, and 9
     * ```
     * Slicing is done after filtering by round number.
     *
     * It only works if you chose `syncUrl` or `syncUrls` as the source.
     *
     */
    slices?: string;
} | {
    name: BroadcastRoundFormName;
    /**
     * URLs that Lichess will poll to get updates about the games, separated by newlines. They must be publicly accessible from the Internet.
     *
     * Example:
     * ```txt
     * https://myserver.org/myevent/round-10/game-1.pgn
     * https://myserver.org/myevent/round-10/game-2.pgn
     * ```
     *
     */
    syncUrls: string;
    /**
     * Filter games by round number
     *
     * Optional, only keep games from the source that match a round number.
     * It uses the PGN **Round** tag. These would match round 3:
     * ```txt
     * [Round "3"]
     * [Round "3.1"]
     * ```
     * If you set a round number, then games without a **Round** tag are dropped.
     *
     * It only works if you chose `syncUrl` or `syncUrls` as the source.
     *
     */
    onlyRound?: number;
    /**
     * Select slices of the games
     *
     * Optional. Select games based on their position in the source.
     * ```txt
     * 1           only select the first board
     * 1-4         only select the first 4 boards
     * 1,2,3,4     same as above, first 4 boards
     * 11-15,21-25 boards 11 to 15, and boards 21 to 25
     * 2,3,7-9     boards 2, 3, 7, 8, and 9
     * ```
     * Slicing is done after filtering by round number.
     *
     * It only works if you chose `syncUrl` or `syncUrls` as the source.
     *
     */
    slices?: string;
} | {
    name: BroadcastRoundFormName;
    /**
     * Lichess game IDs - Up to 64 Lichess game IDs, separated by spaces.
     *
     */
    syncIds: string;
} | {
    name: BroadcastRoundFormName;
    /**
     * Up to 100 Lichess usernames, separated by spaces
     *
     */
    syncUsers: string;
}) & {
    /**
     * Timestamp in milliseconds of broadcast round start. Leave empty to manually start the broadcast round.
     * Example: `1356998400070`
     *
     */
    startsAt?: number;
    /**
     * The start date is unknown, and the round will start automatically when the previous round completes.
     *
     */
    startsAfterPrevious?: boolean;
    /**
     * Delay in seconds for movements to appear on the broadcast. Leave it empty if you don't need it.
     * Example: `900` (15 min)
     *
     */
    delay?: number;
    /**
     * Lichess can usually detect the round status, but you can also set it manually if needed.
     *
     */
    status?: 'new' | 'started' | 'finished';
    /**
     * (Only for Admins) Waiting time for each poll.
     *
     */
    period?: number;
};
type BroadcastRoundStudyInfo = {
    /**
     * Whether the currently authenticated user has permission to update the study
     */
    writeable?: boolean;
};
type BroadcastRoundNew = {
    round: BroadcastRoundInfo;
    tour: BroadcastTour;
    study: BroadcastRoundStudyInfo;
};
type BroadcastRoundGame = {
    id: string;
    name: string;
    fen?: string;
    players?: Array<{
        name?: string;
        title?: string;
        rating?: number;
        clock?: number;
        fed?: string;
    }>;
    lastMove?: string;
    thinkTime?: number;
    /**
     * The result of the game
     */
    status?: '*' | '1-0' | '0-1' | '½-½';
};
type BroadcastRound = {
    round: BroadcastRoundInfo;
    tour: BroadcastTour;
    study: BroadcastRoundStudyInfo;
    games: Array<BroadcastRoundGame>;
    group?: BroadcastGroup;
};
type BroadcastPgnPushTags = {
    [key: string]: string;
};
type BroadcastPgnPush = {
    games: Array<{
        tags: BroadcastPgnPushTags;
        moves?: number;
        error?: string;
    }>;
};
type BroadcastMyRound = {
    round: BroadcastRoundInfo;
    tour: BroadcastTour;
    study: BroadcastRoundStudyInfo;
};
type FidePlayer = {
    id: number;
    name: string;
    title?: Title;
    federation: string;
    year?: number;
    inactive?: boolean;
    standard?: number;
    rapid?: number;
    blitz?: number;
};
type Simul = {
    id: string;
    host: LightUser & {
        rating?: number;
        provisional?: boolean;
        gameId?: string;
        online?: boolean;
    };
    name: string;
    fullName: string;
    variants: Array<Variant>;
    isCreated: boolean;
    isFinished: boolean;
    isRunning: boolean;
    text?: string;
    estimatedStartAt?: number;
    startedAt?: number;
    finishedAt?: number;
    nbApplicants: number;
    nbPairings: number;
};
type Team = {
    id: string;
    name: string;
    description?: string;
    flair?: Flair;
    leaders?: Array<LightUser>;
    nbMembers?: number;
    open?: boolean;
    joined?: boolean;
    requested?: boolean;
};
type TeamPaginatorJson = {
    currentPage?: number;
    maxPerPage?: number;
    currentPageResults?: Array<Team>;
    nbResults?: number;
    previousPage?: number | null;
    nextPage?: number | null;
    nbPages?: number;
};
/**
 * The current state of the arena tournament
 */
type ArenaStatusName = 'created' | 'started' | 'finished';
type TeamRequest = {
    teamId?: string;
    userId?: string;
    date?: number;
    message?: string;
};
type TeamRequestWithUser = {
    request?: TeamRequest;
    user?: User;
};
type Crosstable = unknown;
type LightUserOnline = LightUser & {
    online?: boolean;
};
type UserNote = {
    from?: LightUser;
    to?: LightUser;
    text?: string;
    date?: number;
};
type GameEventInfo = {
    id?: string;
    source?: GameSource;
    status?: {
        id?: 10 | 20 | 25 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 60;
        name?: GameStatus;
    };
    winner?: 'white' | 'black';
    compat?: {
        bot?: boolean;
        board?: boolean;
    };
};
type GameStartEvent = {
    type?: 'gameStart';
    game?: GameEventInfo;
};
type GameFinishEvent = {
    type?: 'gameFinish';
    game?: GameEventInfo;
};
type ChallengeUser = LightUser & {
    rating?: number;
    provisional?: boolean;
    online?: boolean;
    lag?: number;
};
type ChallengeJson = {
    id: string;
    url: string;
    status: 'created' | 'offline' | 'canceled' | 'declined' | 'accepted';
    challenger: ChallengeUser;
    destUser: ChallengeUser | null;
    variant: Variant;
    rated: boolean;
    speed: Speed;
    timeControl: {
        type?: string;
        limit?: number;
        increment?: number;
        show?: string;
    } | {
        type?: string;
        daysPerTurn?: number;
    } | {
        type?: string;
    };
    color: 'white' | 'black' | 'random';
    finalColor?: 'white' | 'black';
    perf: {
        icon?: string;
        name?: string;
    };
    direction?: 'in' | 'out';
    initialFen?: string;
    /**
     * Human readable, possibly translated reason why the challenge was declined.
     */
    declineReason?: string;
    /**
     * Untranslated, computer-matchable reason why the challenge was declined.
     */
    declineReasonKey?: string;
};
type ChallengeEvent = {
    type?: 'challenge';
    challenge?: ChallengeJson;
};
type ChallengeCanceledEvent = {
    type?: 'challengeCanceled';
    challenge?: ChallengeJson;
};
type ChallengeCanceledJson = {
    id?: string;
};
type ChallengeDeclinedEvent = {
    type?: 'challengeDeclined';
    challenge?: ChallengeCanceledJson;
};
type GameEventPlayer = {
    aiLevel?: number;
    id?: string;
    name?: string;
    title?: string | null;
    rating?: number;
    provisional?: boolean;
};
type GameStateEvent = {
    type: 'gameState';
    /**
     * Current moves in UCI format
     */
    moves: string;
    /**
     * Integer of milliseconds White has left on the clock
     */
    wtime: number;
    /**
     * Integer of milliseconds Black has left on the clock
     */
    btime: number;
    /**
     * Integer of White Fisher increment.
     */
    winc: number;
    /**
     * Integer of Black Fisher increment.
     */
    binc: number;
    status: GameStatus;
    /**
     * Color of the winner, if any
     */
    winner?: string;
    /**
     * true if white is offering draw, else omitted
     */
    wdraw?: boolean;
    /**
     * true if black is offering draw, else omitted
     */
    bdraw?: boolean;
    /**
     * true if white is proposing takeback, else omitted
     */
    wtakeback?: boolean;
    /**
     * true if black is proposing takeback, else omitted
     */
    btakeback?: boolean;
};
type GameFullEvent = {
    type: 'gameFull';
    id: string;
    variant: Variant;
    clock: Clock | null;
    speed: Speed;
    perf: {
        /**
         * Translated perf name (e.g. "Classical" or "Blitz")
         */
        name?: string;
    };
    rated: boolean;
    createdAt: number;
    white: GameEventPlayer;
    black: GameEventPlayer;
    initialFen: string;
    state: GameStateEvent;
    tournamentId?: string;
};
type ChatLineEvent = {
    type: 'chatLine';
    room: 'player' | 'spectator';
    username: string;
    text: string;
};
type OpponentGone = {
    type: 'opponentGone';
    gone: boolean;
    claimWinInSeconds?: number;
};
type NotFound = {
    error?: string;
};
type GameChat = unknown;
type ChallengeOpenJson = {
    id: string;
    url: string;
    status: 'created' | 'offline' | 'canceled' | 'declined' | 'accepted';
    challenger: null;
    destUser: null;
    variant: Variant;
    rated: boolean;
    speed: Speed;
    timeControl: {
        type?: string;
        limit?: number;
        increment?: number;
        show?: string;
    } | {
        type?: string;
        daysPerTurn?: number;
    } | {
        type?: string;
    };
    color: 'white' | 'black' | 'random';
    finalColor?: 'white' | 'black';
    perf: {
        icon?: string;
        name?: string;
    };
    initialFen?: string;
    urlWhite: string;
    urlBlack: string;
    open: {
        /**
         * An optional array of two user ids. If set, only these users will be allowed to join the game. The first username gets the white pieces.
         */
        userIds?: Array<string>;
    };
};
type BulkPairing = unknown;
type CloudEval = {
    depth: number;
    fen: string;
    knodes: number;
    pvs: Array<{
        /**
         * Variation in UCI notation
         */
        moves: string;
    } & ({
        /**
         * Evaluation in centi-pawns, from White's point of view
         */
        cp: number;
    } | {
        /**
         * Evaluation in moves to mate, from White's point of view
         */
        mate: number;
    })>;
};
type UciVariant = 'chess' | 'crazyhouse' | 'antichess' | 'atomic' | 'horde' | 'kingofthehill' | 'racingkings' | '3check';
type ExternalEngine = {
    /**
     * Unique engine registration ID.
     */
    id: string;
    /**
     * Display name of the engine.
     */
    name: string;
    /**
     * A secret token that can be used to
     * [*request* analysis](#tag/External-engine/operation/apiExternalEngineAnalyse)
     * from this external engine.
     *
     */
    clientSecret: string;
    /**
     * The user this engine has been registered for.
     */
    userId: string;
    /**
     * Maximum number of available threads.
     */
    maxThreads: number;
    /**
     * Maximum available hash table size, in MiB.
     */
    maxHash: number;
    /**
     * List of supported chess variants.
     */
    variants: Array<UciVariant>;
    /**
     * Arbitrary data that the engine provider can use for identification
     * or bookkeeping.
     *
     * Users can read this information, but updating it requires knowing
     * or changing the `providerSecret`.
     *
     */
    providerData?: string;
};
type ExternalEngineRegistration = {
    /**
     * Display name of the engine.
     */
    name: string;
    /**
     * Maximum number of available threads.
     */
    maxThreads: number;
    /**
     * Maximum available hash table size, in MiB.
     */
    maxHash: number;
    /**
     * Optional list of supported chess variants.
     */
    variants?: Array<UciVariant>;
    /**
     * A random token that can be used to
     * [wait for analysis requests](#tag/External-engine/operation/apiExternalEngineAcquire)
     * and provide analysis.
     *
     * The engine provider should securely generate a random string.
     *
     * The token will not be readable again, even by the user.
     *
     * The analysis provider can register multiple engines with the same
     * token, even for different users, and wait for analysis requests
     * from any of them. In this case, the request must not be made via
     * CORS, so that the token is not revealed to any of the users.
     *
     */
    providerSecret: string;
    /**
     * Arbitrary data that the engine provider can use for identification
     * or bookkeeping.
     *
     * Users can read this information, but updating it requires knowing
     * or changing the `providerSecret`.
     *
     */
    providerData?: string;
};
type ExternalEngineWork = {
    /**
     * Arbitary string that identifies the analysis session.
     * Providers may wish to clear the hash table between sessions.
     *
     */
    sessionId: string;
    /**
     * Number of threads to use for analysis.
     */
    threads: number;
    /**
     * Hash table size to use for analysis, in MiB.
     */
    hash: number;
    /**
     * Requested number of principal variations.
     */
    multiPv: number;
    variant: UciVariant;
    /**
     * Initial position of the game.
     */
    initialFen: string;
    /**
     * List of moves played from the initial position, in UCI notation.
     */
    moves: Array<string>;
    /**
     * Amount of time to analyse the position, in milliseconds.
     */
    movetime?: number;
    /**
     * Analysis target depth
     */
    depth?: number;
    /**
     * Number of nodes to analyse in the position
     */
    nodes?: number;
};
type OAuthError = {
    /**
     * The cause of the error.
     */
    error?: string;
    /**
     * The reason why the request was rejected.
     */
    error_description?: string;
};
type OpeningExplorerOpening = {
    eco: string;
    name: string;
};
type OpeningExplorerGamePlayer = {
    name: string;
    rating: number;
};
type OpeningExplorerMastersGame = {
    id: string;
    winner: 'white' | 'black';
    white: OpeningExplorerGamePlayer;
    black: OpeningExplorerGamePlayer;
    year: number;
    month?: string;
};
type OpeningExplorerMasters = {
    opening: OpeningExplorerOpening | null;
    white: number;
    draws: number;
    black: number;
    moves: Array<{
        uci: string;
        san: string;
        averageRating: number;
        white: number;
        draws: number;
        black: number;
        game: OpeningExplorerMastersGame | null;
        opening: OpeningExplorerOpening | null;
    }>;
    topGames: Array<{
        uci: string;
    } & OpeningExplorerMastersGame>;
};
type OpeningExplorerLichessGame = {
    id: string;
    winner: 'white' | 'black';
    speed: Speed;
    white: OpeningExplorerGamePlayer;
    black: OpeningExplorerGamePlayer;
    year: number;
    month: string;
};
type OpeningExplorerLichess = {
    opening: OpeningExplorerOpening | null;
    white: number;
    draws: number;
    black: number;
    moves: Array<{
        uci: string;
        san: string;
        averageRating: number;
        white: number;
        draws: number;
        black: number;
        game: OpeningExplorerLichessGame | null;
        opening: OpeningExplorerOpening | null;
    }>;
    topGames: Array<{
        uci: string;
    } & OpeningExplorerLichessGame>;
    recentGames: Array<{
        uci: string;
    } & OpeningExplorerLichessGame>;
    history?: Array<{
        month: string;
        white: number;
        draws: number;
        black: number;
    }>;
};
type OpeningExplorerPlayerGame = {
    id: string;
    winner: 'white' | 'black';
    speed: Speed;
    mode: 'rated' | 'casual';
    white: OpeningExplorerGamePlayer;
    black: OpeningExplorerGamePlayer;
    year: number;
    month: string;
};
type OpeningExplorerPlayer = {
    opening: OpeningExplorerOpening | null;
    queuePosition: number;
    white: number;
    draws: number;
    black: number;
    moves: Array<{
        uci: string;
        san: string;
        averageOpponentRating: number;
        performance: number;
        white: number;
        draws: number;
        black: number;
        game: OpeningExplorerPlayerGame | null;
        opening: OpeningExplorerOpening | null;
    }>;
    recentGames: Array<{
        uci: string;
    } & OpeningExplorerPlayerGame>;
};
type MasterGamePgn = unknown;
type Move = {
    uci?: string;
    san?: string;
    category?: 'loss' | 'unknown' | 'syzygy-loss' | 'maybe-loss' | 'blessed-loss' | 'draw' | 'cursed-win' | 'maybe-win' | 'syzygy-win' | 'win';
    /**
     * DTZ50'' with rounding or null if unknown
     */
    dtz?: null | number;
    /**
     * DTZ50'' (only if guaranteed to be not rounded) or null if unknown
     *
     */
    precise_dtz?: null | number;
    /**
     * Depth to Conversion (experimental)
     */
    dtc?: null | number;
    /**
     * Depth To Mate (only for Standard positions with not more than 5 pieces)
     */
    dtm?: null | number;
    /**
     * Depth To Win (only for Antichess positions with not more than 4 pieces)
     */
    dtw?: null | number;
    zeroing?: boolean;
    checkmate?: boolean;
    stalemate?: boolean;
    variant_win?: boolean;
    variant_loss?: boolean;
    insufficient_material?: boolean;
};
type TablebaseJson = {
    /**
     * `cursed-win` and `blessed-loss` means the 50-move rule prevents
     * the decisive result.
     *
     * `syzygy-win` and `syzygy-loss` means exact result is unknown due to
     * [DTZ rounding](https://syzygy-tables.info/metrics#dtz), i.e., the
     * win or loss could also be prevented by the 50-move rule if
     * the user has deviated from the tablebase recommendation since the
     * last pawn move or capture.
     *
     * `maybe-win` and `maybe-loss` means the result with regard to the
     * 50-move rule is unknown because the DTC tablebase does not
     * guarantee to reach a zeroing move as soon as possible.
     *
     */
    category?: 'win' | 'unknown' | 'syzygy-win' | 'maybe-win' | 'cursed-win' | 'draw' | 'blessed-loss' | 'maybe-loss' | 'syzygy-loss' | 'loss';
    /**
     * [DTZ50'' with rounding](https://syzygy-tables.info/metrics#dtz) or null if unknown
     *
     */
    dtz?: null | number;
    /**
     * DTZ50'' (only if guaranteed to be not rounded) or null if unknown
     *
     */
    precise_dtz?: null | number;
    /**
     * Depth to Conversion (experimental)
     */
    dtc?: null | number;
    /**
     * Depth To Mate (only for Standard positions with not more than 5 pieces)
     */
    dtm?: null | number;
    /**
     * Depth To Win (only for Antichess positions with not more than 4 pieces)
     */
    dtw?: null | number;
    checkmate?: boolean;
    stalemate?: boolean;
    /**
     * Only in chess variants
     */
    variant_win?: boolean;
    /**
     * Only in chess variants
     */
    variant_loss?: boolean;
    insufficient_material?: boolean;
    /**
     * Information about legal moves, best first
     */
    moves?: Array<Move>;
};
type ApiUsersStatusData = {
    body?: never;
    path?: never;
    query: {
        /**
         * User IDs separated by commas. Up to 100 IDs.
         */
        ids: string;
        /**
         * Also return the network signal of the player, when available.
         * It ranges from 1 (poor connection, lag > 500ms) to 4 (great connection, lag < 150ms)
         * Defaults to `false` to preserve server resources.
         *
         */
        withSignal?: boolean;
        /**
         * Also return the ID of the game being played, if any, for each player, in a `playingId` field.
         * Defaults to `false` to preserve server resources.
         *
         */
        withGameIds?: boolean;
        /**
         * Also return the id, time control and variant of the game being played, if any, for each player, in a `playing` field.
         * Defaults to `false` to preserve server resources. Disables `withGameIds`.
         *
         */
        withGameMetas?: boolean;
    };
    url: '/api/users/status';
};
type ApiUsersStatusResponses = {
    /**
     * The list of users and their respective statuses.
     */
    200: Array<{
        id: string;
        name: string;
        title?: string;
        online?: boolean;
        playing?: boolean;
        streaming?: boolean;
        patron?: boolean;
    }>;
};
type ApiUsersStatusResponse = ApiUsersStatusResponses[keyof ApiUsersStatusResponses];
type PlayerData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/player';
};
type PlayerResponses = {
    /**
     * The list of variants with their respective top players.
     */
    200: Top10S;
};
type PlayerResponse = PlayerResponses[keyof PlayerResponses];
type PlayerTopNbPerfTypeData = {
    body?: never;
    path: {
        /**
         * How many users to fetch
         */
        nb: number;
        /**
         * The speed or variant
         */
        perfType: 'ultraBullet' | 'bullet' | 'blitz' | 'rapid' | 'classical' | 'chess960' | 'crazyhouse' | 'antichess' | 'atomic' | 'horde' | 'kingOfTheHill' | 'racingKings' | 'threeCheck';
    };
    query?: never;
    url: '/api/player/top/{nb}/{perfType}';
};
type PlayerTopNbPerfTypeResponses = {
    /**
     * The list of top players for the variant.
     */
    200: Leaderboard;
};
type PlayerTopNbPerfTypeResponse = PlayerTopNbPerfTypeResponses[keyof PlayerTopNbPerfTypeResponses];
type ApiUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: {
        /**
         * Include user trophies
         */
        trophies?: boolean;
    };
    url: '/api/user/{username}';
};
type ApiUserResponses = {
    /**
     * The information of the user.
     */
    200: UserExtended;
};
type ApiUserResponse = ApiUserResponses[keyof ApiUserResponses];
type ApiUserRatingHistoryData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/user/{username}/rating-history';
};
type ApiUserRatingHistoryResponses = {
    /**
     * The rating history of the user.
     */
    200: RatingHistory;
};
type ApiUserRatingHistoryResponse = ApiUserRatingHistoryResponses[keyof ApiUserRatingHistoryResponses];
type ApiUserPerfData = {
    body?: never;
    path: {
        username: string;
        perf: PerfType;
    };
    query?: never;
    url: '/api/user/{username}/perf/{perf}';
};
type ApiUserPerfResponses = {
    /**
     * The performance statistics of the user
     */
    200: PerfStat;
};
type ApiUserPerfResponse = ApiUserPerfResponses[keyof ApiUserPerfResponses];
type ApiUserActivityData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/user/{username}/activity';
};
type ApiUserActivityResponses = {
    /**
     * The activity feed of the user.
     */
    200: UserActivity;
};
type ApiUserActivityResponse = ApiUserActivityResponses[keyof ApiUserActivityResponses];
type ApiPuzzleDailyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/puzzle/daily';
};
type ApiPuzzleDailyResponses = {
    /**
     * The daily puzzle.
     */
    200: PuzzleAndGame;
};
type ApiPuzzleDailyResponse = ApiPuzzleDailyResponses[keyof ApiPuzzleDailyResponses];
type ApiPuzzleIdData = {
    body?: never;
    path: {
        /**
         * The puzzle ID
         */
        id: string;
    };
    query?: never;
    url: '/api/puzzle/{id}';
};
type ApiPuzzleIdResponses = {
    /**
     * The requested puzzle.
     */
    200: PuzzleAndGame;
};
type ApiPuzzleIdResponse = ApiPuzzleIdResponses[keyof ApiPuzzleIdResponses];
type ApiPuzzleNextData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The theme or opening to filter puzzles with.
         *
         * Available themes are listed in [the lichess source code](https://github.com/ornicar/lila/blob/master/translation/source/puzzleTheme.xml).
         *
         */
        angle?: string;
        /**
         * The desired puzzle difficulty, relative to the authenticated user puzzle rating, or 1500 if anonymous.
         */
        difficulty?: 'easiest' | 'easier' | 'normal' | 'harder' | 'hardest';
    };
    url: '/api/puzzle/next';
};
type ApiPuzzleNextResponses = {
    /**
     * The requested puzzle.
     */
    200: PuzzleAndGame;
};
type ApiPuzzleNextResponse = ApiPuzzleNextResponses[keyof ApiPuzzleNextResponses];
type ApiPuzzleActivityData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * How many entries to download. Leave empty to download all activity.
         */
        max?: number;
        /**
         * Download entries before this timestamp. Defaults to now. Use `before` and `max` for pagination.
         */
        before?: number;
    };
    url: '/api/puzzle/activity';
};
type ApiPuzzleActivityResponses = {
    /**
     * The puzzle activity of the logged in user.
     */
    200: PuzzleActivity;
};
type ApiPuzzleActivityResponse = ApiPuzzleActivityResponses[keyof ApiPuzzleActivityResponses];
type ApiPuzzleReplayData = {
    body?: never;
    path: {
        /**
         * How many days to look back when aggregating puzzle results. 30 is sensible.
         */
        days: number;
        /**
         * The theme or opening to filter puzzles with.
         */
        theme: string;
    };
    query?: never;
    url: '/api/puzzle/replay/{days}/{theme}';
};
type ApiPuzzleReplayErrors = {
    /**
     * No puzzles to replay were found
     */
    404: {
        error?: string;
    };
};
type ApiPuzzleReplayError = ApiPuzzleReplayErrors[keyof ApiPuzzleReplayErrors];
type ApiPuzzleReplayResponses = {
    /**
     * The requested puzzles to replay.
     */
    200: PuzzleReplay;
};
type ApiPuzzleReplayResponse = ApiPuzzleReplayResponses[keyof ApiPuzzleReplayResponses];
type ApiPuzzleDashboardData = {
    body?: never;
    path: {
        /**
         * How many days to look back when aggregating puzzle results. 30 is sensible.
         */
        days: number;
    };
    query?: never;
    url: '/api/puzzle/dashboard/{days}';
};
type ApiPuzzleDashboardResponses = {
    /**
     * The puzzle dashboard of the logged in user.
     */
    200: PuzzleDashboard;
};
type ApiPuzzleDashboardResponse = ApiPuzzleDashboardResponses[keyof ApiPuzzleDashboardResponses];
type ApiStormDashboardData = {
    body?: never;
    path: {
        /**
         * Username of the player
         */
        username: string;
    };
    query?: {
        /**
         * How many days of history to return
         */
        days?: number;
    };
    url: '/api/storm/dashboard/{username}';
};
type ApiStormDashboardResponses = {
    /**
     * The storm dashboard of a player.
     */
    200: PuzzleStormDashboard;
};
type ApiStormDashboardResponse = ApiStormDashboardResponses[keyof ApiStormDashboardResponses];
type RacerPostData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/racer';
};
type RacerPostResponses = {
    /**
     * The new puzzle race.
     */
    200: PuzzleRacer;
};
type RacerPostResponse = RacerPostResponses[keyof RacerPostResponses];
type ApiUsersData = {
    /**
     * User IDs separated by commas.
     */
    body: string;
    path?: never;
    query?: never;
    url: '/api/users';
};
type ApiUsersResponses = {
    /**
     * The list of users.
     */
    200: Array<User>;
};
type ApiUsersResponse = ApiUsersResponses[keyof ApiUsersResponses];
type AccountMeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/account';
};
type AccountMeResponses = {
    /**
     * The public information about the logged in user.
     */
    200: UserExtended;
};
type AccountMeResponse = AccountMeResponses[keyof AccountMeResponses];
type AccountEmailData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/account/email';
};
type AccountEmailResponses = {
    /**
     * The email address of the logged in user.
     */
    200: {
        email?: string;
    };
};
type AccountEmailResponse = AccountEmailResponses[keyof AccountEmailResponses];
type AccountData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/account/preferences';
};
type AccountResponses = {
    /**
     * The preferences of the logged in user.
     */
    200: {
        prefs?: UserPreferences;
        language?: string;
    };
};
type AccountResponse = AccountResponses[keyof AccountResponses];
type AccountKidData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/account/kid';
};
type AccountKidResponses = {
    /**
     * The kid mode status of the logged in user.
     */
    200: {
        kid?: boolean;
    };
};
type AccountKidResponse = AccountKidResponses[keyof AccountKidResponses];
type AccountKidPostData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Kid mode status
         */
        v: boolean;
    };
    url: '/api/account/kid';
};
type AccountKidPostResponses = {
    /**
     * The kid mode status was set successfully for the logged in user.
     */
    200: Ok;
};
type AccountKidPostResponse = AccountKidPostResponses[keyof AccountKidPostResponses];
type TimelineData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Show events since this timestamp.
         */
        since?: number;
        /**
         * Max number of events to fetch.
         */
        nb?: number;
    };
    url: '/api/timeline';
};
type TimelineResponses = {
    /**
     * The events in the timeline of the logged in user.
     */
    200: Timeline;
};
type TimelineResponse = TimelineResponses[keyof TimelineResponses];
type GamePgnData = {
    body?: never;
    path: {
        /**
         * The game ID
         */
        gameId: string;
    };
    query?: {
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
        /**
         * Add a `bookmarked: true` JSON field when the logged in user has bookmarked the game.
         * The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *
         */
        withBookmarked?: boolean;
        /**
         * URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         * Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *
         */
        players?: string;
    };
    url: '/game/export/{gameId}';
};
type GamePgnResponses = {
    /**
     * The game representation.
     */
    200: GamePgn;
};
type GamePgnResponse = GamePgnResponses[keyof GamePgnResponses];
type ApiUserCurrentGameData = {
    body?: never;
    path: {
        username: string;
    };
    query?: {
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
        /**
         * URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         * Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *
         */
        players?: string;
    };
    url: '/api/user/{username}/current-game';
};
type ApiUserCurrentGameResponses = {
    /**
     * The ongoing (or last) game of a user.
     */
    200: GamePgn;
};
type ApiUserCurrentGameResponse = ApiUserCurrentGameResponses[keyof ApiUserCurrentGameResponses];
type ApiGamesUserData = {
    body?: never;
    path: {
        /**
         * The user name.
         */
        username: string;
    };
    query?: {
        /**
         * Download games played since this timestamp. Defaults to account creation date.
         */
        since?: number;
        /**
         * Download games played until this timestamp. Defaults to now.
         */
        until?: number;
        /**
         * How many games to download. Leave empty to download all games.
         */
        max?: number;
        /**
         * [Filter] Only games played against this opponent
         */
        vs?: string;
        /**
         * [Filter] Only rated (`true`) or casual (`false`) games
         */
        rated?: boolean;
        /**
         * [Filter] Only games in these speeds or variants.
         * Multiple perf types can be specified, separated by a comma.
         * Example: blitz,rapid,classical
         *
         */
        perfType?: PerfType & unknown;
        /**
         * [Filter] Only games played as this color.
         */
        color?: 'white' | 'black';
        /**
         * [Filter] Only games with or without a computer analysis available
         */
        analysed?: boolean;
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field. The response type must be set to `application/x-ndjson` by the request `Accept` header.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
         */
        ongoing?: boolean;
        /**
         * Include finished games. Set to `false` to only get ongoing games.
         */
        finished?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
        /**
         * Include the FEN notation of the last position of the game.
         * The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *
         */
        lastFen?: boolean;
        /**
         * Add a `bookmarked: true` JSON field when the logged in user has bookmarked the game.
         * The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *
         */
        withBookmarked?: boolean;
        /**
         * URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         * Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *
         */
        players?: string;
        /**
         * Sort order of the games.
         */
        sort?: 'dateAsc' | 'dateDesc';
    };
    url: '/api/games/user/{username}';
};
type ApiGamesUserResponses = {
    /**
     * The games of the user.
     */
    200: GamePgn;
};
type ApiGamesUserResponse = ApiGamesUserResponses[keyof ApiGamesUserResponses];
type GamesExportIdsData = {
    /**
     * Game IDs separated by commas. Up to 300.
     */
    body: string;
    path?: never;
    query?: {
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
        /**
         * URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         * Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *
         */
        players?: string;
    };
    url: '/api/games/export/_ids';
};
type GamesExportIdsResponses = {
    /**
     * The representation of the games.
     */
    200: GamePgn;
};
type GamesExportIdsResponse = GamesExportIdsResponses[keyof GamesExportIdsResponses];
type GamesByUsersData = {
    /**
     * Up to 300 user IDs separated by commas.
     * Example: `thibault,maia1,maia5`
     *
     */
    body: string;
    path?: never;
    query?: {
        /**
         * Include the already started games at the beginning of the stream.
         */
        withCurrentGames?: boolean;
    };
    url: '/api/stream/games-by-users';
};
type GamesByUsersResponses = {
    /**
     * The stream of the games played between the users.
     */
    200: GameStream;
};
type GamesByUsersResponse = GamesByUsersResponses[keyof GamesByUsersResponses];
type GamesByIdsData = {
    /**
     * Up to 500 or 1000 game IDs separated by commas.
     * Example: `gameId01,gameId02,gameId03`
     *
     */
    body: string;
    path: {
        /**
         * Arbitrary stream ID that you can later use to add game IDs to the stream.
         */
        streamId: string;
    };
    query?: never;
    url: '/api/stream/games/{streamId}';
};
type GamesByIdsResponses = {
    /**
     * The stream of the games matching the requested IDs.
     */
    200: GameStream;
};
type GamesByIdsResponse = GamesByIdsResponses[keyof GamesByIdsResponses];
type GamesByIdsAddData = {
    /**
     * Up to 500 or 1000 game IDs separated by commas.
     * Example: `gameId04,gameId05,gameId06`
     *
     */
    body: string;
    path: {
        /**
         * The stream ID you used to [create the stream](#operation/gamesByIds).
         */
        streamId: string;
    };
    query?: never;
    url: '/api/stream/games/{streamId}/add';
};
type GamesByIdsAddResponses = {
    /**
     * The game IDs have been added to the stream.
     */
    200: Ok;
};
type GamesByIdsAddResponse = GamesByIdsAddResponses[keyof GamesByIdsAddResponses];
type ApiAccountPlayingData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Max number of games to fetch
         */
        nb?: number;
    };
    url: '/api/account/playing';
};
type ApiAccountPlayingResponses = {
    /**
     * The ongoing games of the logged in user.
     */
    200: {
        nowPlaying: Array<{
            fullId: string;
            gameId: string;
            fen: string;
            color: 'white' | 'black';
            lastMove: string;
            source: GameSource;
            status?: GameStatus;
            variant: Variant;
            speed: Speed;
            perf: PerfType;
            rated: boolean;
            hasMoved: boolean;
            opponent: {
                id: string;
                username: string;
                rating?: number;
                ratingDiff?: number;
                ai?: number;
            };
            isMyTurn: boolean;
            secondsLeft: number;
            tournamentId?: string;
            swissId?: string;
            winner?: 'white' | 'black';
            ratingDiff?: number;
        }>;
    };
};
type ApiAccountPlayingResponse = ApiAccountPlayingResponses[keyof ApiAccountPlayingResponses];
type StreamGameData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/stream/game/{id}';
};
type StreamGameResponses = {
    /**
     * The stream of the game moves.
     */
    200: MoveStream;
};
type StreamGameResponse = StreamGameResponses[keyof StreamGameResponses];
type GameImportData = {
    /**
     * A single game to import
     */
    body: {
        /**
         * The PGN. It can contain only one game. Most standard tags are supported.
         */
        pgn?: string;
    };
    path?: never;
    query?: never;
    url: '/api/import';
};
type GameImportResponses = {
    /**
     * The game was successfully imported.
     */
    200: {
        /**
         * The game ID
         */
        id?: string;
        /**
         * The game URL
         */
        url?: string;
    };
};
type GameImportResponse = GameImportResponses[keyof GameImportResponses];
type ApiImportedGamesUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/games/export/imports';
};
type ApiImportedGamesUserResponses = {
    /**
     * Imported games in PGN format
     */
    200: GamePgn;
};
type ApiImportedGamesUserResponse = ApiImportedGamesUserResponses[keyof ApiImportedGamesUserResponses];
type ApiExportBookmarksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Download games bookmarked since this timestamp. Defaults to account creation date.
         */
        since?: number;
        /**
         * Download games bookmarked until this timestamp. Defaults to now.
         */
        until?: number;
        /**
         * How many bookmarked games to download. Leave empty to download all bookmarked games.
         */
        max?: number;
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field. The response type must be set to `application/x-ndjson` by the request `Accept` header.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
        /**
         * Include the FEN notation of the last position of the game.
         * The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *
         */
        lastFen?: boolean;
        /**
         * Sort order of the bookmarks.
         */
        sort?: 'dateAsc' | 'dateDesc';
    };
    url: '/api/games/export/bookmarks';
};
type ApiExportBookmarksResponses = {
    /**
     * The bookmarked games of the user.
     */
    200: GamePgn;
};
type ApiExportBookmarksResponse = ApiExportBookmarksResponses[keyof ApiExportBookmarksResponses];
type TvChannelsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tv/channels';
};
type TvChannelsResponses = {
    /**
     * The list of games being played for each speed and variant.
     */
    200: {
        bot: TvGame;
        blitz: TvGame;
        racingKings: TvGame;
        ultraBullet: TvGame;
        bullet: TvGame;
        classical: TvGame;
        threeCheck: TvGame;
        antichess: TvGame;
        computer: TvGame;
        horde: TvGame;
        rapid: TvGame;
        atomic: TvGame;
        crazyhouse: TvGame;
        chess960: TvGame;
        kingOfTheHill: TvGame;
        best: TvGame;
    };
};
type TvChannelsResponse = TvChannelsResponses[keyof TvChannelsResponses];
type TvFeedData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tv/feed';
};
type TvFeedResponses = {
    /**
     * The stream of the current TV game.
     */
    200: TvFeed;
};
type TvFeedResponse = TvFeedResponses[keyof TvFeedResponses];
type TvChannelFeedData = {
    body?: never;
    path: {
        /**
         * The name of the channel in camel case.
         */
        channel: string;
    };
    query?: never;
    url: '/api/tv/{channel}/feed';
};
type TvChannelFeedResponses = {
    /**
     * The stream of the current TV game of a TV channel.
     */
    200: TvFeed;
};
type TvChannelFeedResponse = TvChannelFeedResponses[keyof TvChannelFeedResponses];
type TvChannelGamesData = {
    body?: never;
    path: {
        /**
         * The name of the channel in camel case.
         */
        channel: string;
    };
    query?: {
        /**
         * Number of games to fetch.
         */
        nb?: number;
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
    };
    url: '/api/tv/{channel}';
};
type TvChannelGamesResponses = {
    /**
     * The representation of the games.
     */
    200: GamePgn;
};
type TvChannelGamesResponse = TvChannelGamesResponses[keyof TvChannelGamesResponses];
type ApiTournamentData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tournament';
};
type ApiTournamentResponses = {
    /**
     * The list of current tournaments.
     */
    200: ArenaTournaments;
};
type ApiTournamentResponse = ApiTournamentResponses[keyof ApiTournamentResponses];
type ApiTournamentPostData = {
    /**
     * Parameters of the tournament
     */
    body: {
        /**
         * The tournament name. Leave empty to get a random Grandmaster name
         */
        name?: string;
        /**
         * Clock initial time in minutes
         */
        clockTime: 0 | 0.25 | 0.5 | 0.75 | 1 | 1.5 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 10 | 15 | 20 | 25 | 30 | 40 | 50 | 60;
        /**
         * Clock increment in seconds
         */
        clockIncrement: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 10 | 15 | 20 | 25 | 30 | 40 | 50 | 60;
        /**
         * How long the tournament lasts, in minutes
         */
        minutes: 20 | 25 | 30 | 35 | 40 | 45 | 50 | 55 | 60 | 70 | 80 | 90 | 100 | 110 | 120 | 150 | 180 | 210 | 240 | 270 | 300 | 330 | 360 | 420 | 480 | 540 | 600 | 720;
        /**
         * How long to wait before starting the tournament, from now, in minutes
         */
        waitMinutes?: 1 | 2 | 3 | 5 | 10 | 15 | 20 | 30 | 45 | 60;
        /**
         * Timestamp (in milliseconds) to start the tournament at a given date and time. Overrides the `waitMinutes` setting
         */
        startDate?: number;
        variant?: VariantKey;
        /**
         * Games are rated and impact players ratings
         */
        rated?: boolean;
        position?: FromPositionFen;
        /**
         * Whether the players can use berserk. Only allowed if clockIncrement <= clockTime * 2
         */
        berserkable?: boolean;
        /**
         * After 2 wins, consecutive wins grant 4 points instead of 2.
         */
        streakable?: boolean;
        /**
         * Whether the players can discuss in a chat
         */
        hasChat?: boolean;
        /**
         * Anything you want to tell players about the tournament
         */
        description?: string;
        /**
         * Make the tournament private, and restrict access with a password.
         * You can also [generate user-specific entry codes](https://github.com/lichess-org/api/tree/master/example/tournament-entry-code)
         * based on this password.
         *
         */
        password?: string;
        /**
         * Set the ID of a team you lead to create a team battle.
         * The other teams can be added using the [team battle edit endpoint](#operation/apiTournamentTeamBattlePost).
         *
         */
        teamBattleByTeam?: string;
        /**
         * Restrict entry to members of a team.
         * The teamId is the last part of a team URL, e.g. `https://lichess.org/team/coders` has teamId = `coders`.
         * Leave empty to let everyone join the tournament.
         * Do not use this to create team battles, use `teamBattleByTeam` instead.
         *
         */
        'conditions.teamMember.teamId'?: string;
        /**
         * Minimum rating to join. Leave empty to let everyone join the tournament.
         */
        'conditions.minRating.rating'?: 1000 | 1100 | 1200 | 1300 | 1400 | 1500 | 1600 | 1700 | 1800 | 1900 | 2000 | 2100 | 2200 | 2300 | 2400 | 2500 | 2600;
        /**
         * Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
         */
        'conditions.maxRating.rating'?: 2200 | 2100 | 2000 | 1900 | 1800 | 1700 | 1600 | 1500 | 1400 | 1300 | 1200 | 1100 | 1000 | 900 | 800;
        /**
         * Minimum number of rated games required to join.
         */
        'conditions.nbRatedGame.nb'?: 0 | 5 | 10 | 15 | 20 | 30 | 40 | 50 | 75 | 100 | 150 | 200;
        /**
         * Predefined list of usernames that are allowed to join, separated by commas.
         * If this list is non-empty, then usernames absent from this list will be forbidden to join.
         * Adding `%titled` to the list additionally allows any titled player to join.
         * Example: `thibault,german11,%titled`
         *
         */
        'conditions.allowList'?: string;
        /**
         * Whether bots are allowed to join the tournament.
         */
        'conditions.bots'?: boolean;
        /**
         * Minium account age in days required to join.
         */
        'conditions.accountAge'?: 1 | 3 | 7 | 14 | 30 | 60 | 90 | 180 | 365 | 730 | 1095;
    };
    path?: never;
    query?: never;
    url: '/api/tournament';
};
type ApiTournamentPostErrors = {
    /**
     * The creation of the Arena tournament failed.
     */
    400: _Error;
};
type ApiTournamentPostError = ApiTournamentPostErrors[keyof ApiTournamentPostErrors];
type ApiTournamentPostResponses = {
    /**
     * The Arena tournament has been successfully created.
     */
    200: ArenaTournamentFull;
};
type ApiTournamentPostResponse = ApiTournamentPostResponses[keyof ApiTournamentPostResponses];
type TournamentData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: {
        /**
         * Specify which page of player standings to view.
         */
        page?: number;
    };
    url: '/api/tournament/{id}';
};
type TournamentResponses = {
    /**
     * The information of the Arena tournament.
     */
    200: ArenaTournamentFull;
};
type TournamentResponse = TournamentResponses[keyof TournamentResponses];
type ApiTournamentUpdateData = {
    /**
     * Parameters of the tournament
     */
    body: {
        /**
         * The tournament name. Leave empty to get a random Grandmaster name
         */
        name?: string;
        /**
         * Clock initial time in minutes
         */
        clockTime: 0 | 0.25 | 0.5 | 0.75 | 1 | 1.5 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 10 | 15 | 20 | 25 | 30 | 40 | 50 | 60;
        /**
         * Clock increment in seconds
         */
        clockIncrement: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 10 | 15 | 20 | 25 | 30 | 40 | 50 | 60;
        /**
         * How long the tournament lasts, in minutes
         */
        minutes: 20 | 25 | 30 | 35 | 40 | 45 | 50 | 55 | 60 | 70 | 80 | 90 | 100 | 110 | 120 | 150 | 180 | 210 | 240 | 270 | 300 | 330 | 360 | 420 | 480 | 540 | 600 | 720;
        /**
         * How long to wait before starting the tournament, from now, in minutes
         */
        waitMinutes?: 1 | 2 | 3 | 5 | 10 | 15 | 20 | 30 | 45 | 60;
        /**
         * Timestamp (in milliseconds) to start the tournament at a given date and time. Overrides the `waitMinutes` setting
         */
        startDate?: number;
        variant?: VariantKey;
        /**
         * Games are rated and impact players ratings
         */
        rated?: boolean;
        position?: FromPositionFen;
        /**
         * Whether the players can use berserk. Only allowed if clockIncrement <= clockTime * 2
         */
        berserkable?: boolean;
        /**
         * After 2 wins, consecutive wins grant 4 points instead of 2.
         */
        streakable?: boolean;
        /**
         * Whether the players can discuss in a chat
         */
        hasChat?: boolean;
        /**
         * Anything you want to tell players about the tournament
         */
        description?: string;
        /**
         * Make the tournament private, and restrict access with a password
         */
        password?: string;
        /**
         * Minimum rating to join. Leave empty to let everyone join the tournament.
         */
        'conditions.minRating.rating'?: 1000 | 1100 | 1200 | 1300 | 1400 | 1500 | 1600 | 1700 | 1800 | 1900 | 2000 | 2100 | 2200 | 2300 | 2400 | 2500 | 2600;
        /**
         * Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
         */
        'conditions.maxRating.rating'?: 2200 | 2100 | 2000 | 1900 | 1800 | 1700 | 1600 | 1500 | 1400 | 1300 | 1200 | 1100 | 1000 | 900 | 800;
        /**
         * Minimum number of rated games required to join.
         */
        'conditions.nbRatedGame.nb'?: 0 | 5 | 10 | 15 | 20 | 30 | 40 | 50 | 75 | 100 | 150 | 200;
        /**
         * Predefined list of usernames that are allowed to join, separated by commas.
         * If this list is non-empty, then usernames absent from this list will be forbidden to join.
         * Adding `%titled` to the list additionally allows any titled player to join.
         * Example: `thibault,german11,%titled`
         *
         */
        'conditions.allowList'?: string;
        /**
         * Whether bots are allowed to join the tournament.
         */
        'conditions.bots'?: boolean;
        /**
         * Minium account age in days required to join.
         */
        'conditions.accountAge'?: 1 | 3 | 7 | 14 | 30 | 60 | 90 | 180 | 365 | 730 | 1095;
    };
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/{id}';
};
type ApiTournamentUpdateErrors = {
    /**
     * The update of the Arena tournament failed.
     */
    400: _Error;
};
type ApiTournamentUpdateError = ApiTournamentUpdateErrors[keyof ApiTournamentUpdateErrors];
type ApiTournamentUpdateResponses = {
    /**
     * The Arena tournament was successfully updated.
     */
    200: ArenaTournamentFull;
};
type ApiTournamentUpdateResponse = ApiTournamentUpdateResponses[keyof ApiTournamentUpdateResponses];
type ApiTournamentJoinData = {
    /**
     * You may need these depending on the tournament to join
     */
    body?: {
        /**
         * The tournament password, if one is required.
         * Can also be a [user-specific entry code](https://github.com/lichess-org/api/tree/master/example/tournament-entry-code)
         * generated and shared by the organizer.
         *
         */
        password?: string;
        /**
         * The team to join the tournament with, for team battle tournaments
         */
        team?: string;
        /**
         * If the tournament is started, attempt to pair the user,
         * even if they are not connected to the tournament page.
         * This expires after one minute, to avoid pairing a user who is long gone.
         * You may call "join" again to extend the waiting.
         *
         */
        pairMeAsap?: boolean;
    };
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/{id}/join';
};
type ApiTournamentJoinErrors = {
    /**
     * Joining the tournament failed.
     */
    400: _Error;
};
type ApiTournamentJoinError = ApiTournamentJoinErrors[keyof ApiTournamentJoinErrors];
type ApiTournamentJoinResponses = {
    /**
     * The tournament was successfully joined.
     */
    200: Ok;
};
type ApiTournamentJoinResponse = ApiTournamentJoinResponses[keyof ApiTournamentJoinResponses];
type ApiTournamentWithdrawData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/{id}/withdraw';
};
type ApiTournamentWithdrawErrors = {
    /**
     * Pausing/leaving the tournament failed.
     */
    400: _Error;
};
type ApiTournamentWithdrawError = ApiTournamentWithdrawErrors[keyof ApiTournamentWithdrawErrors];
type ApiTournamentWithdrawResponses = {
    /**
     * The tournament was successfully paused or left.
     */
    200: Ok;
};
type ApiTournamentWithdrawResponse = ApiTournamentWithdrawResponses[keyof ApiTournamentWithdrawResponses];
type ApiTournamentTerminateData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/{id}/terminate';
};
type ApiTournamentTerminateErrors = {
    /**
     * Terminating the tournament failed.
     */
    400: _Error;
};
type ApiTournamentTerminateError = ApiTournamentTerminateErrors[keyof ApiTournamentTerminateErrors];
type ApiTournamentTerminateResponses = {
    /**
     * The tournament was successfully terminated.
     */
    200: Ok;
};
type ApiTournamentTerminateResponse = ApiTournamentTerminateResponses[keyof ApiTournamentTerminateResponses];
type ApiTournamentTeamBattlePostData = {
    body: {
        /**
         * All team IDs of the team battle, separated by commas.
         * Make sure to always send the full list.
         * Teams that are not in the list will be removed from the team battle.
         * Example: `coders,zhigalko_sergei-fan-club,hhSwTKZv`
         *
         */
        teams: string;
        /**
         * Number team leaders per team.
         */
        nbLeaders: number;
    };
    path: {
        /**
         * The tournament ID
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/team-battle/{id}';
};
type ApiTournamentTeamBattlePostErrors = {
    /**
     * The update of the team battle tournament failed.
     */
    400: _Error;
};
type ApiTournamentTeamBattlePostError = ApiTournamentTeamBattlePostErrors[keyof ApiTournamentTeamBattlePostErrors];
type ApiTournamentTeamBattlePostResponses = {
    /**
     * The team battle tournament was successfully updated.
     */
    200: ArenaTournamentFull;
};
type ApiTournamentTeamBattlePostResponse = ApiTournamentTeamBattlePostResponses[keyof ApiTournamentTeamBattlePostResponses];
type GamesByTournamentData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: {
        /**
         * Only games of a particular player. Leave empty to fetch games of all players.
         */
        player?: string;
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
    };
    url: '/api/tournament/{id}/games';
};
type GamesByTournamentResponses = {
    /**
     * The list of games of an Arena tournament.
     */
    200: GamePgn;
};
type GamesByTournamentResponse = GamesByTournamentResponses[keyof GamesByTournamentResponses];
type ResultsByTournamentData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: {
        /**
         * Max number of players to fetch
         */
        nb?: number;
        /**
         * Add a `sheet` field to the player document.
         * It's an expensive server computation that slows down the stream.
         *
         */
        sheet?: boolean;
    };
    url: '/api/tournament/{id}/results';
};
type ResultsByTournamentResponses = {
    /**
     * The results of the Arena tournament.
     */
    200: {
        rank: number;
        score: number;
        rating: number;
        username: string;
        performance: number;
        title?: Title;
        team: string;
        flair?: Flair;
        sheet?: ArenaSheet;
    };
};
type ResultsByTournamentResponse = ResultsByTournamentResponses[keyof ResultsByTournamentResponses];
type TeamsByTournamentData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/{id}/teams';
};
type TeamsByTournamentResponses = {
    /**
     * The list of teams of a team battle tournament, with their respective top players.
     */
    200: {
        id: string;
        teams: Array<{
            rank: number;
            id: string;
            score: number;
            players: Array<{
                user: LightUser;
                score?: number;
            }>;
        }>;
    };
};
type TeamsByTournamentResponse = TeamsByTournamentResponses[keyof TeamsByTournamentResponses];
type ApiUserNameTournamentCreatedData = {
    body?: never;
    path: {
        /**
         * The user whose created tournaments to fetch
         */
        username: string;
    };
    query?: {
        /**
         * Max number of tournaments to fetch
         */
        nb?: number;
        /**
         * Include tournaments in the given status: "Created" (10), "Started" (20), "Finished" (30)
         * You can add this parameter more than once to include tournaments in different statuses.
         * Example: `?status=10&status=20`
         *
         */
        status?: 10 | 20 | 30;
    };
    url: '/api/user/{username}/tournament/created';
};
type ApiUserNameTournamentCreatedResponses = {
    /**
     * The list of tournaments created by the user.
     */
    200: ArenaTournament;
};
type ApiUserNameTournamentCreatedResponse = ApiUserNameTournamentCreatedResponses[keyof ApiUserNameTournamentCreatedResponses];
type ApiUserNameTournamentPlayedData = {
    body?: never;
    path: {
        /**
         * The user whose played tournaments to fetch
         */
        username: string;
    };
    query?: {
        /**
         * Max number of tournaments to fetch
         */
        nb?: number;
        /**
         * Include the player performance rating in the response, at some cost for the server.
         *
         */
        performance?: boolean;
    };
    url: '/api/user/{username}/tournament/played';
};
type ApiUserNameTournamentPlayedResponses = {
    /**
     * The list of tournaments played by the user.
     */
    200: ArenaTournamentPlayed;
};
type ApiUserNameTournamentPlayedResponse = ApiUserNameTournamentPlayedResponses[keyof ApiUserNameTournamentPlayedResponses];
type ApiSwissNewData = {
    /**
     * Parameters of the tournament
     */
    body: {
        /**
         * The tournament name. Leave empty to get a random Grandmaster name
         */
        name?: string;
        /**
         * Clock initial time in seconds
         */
        'clock.limit': 0 | 15 | 30 | 45 | 60 | 90 | 120 | 180 | 240 | 300 | 360 | 420 | 480 | 600 | 900 | 1200 | 1500 | 1800 | 2400 | 3000 | 3600 | 4200 | 4800 | 5400 | 6000 | 6600 | 7200 | 7800 | 8400 | 9000 | 9600 | 10200 | 10800;
        /**
         * Clock increment in seconds
         */
        'clock.increment': number;
        /**
         * Maximum number of rounds to play
         */
        nbRounds: number;
        /**
         * Timestamp in milliseconds to start the tournament at a given date and time. By default, it starts 10 minutes after creation.
         */
        startsAt?: number;
        /**
         * How long to wait between each round, in seconds.
         * Set to 99999999 to manually schedule each round from the tournament UI.
         * If empty or -1, a sensible value is picked automatically.
         *
         */
        roundInterval?: -1 | 5 | 10 | 20 | 30 | 45 | 60 | 120 | 180 | 300 | 600 | 900 | 1200 | 1800 | 2700 | 3600 | 86400 | 172800 | 604800 | 99999999;
        variant?: VariantKey;
        position?: SwissFromPositionFen;
        /**
         * Anything you want to tell players about the tournament
         */
        description?: string;
        /**
         * Games are rated and impact players ratings
         */
        rated?: boolean;
        /**
         * Make the tournament private and restrict access with a password.
         */
        password?: string;
        /**
         * Usernames of players that must not play together.
         * Two usernames per line, separated by a space.
         *
         */
        forbiddenPairings?: string;
        /**
         * Manual pairings for the next round.
         * Two usernames per line, separated by a space. Example:
         * ```
         * PlayerA PlayerB
         * PlayerC PlayerD
         * ```
         * To give a bye (1 point) to a player instead of a pairing, add a line like so:
         * ```
         * PlayerE 1
         * ```
         * Missing players will be considered absent and get zero points.
         *
         */
        manualPairings?: string;
        /**
         * Who can read and write in the chat.
         * - 0  = No-one
         * - 10 = Only team leaders
         * - 20 = Only team members
         * - 30 = All Lichess players
         *
         */
        chatFor?: number;
        /**
         * Minimum rating to join. Leave empty to let everyone join the tournament.
         */
        'conditions.minRating.rating'?: 1000 | 1100 | 1200 | 1300 | 1400 | 1500 | 1600 | 1700 | 1800 | 1900 | 2000 | 2100 | 2200 | 2300 | 2400 | 2500 | 2600;
        /**
         * Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
         */
        'conditions.maxRating.rating'?: 2200 | 2100 | 2000 | 1900 | 1800 | 1700 | 1600 | 1500 | 1400 | 1300 | 1200 | 1100 | 1000 | 900 | 800;
        /**
         * Minimum number of rated games required to join.
         */
        'conditions.nbRatedGame.nb'?: number;
        /**
         * Only let players join if they have played their last swiss game.
         * If they failed to show up in a recent swiss event, they won't be able to enter yours.
         * This results in a better swiss experience for the players who actually show up.
         *
         */
        'conditions.playYourGames'?: boolean;
        /**
         * Predefined list of usernames that are allowed to join, separated by commas.
         * If this list is non-empty, then usernames absent from this list will be forbidden to join.
         * Adding `%titled` to the list additionally allows any titled player to join.
         * Example: `thibault,german11,%titled`
         *
         */
        'conditions.allowList'?: string;
    };
    path: {
        /**
         * ID of the team
         */
        teamId: string;
    };
    query?: never;
    url: '/api/swiss/new/{teamId}';
};
type ApiSwissNewErrors = {
    /**
     * The creation of the Swiss tournament failed.
     */
    400: _Error;
};
type ApiSwissNewError = ApiSwissNewErrors[keyof ApiSwissNewErrors];
type ApiSwissNewResponses = {
    /**
     * The Swiss tournament was successfully created.
     */
    200: SwissTournament;
};
type ApiSwissNewResponse = ApiSwissNewResponses[keyof ApiSwissNewResponses];
type SwissData = {
    body?: never;
    path: {
        /**
         * The Swiss tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}';
};
type SwissResponses = {
    /**
     * The information of the Swiss tournament.
     */
    200: SwissTournament;
};
type SwissResponse = SwissResponses[keyof SwissResponses];
type ApiSwissUpdateData = {
    /**
     * Parameters of the tournament
     */
    body: {
        /**
         * The tournament name. Leave empty to get a random Grandmaster name
         */
        name?: string;
        /**
         * Clock initial time in seconds
         */
        'clock.limit': 0 | 15 | 30 | 45 | 60 | 90 | 120 | 180 | 240 | 300 | 360 | 420 | 480 | 600 | 900 | 1200 | 1500 | 1800 | 2400 | 3000 | 3600 | 4200 | 4800 | 5400 | 6000 | 6600 | 7200 | 7800 | 8400 | 9000 | 9600 | 10200 | 10800;
        /**
         * Clock increment in seconds
         */
        'clock.increment': number;
        /**
         * Maximum number of rounds to play
         */
        nbRounds: number;
        /**
         * Timestamp in milliseconds to start the tournament at a given date and time. By default, it starts 10 minutes after creation.
         */
        startsAt?: number;
        /**
         * How long to wait between each round, in seconds.
         * Set to 99999999 to manually schedule each round from the tournament UI, or [with the API](#tag/Swiss-tournaments/operation/apiSwissScheduleNextRound).
         * If empty or -1, a sensible value is picked automatically.
         *
         */
        roundInterval?: -1 | 5 | 10 | 20 | 30 | 45 | 60 | 120 | 180 | 300 | 600 | 900 | 1200 | 1800 | 2700 | 3600 | 86400 | 172800 | 604800 | 99999999;
        variant?: VariantKey;
        position?: SwissFromPositionFen;
        /**
         * Anything you want to tell players about the tournament
         */
        description?: string;
        /**
         * Games are rated and impact players ratings
         */
        rated?: boolean;
        /**
         * Make the tournament private and restrict access with a password.
         */
        password?: string;
        /**
         * Usernames of players that must not play together.
         * Two usernames per line, separated by a space.
         *
         */
        forbiddenPairings?: string;
        /**
         * Manual pairings for the next round.
         * Two usernames per line, separated by a space.
         * Present players without a valid pairing will be given a bye, which is worth 1 point.
         * Forfeited players will get 0 points.
         *
         */
        manualPairings?: string;
        /**
         * Who can read and write in the chat.
         * - 0  = No-one
         * - 10 = Only team leaders
         * - 20 = Only team members
         * - 30 = All Lichess players
         *
         */
        chatFor?: number;
        /**
         * Minimum rating to join. Leave empty to let everyone join the tournament.
         */
        'conditions.minRating.rating'?: 1000 | 1100 | 1200 | 1300 | 1400 | 1500 | 1600 | 1700 | 1800 | 1900 | 2000 | 2100 | 2200 | 2300 | 2400 | 2500 | 2600;
        /**
         * Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
         */
        'conditions.maxRating.rating'?: 2200 | 2100 | 2000 | 1900 | 1800 | 1700 | 1600 | 1500 | 1400 | 1300 | 1200 | 1100 | 1000 | 900 | 800;
        /**
         * Minimum number of rated games required to join.
         */
        'conditions.nbRatedGame.nb'?: number;
        /**
         * Only let players join if they have played their last swiss game.
         * If they failed to show up in a recent swiss event, they won't be able to enter yours.
         * This results in a better swiss experience for the players who actually show up.
         *
         */
        'conditions.playYourGames'?: boolean;
        /**
         * Predefined list of usernames that are allowed to join, separated by commas.
         * If this list is non-empty, then usernames absent from this list will be forbidden to join.
         * Adding `%titled` to the list additionally allows any titled player to join.
         * Example: `thibault,german11,%titled`
         *
         */
        'conditions.allowList'?: string;
    };
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}/edit';
};
type ApiSwissUpdateErrors = {
    /**
     * Updating the swiss failed.
     */
    400: _Error;
    /**
     * This user cannot update this Swiss.
     */
    401: SwissUnauthorisedEdit;
};
type ApiSwissUpdateError = ApiSwissUpdateErrors[keyof ApiSwissUpdateErrors];
type ApiSwissUpdateResponses = {
    /**
     * The Swiss tournament was successfully updated.
     */
    200: SwissTournament;
};
type ApiSwissUpdateResponse = ApiSwissUpdateResponses[keyof ApiSwissUpdateResponses];
type ApiSwissScheduleNextRoundData = {
    /**
     * Parameters of the tournament
     */
    body: {
        /**
         * Timestamp in milliseconds to start the next round at a given date and time.
         */
        date?: number;
    };
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}/schedule-next-round';
};
type ApiSwissScheduleNextRoundErrors = {
    /**
     * Updating the swiss failed.
     */
    400: _Error;
    /**
     * This user cannot update this Swiss.
     */
    401: SwissUnauthorisedEdit;
};
type ApiSwissScheduleNextRoundError = ApiSwissScheduleNextRoundErrors[keyof ApiSwissScheduleNextRoundErrors];
type ApiSwissScheduleNextRoundResponses = {
    /**
     * The Swiss tournament was successfully updated.
     */
    204: void;
};
type ApiSwissScheduleNextRoundResponse = ApiSwissScheduleNextRoundResponses[keyof ApiSwissScheduleNextRoundResponses];
type ApiSwissJoinData = {
    /**
     * You may need these depending on the tournament to join
     */
    body?: {
        /**
         * The tournament password, if one is required
         */
        password?: string;
    };
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}/join';
};
type ApiSwissJoinErrors = {
    /**
     * Joining the tournament failed.
     */
    400: _Error;
};
type ApiSwissJoinError = ApiSwissJoinErrors[keyof ApiSwissJoinErrors];
type ApiSwissJoinResponses = {
    /**
     * The tournament was successfully joined.
     */
    200: Ok;
};
type ApiSwissJoinResponse = ApiSwissJoinResponses[keyof ApiSwissJoinResponses];
type ApiSwissWithdrawData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}/withdraw';
};
type ApiSwissWithdrawResponses = {
    /**
     * The tournament was successfully paused or left.
     */
    200: Ok;
};
type ApiSwissWithdrawResponse = ApiSwissWithdrawResponses[keyof ApiSwissWithdrawResponses];
type ApiSwissTerminateData = {
    body?: never;
    path: {
        /**
         * The Swiss tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}/terminate';
};
type ApiSwissTerminateErrors = {
    /**
     * Terminating the Swiss tournament failed.
     */
    400: _Error;
};
type ApiSwissTerminateError = ApiSwissTerminateErrors[keyof ApiSwissTerminateErrors];
type ApiSwissTerminateResponses = {
    /**
     * The Swiss tournament was successfully terminated.
     */
    200: Ok;
};
type ApiSwissTerminateResponse = ApiSwissTerminateResponses[keyof ApiSwissTerminateResponses];
type SwissTrfData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/swiss/{id}.trf';
};
type SwissTrfResponses = {
    /**
     * The TRF representation of a Swiss tournament.
     */
    200: string;
};
type SwissTrfResponse = SwissTrfResponses[keyof SwissTrfResponses];
type GamesBySwissData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: {
        /**
         * Only the games played by a given player
         */
        player?: string;
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
    };
    url: '/api/swiss/{id}/games';
};
type GamesBySwissResponses = {
    /**
     * The list of games of a Swiss tournament.
     */
    200: GamePgn;
};
type GamesBySwissResponse = GamesBySwissResponses[keyof GamesBySwissResponses];
type ResultsBySwissData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: {
        /**
         * Max number of players to fetch
         */
        nb?: number;
    };
    url: '/api/swiss/{id}/results';
};
type ResultsBySwissResponses = {
    /**
     * The results of a Swiss tournament.
     */
    200: {
        absent?: boolean;
        rank: number;
        points: number;
        tieBreak: number;
        rating: number;
        username: string;
        title?: Title;
        performance: number;
    };
};
type ResultsBySwissResponse = ResultsBySwissResponses[keyof ResultsBySwissResponses];
type ApiTeamSwissData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: {
        /**
         * How many tournaments to download.
         */
        max?: number;
        /**
         * [Filter] Only swiss tournaments in this current state.
         *
         */
        status?: SwissStatus & unknown;
        /**
         * [Filter] Only swiss tournaments created by a given user.
         *
         */
        createdBy?: string;
        /**
         * [Filter] Only swiss tournaments with a given name.
         *
         */
        name?: string;
    };
    url: '/api/team/{teamId}/swiss';
};
type ApiTeamSwissResponses = {
    /**
     * The list of Swiss tournaments of a team.
     */
    200: SwissTournament;
};
type ApiTeamSwissResponse = ApiTeamSwissResponses[keyof ApiTeamSwissResponses];
type StudyChapterPgnData = {
    body?: never;
    path: {
        /**
         * The study ID
         */
        studyId: string;
        /**
         * The chapter ID
         */
        chapterId: string;
    };
    query?: {
        /**
         * Include clock comments in the PGN moves, when available.
         * Example: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *
         */
        clocks?: boolean;
        /**
         * Include analysis and annotator comments in the PGN moves, when available.
         * Example: `12. Bxf6 { [%eval 0.23] } a3 { White is in a pickle. }`
         *
         */
        comments?: boolean;
        /**
         * Include non-mainline moves, when available.
         * Example: `4. d4 Bb4+ (4... Nc6 5. Nf3 Bb4+ 6. Bd2 (6. Nbd2 O-O 7. O-O) 6... Bd6) 5. Nd2`
         *
         */
        variations?: boolean;
        /**
         * Add a `Source` PGN tag with the study chapter URL.
         * Example: `[Source "https://lichess.org/study/4NBHImfM/1Tk4IyTz"]`
         *
         */
        source?: boolean;
        /**
         * Add a `Orientation` PGN tag with the chapter predefined orientation.
         * Example: `[Orientation "white"]`
         *
         */
        orientation?: boolean;
    };
    url: '/api/study/{studyId}/{chapterId}.pgn';
};
type StudyChapterPgnResponses = {
    /**
     * The chapter of the study.
     */
    200: StudyPgn;
};
type StudyChapterPgnResponse = StudyChapterPgnResponses[keyof StudyChapterPgnResponses];
type StudyAllChaptersPgnData = {
    body?: never;
    path: {
        /**
         * The study ID
         */
        studyId: string;
    };
    query?: {
        /**
         * Include clock comments in the PGN moves, when available.
         * Example: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *
         */
        clocks?: boolean;
        /**
         * Include analysis and annotator comments in the PGN moves, when available.
         * Example: `12. Bxf6 { [%eval 0.23] } a3 { White is in a pickle. }`
         *
         */
        comments?: boolean;
        /**
         * Include non-mainline moves, when available.
         * Example: `4. d4 Bb4+ (4... Nc6 5. Nf3 Bb4+ 6. Bd2 (6. Nbd2 O-O 7. O-O) 6... Bd6) 5. Nd2`
         *
         */
        variations?: boolean;
        /**
         * Add a `Source` PGN tag with the study chapter URL.
         * Example: `[Source "https://lichess.org/study/4NBHImfM/1Tk4IyTz"]`
         *
         */
        source?: boolean;
        /**
         * Add a `Orientation` PGN tag with the chapter predefined orientation.
         * Example: `[Orientation "white"]`
         *
         */
        orientation?: boolean;
    };
    url: '/api/study/{studyId}.pgn';
};
type StudyAllChaptersPgnResponses = {
    /**
     * The PGN representation of the study.
     */
    200: StudyPgn;
};
type StudyAllChaptersPgnResponse = StudyAllChaptersPgnResponses[keyof StudyAllChaptersPgnResponses];
type StudyAllChaptersHeadData = {
    body?: never;
    path: {
        /**
         * The study ID
         */
        studyId: string;
    };
    query?: never;
    url: '/api/study/{studyId}.pgn';
};
type StudyAllChaptersHeadResponses = {
    /**
     * The study headers.
     */
    204: void;
};
type StudyAllChaptersHeadResponse = StudyAllChaptersHeadResponses[keyof StudyAllChaptersHeadResponses];
type ApiStudyImportPgnData = {
    /**
     * Parameters of the import
     */
    body: {
        /**
         * PGN to import. Can contain multiple games separated by 2 or more newlines.
         *
         */
        pgn: string;
        /**
         * Name of the new chapter.
         * If not specified, or if multiple chapters are created, the names will be inferred from the PGN tags.
         *
         */
        name?: string;
        /**
         * Default board orientation.
         */
        orientation?: 'white' | 'black';
        variant?: VariantKey;
    };
    path: {
        /**
         * ID of the study
         */
        studyId: string;
    };
    query?: never;
    url: '/api/study/{studyId}/import-pgn';
};
type ApiStudyImportPgnErrors = {
    /**
     * The creation of the chapter(s) failed.
     */
    400: _Error;
};
type ApiStudyImportPgnError = ApiStudyImportPgnErrors[keyof ApiStudyImportPgnErrors];
type ApiStudyImportPgnResponses = {
    /**
     * The chapters that were created.
     */
    200: StudyImportPgnChapters;
};
type ApiStudyImportPgnResponse = ApiStudyImportPgnResponses[keyof ApiStudyImportPgnResponses];
type StudyExportAllPgnData = {
    body?: never;
    path: {
        /**
         * The user whose studies we export
         */
        username: string;
    };
    query?: {
        /**
         * Include clock comments in the PGN moves, when available.
         * Example: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *
         */
        clocks?: boolean;
        /**
         * Include analysis and annotator comments in the PGN moves, when available.
         * Example: `12. Bxf6 { [%eval 0.23] } a3 { White is in a pickle. }`
         *
         */
        comments?: boolean;
        /**
         * Include non-mainline moves, when available.
         * Example: `4. d4 Bb4+ (4... Nc6 5. Nf3 Bb4+ 6. Bd2 (6. Nbd2 O-O 7. O-O) 6... Bd6) 5. Nd2`
         *
         */
        variations?: boolean;
        /**
         * Add a `Source` PGN tag with the study chapter URL.
         * Example: `[Source "https://lichess.org/study/4NBHImfM/1Tk4IyTz"]`
         *
         */
        source?: boolean;
        /**
         * Add a `Orientation` PGN tag with the chapter predefined orientation.
         * Example: `[Orientation "white"]`
         *
         */
        orientation?: boolean;
    };
    url: '/study/by/{username}/export.pgn';
};
type StudyExportAllPgnResponses = {
    /**
     * The studies of the user.
     */
    200: StudyPgn;
};
type StudyExportAllPgnResponse = StudyExportAllPgnResponses[keyof StudyExportAllPgnResponses];
type StudyListMetadataData = {
    body?: never;
    path: {
        /**
         * The user whose studies we list
         */
        username: string;
    };
    query?: never;
    url: '/api/study/by/{username}';
};
type StudyListMetadataResponses = {
    /**
     * The list of studies.
     */
    200: StudyMetadata;
};
type StudyListMetadataResponse = StudyListMetadataResponses[keyof StudyListMetadataResponses];
type ApiStudyStudyIdChapterIdDeleteData = {
    body?: never;
    path: {
        /**
         * The study ID
         */
        studyId: string;
        /**
         * The chapter ID
         */
        chapterId: string;
    };
    query?: never;
    url: '/api/study/{studyId}/{chapterId}';
};
type ApiStudyStudyIdChapterIdDeleteResponses = {
    /**
     * Chapter successfully deleted
     */
    204: void;
};
type ApiStudyStudyIdChapterIdDeleteResponse = ApiStudyStudyIdChapterIdDeleteResponses[keyof ApiStudyStudyIdChapterIdDeleteResponses];
type BroadcastsOfficialData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Max number of broadcasts to fetch
         */
        nb?: number;
        /**
         * Convert the "description" field from markdown to HTML
         */
        html?: boolean;
    };
    url: '/api/broadcast';
};
type BroadcastsOfficialResponses = {
    /**
     * The list of official broadcasts.
     */
    200: BroadcastWithRounds;
};
type BroadcastsOfficialResponse = BroadcastsOfficialResponses[keyof BroadcastsOfficialResponses];
type BroadcastsTopData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Which page to fetch. Only page 1 has "active" broadcasts.
         */
        page?: number;
        /**
         * Convert the "description" field from markdown to HTML
         */
        html?: boolean;
    };
    url: '/api/broadcast/top';
};
type BroadcastsTopResponses = {
    /**
     * Paginated top broadcast previews.
     */
    200: BroadcastTop;
};
type BroadcastsTopResponse = BroadcastsTopResponses[keyof BroadcastsTopResponses];
type BroadcastsByUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: {
        page?: number;
        /**
         * Convert the "description" field from markdown to HTML
         */
        html?: boolean;
    };
    url: '/api/broadcast/by/{username}';
};
type BroadcastsByUserResponses = {
    /**
     * A paginated list of the broadcasts created by a user.
     */
    200: {
        currentPage: number;
        maxPerPage: number;
        currentPageResults: Array<BroadcastByUser>;
        nbResults: number;
        previousPage: number | null;
        nextPage: number | null;
        nbPages: number;
    };
};
type BroadcastsByUserResponse = BroadcastsByUserResponses[keyof BroadcastsByUserResponses];
type BroadcastTourCreateData = {
    body: BroadcastForm;
    path?: never;
    query?: never;
    url: '/broadcast/new';
};
type BroadcastTourCreateErrors = {
    /**
     * The creation of the broadcast tournament failed.
     */
    400: _Error;
};
type BroadcastTourCreateError = BroadcastTourCreateErrors[keyof BroadcastTourCreateErrors];
type BroadcastTourCreateResponses = {
    /**
     * The broadcast tournament was successfully created.
     */
    200: BroadcastWithRounds;
};
type BroadcastTourCreateResponse = BroadcastTourCreateResponses[keyof BroadcastTourCreateResponses];
type BroadcastTourGetData = {
    body?: never;
    path: {
        /**
         * The broadcast tournament ID
         */
        broadcastTournamentId: string;
    };
    query?: never;
    url: '/api/broadcast/{broadcastTournamentId}';
};
type BroadcastTourGetResponses = {
    /**
     * The information about the broadcast tournament.
     */
    200: BroadcastWithRounds;
};
type BroadcastTourGetResponse = BroadcastTourGetResponses[keyof BroadcastTourGetResponses];
type BroadcastPlayersGetData = {
    body?: never;
    path: {
        /**
         * The broadcast tournament ID
         */
        broadcastTournamentId: string;
    };
    query?: never;
    url: '/broadcast/{broadcastTournamentId}/players';
};
type BroadcastPlayersGetResponses = {
    /**
     * The broadcast players
     */
    200: Array<BroadcastPlayerEntry>;
};
type BroadcastPlayersGetResponse = BroadcastPlayersGetResponses[keyof BroadcastPlayersGetResponses];
type BroadcastTourUpdateData = {
    body: BroadcastForm;
    path: {
        /**
         * The broadcast ID
         */
        broadcastTournamentId: string;
    };
    query?: never;
    url: '/broadcast/{broadcastTournamentId}/edit';
};
type BroadcastTourUpdateErrors = {
    /**
     * The broadcast tournament update failed.
     */
    400: _Error;
};
type BroadcastTourUpdateError = BroadcastTourUpdateErrors[keyof BroadcastTourUpdateErrors];
type BroadcastTourUpdateResponses = {
    /**
     * The broadcast tournament was successfully edited.
     */
    200: Ok;
};
type BroadcastTourUpdateResponse = BroadcastTourUpdateResponses[keyof BroadcastTourUpdateResponses];
type BroadcastRoundCreateData = {
    body: BroadcastRoundForm;
    path: {
        /**
         * The broadcast tournament ID
         */
        broadcastTournamentId: string;
    };
    query?: never;
    url: '/broadcast/{broadcastTournamentId}/new';
};
type BroadcastRoundCreateErrors = {
    /**
     * The creation of the broadcast failed.
     */
    400: _Error;
};
type BroadcastRoundCreateError = BroadcastRoundCreateErrors[keyof BroadcastRoundCreateErrors];
type BroadcastRoundCreateResponses = {
    /**
     * The broadcast round was successfully created.
     */
    200: BroadcastRoundNew;
};
type BroadcastRoundCreateResponse = BroadcastRoundCreateResponses[keyof BroadcastRoundCreateResponses];
type BroadcastRoundGetData = {
    body?: never;
    path: {
        /**
         * The broadcast tournament slug. Only used for SEO, the slug can be safely replaced by `-`. Only the `broadcastRoundId` is actually used.
         */
        broadcastTournamentSlug: string;
        /**
         * The broadcast round slug. Only used for SEO, the slug can be safely replaced by `-`. Only the `broadcastRoundId` is actually used.
         */
        broadcastRoundSlug: string;
        /**
         * The broadcast Round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/api/broadcast/{broadcastTournamentSlug}/{broadcastRoundSlug}/{broadcastRoundId}';
};
type BroadcastRoundGetResponses = {
    /**
     * The information about the broadcast round.
     */
    200: BroadcastRound;
};
type BroadcastRoundGetResponse = BroadcastRoundGetResponses[keyof BroadcastRoundGetResponses];
type BroadcastRoundUpdateData = {
    body: BroadcastRoundForm;
    path: {
        /**
         * The broadcast round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/broadcast/round/{broadcastRoundId}/edit';
};
type BroadcastRoundUpdateErrors = {
    /**
     * The broadcast round update failed.
     */
    400: _Error;
};
type BroadcastRoundUpdateError = BroadcastRoundUpdateErrors[keyof BroadcastRoundUpdateErrors];
type BroadcastRoundUpdateResponses = {
    /**
     * The broadcast round was successfully edited.
     */
    200: Ok;
};
type BroadcastRoundUpdateResponse = BroadcastRoundUpdateResponses[keyof BroadcastRoundUpdateResponses];
type BroadcastRoundResetData = {
    body?: never;
    path: {
        /**
         * The broadcast round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/api/broadcast/round/{broadcastRoundId}/reset';
};
type BroadcastRoundResetResponses = {
    /**
     * The broadcast round was successfully reset.
     */
    200: Ok;
};
type BroadcastRoundResetResponse = BroadcastRoundResetResponses[keyof BroadcastRoundResetResponses];
type BroadcastPushData = {
    /**
     * The PGN. It can contain up to 64 games, separated by a double new line.
     */
    body: string;
    path: {
        /**
         * The broadcast round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/api/broadcast/round/{broadcastRoundId}/push';
};
type BroadcastPushErrors = {
    /**
     * There was a problem with the pushed PGN.
     */
    400: {
        error?: string;
    };
};
type BroadcastPushError = BroadcastPushErrors[keyof BroadcastPushErrors];
type BroadcastPushResponses = {
    /**
     * The broadcast was successfully updated.
     */
    200: BroadcastPgnPush;
};
type BroadcastPushResponse = BroadcastPushResponses[keyof BroadcastPushResponses];
type BroadcastStreamRoundPgnData = {
    body?: never;
    path: {
        /**
         * The broadcast round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/api/stream/broadcast/round/{broadcastRoundId}.pgn';
};
type BroadcastStreamRoundPgnResponses = {
    /**
     * The PGN representation of the tournament games, then the PGNs of games as they are updated.
     */
    200: StudyPgn;
};
type BroadcastStreamRoundPgnResponse = BroadcastStreamRoundPgnResponses[keyof BroadcastStreamRoundPgnResponses];
type BroadcastRoundPgnData = {
    body?: never;
    path: {
        /**
         * The round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/api/broadcast/round/{broadcastRoundId}.pgn';
};
type BroadcastRoundPgnResponses = {
    /**
     * The PGN representation of the round.
     */
    200: StudyPgn;
};
type BroadcastRoundPgnResponse = BroadcastRoundPgnResponses[keyof BroadcastRoundPgnResponses];
type BroadcastAllRoundsPgnData = {
    body?: never;
    path: {
        /**
         * The broadcast tournament ID
         */
        broadcastTournamentId: string;
    };
    query?: never;
    url: '/api/broadcast/{broadcastTournamentId}.pgn';
};
type BroadcastAllRoundsPgnResponses = {
    /**
     * The PGN representation of the broadcast.
     */
    200: StudyPgn;
};
type BroadcastAllRoundsPgnResponse = BroadcastAllRoundsPgnResponses[keyof BroadcastAllRoundsPgnResponses];
type BroadcastMyRoundsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * How many rounds to get
         */
        nb?: number;
    };
    url: '/api/broadcast/my-rounds';
};
type BroadcastMyRoundsGetResponses = {
    /**
     * The broadcast rounds with their tournament and a `study.writeable` flag.
     */
    200: BroadcastMyRound;
};
type BroadcastMyRoundsGetResponse = BroadcastMyRoundsGetResponses[keyof BroadcastMyRoundsGetResponses];
type FidePlayerGetData = {
    body?: never;
    path: {
        /**
         * The FIDE player ID.
         */
        playerId: number;
    };
    query?: never;
    url: '/api/fide/player/{playerId}';
};
type FidePlayerGetResponses = {
    /**
     * The information about the FIDE player.
     */
    200: FidePlayer;
};
type FidePlayerGetResponse = FidePlayerGetResponses[keyof FidePlayerGetResponses];
type FidePlayerSearchData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The search query.
         */
        q: string;
    };
    url: '/api/fide/player';
};
type FidePlayerSearchResponses = {
    /**
     * The list of FIDE players.
     */
    200: Array<FidePlayer>;
};
type FidePlayerSearchResponse = FidePlayerSearchResponses[keyof FidePlayerSearchResponses];
type ApiSimulData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/simul';
};
type ApiSimulResponses = {
    /**
     * The list of simuls.
     */
    200: {
        pending?: Array<Simul>;
        created?: Array<Simul>;
        started?: Array<Simul>;
        finished?: Array<Simul>;
    };
};
type ApiSimulResponse = ApiSimulResponses[keyof ApiSimulResponses];
type TeamShowData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: never;
    url: '/api/team/{teamId}';
};
type TeamShowResponses = {
    /**
     * The information about the team.
     */
    200: Team;
};
type TeamShowResponse = TeamShowResponses[keyof TeamShowResponses];
type TeamAllData = {
    body?: never;
    path?: never;
    query?: {
        page?: number;
    };
    url: '/api/team/all';
};
type TeamAllResponses = {
    /**
     * A paginated list of the most popular teams.
     */
    200: TeamPaginatorJson;
};
type TeamAllResponse = TeamAllResponses[keyof TeamAllResponses];
type TeamOfUsernameData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/team/of/{username}';
};
type TeamOfUsernameResponses = {
    /**
     * The list of teams the user is a member of.
     */
    200: Array<Team>;
};
type TeamOfUsernameResponse = TeamOfUsernameResponses[keyof TeamOfUsernameResponses];
type TeamSearchData = {
    body?: never;
    path?: never;
    query?: {
        text?: string;
        page?: number;
    };
    url: '/api/team/search';
};
type TeamSearchResponses = {
    /**
     * The paginated list of teams.
     */
    200: TeamPaginatorJson;
};
type TeamSearchResponse = TeamSearchResponses[keyof TeamSearchResponses];
type TeamIdUsersData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: {
        /**
         * Full user documents with performance ratings.
         * This limits the response to 1,000 users.
         *
         */
        full?: boolean;
    };
    url: '/api/team/{teamId}/users';
};
type TeamIdUsersResponses = {
    /**
     * The list of users in the team.
     */
    200: {
        joinedTeamAt?: number;
        id: string;
        name: string;
        title?: Title;
        patron?: boolean;
    };
};
type TeamIdUsersResponse = TeamIdUsersResponses[keyof TeamIdUsersResponses];
type ApiTeamArenaData = {
    body?: never;
    path: {
        /**
         * ID of the team
         */
        teamId: string;
    };
    query?: {
        /**
         * How many tournaments to download.
         */
        max?: number;
        /**
         * [Filter] Only arena tournaments in this current state.
         *
         */
        status?: ArenaStatusName & unknown;
        /**
         * [Filter] Only arena tournaments created by a given user.
         *
         */
        createdBy?: string;
        /**
         * [Filter] Only arena tournaments with a given name.
         *
         */
        name?: string;
    };
    url: '/api/team/{teamId}/arena';
};
type ApiTeamArenaResponses = {
    /**
     * The list of Arena tournaments of a team.
     */
    200: ArenaTournament;
};
type ApiTeamArenaResponse = ApiTeamArenaResponses[keyof ApiTeamArenaResponses];
type TeamIdJoinData = {
    body?: {
        /**
         * Required if team manually reviews admission requests.
         */
        message?: string;
        /**
         * Optional password, if the team requires one.
         */
        password?: string;
    };
    path: {
        teamId: string;
    };
    query?: never;
    url: '/team/{teamId}/join';
};
type TeamIdJoinResponses = {
    /**
     * The request to join a team was successfully sent.
     */
    200: Ok;
};
type TeamIdJoinResponse = TeamIdJoinResponses[keyof TeamIdJoinResponses];
type TeamIdQuitData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: never;
    url: '/team/{teamId}/quit';
};
type TeamIdQuitResponses = {
    /**
     * The logged in user has successfully left the team.
     */
    200: Ok;
};
type TeamIdQuitResponse = TeamIdQuitResponses[keyof TeamIdQuitResponses];
type TeamRequestsData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: {
        /**
         * Get the declined join requests
         */
        declined?: boolean;
    };
    url: '/api/team/{teamId}/requests';
};
type TeamRequestsResponses = {
    /**
     * The list of pending join requests on your team
     */
    200: Array<TeamRequestWithUser>;
};
type TeamRequestsResponse = TeamRequestsResponses[keyof TeamRequestsResponses];
type TeamRequestAcceptData = {
    body?: never;
    path: {
        teamId: string;
        userId: string;
    };
    query?: never;
    url: '/api/team/{teamId}/request/{userId}/accept';
};
type TeamRequestAcceptResponses = {
    /**
     * The member has been added to the team.
     */
    200: Ok;
};
type TeamRequestAcceptResponse = TeamRequestAcceptResponses[keyof TeamRequestAcceptResponses];
type TeamRequestDeclineData = {
    body?: never;
    path: {
        teamId: string;
        userId: string;
    };
    query?: never;
    url: '/api/team/{teamId}/request/{userId}/decline';
};
type TeamRequestDeclineResponses = {
    /**
     * The join request has been declined and is no longer pending.
     */
    200: Ok;
};
type TeamRequestDeclineResponse = TeamRequestDeclineResponses[keyof TeamRequestDeclineResponses];
type TeamIdKickUserIdData = {
    body?: never;
    path: {
        teamId: string;
        userId: string;
    };
    query?: never;
    url: '/api/team/{teamId}/kick/{userId}';
};
type TeamIdKickUserIdResponses = {
    /**
     * The member has been kicked from the team.
     */
    200: Ok;
};
type TeamIdKickUserIdResponse = TeamIdKickUserIdResponses[keyof TeamIdKickUserIdResponses];
type TeamIdPmAllData = {
    body: {
        /**
         * The message to send to all your team members.
         */
        message?: string;
    };
    path: {
        teamId: string;
    };
    query?: never;
    url: '/team/{teamId}/pm-all';
};
type TeamIdPmAllErrors = {
    /**
     * The sending of message to all team members has failed.
     */
    400: _Error;
};
type TeamIdPmAllError = TeamIdPmAllErrors[keyof TeamIdPmAllErrors];
type TeamIdPmAllResponses = {
    /**
     * The message has successfully been sent to all team members.
     */
    200: Ok;
};
type TeamIdPmAllResponse = TeamIdPmAllResponses[keyof TeamIdPmAllResponses];
type StreamerLiveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/streamer/live';
};
type StreamerLiveResponses = {
    /**
     * The list of live streamers and their respective information.
     */
    200: Array<LightUser>;
};
type StreamerLiveResponse = StreamerLiveResponses[keyof StreamerLiveResponses];
type ApiCrosstableData = {
    body?: never;
    path: {
        user1: string;
        user2: string;
    };
    query?: {
        /**
         * Whether to get the current match data, if any
         */
        matchup?: boolean;
    };
    url: '/api/crosstable/{user1}/{user2}';
};
type ApiCrosstableResponses = {
    /**
     * The crosstable of the two users.
     */
    200: Crosstable;
};
type ApiCrosstableResponse = ApiCrosstableResponses[keyof ApiCrosstableResponses];
type ApiPlayerAutocompleteData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The beginning of a username
         */
        term: string;
        /**
         * - `false` returns an array of usernames
         * - `true` returns an object with matching users
         *
         */
        object?: boolean;
        /**
         * Returns followed players matching `term` if any, else returns other players.
         * Requires [OAuth](#tag/OAuth).
         *
         */
        friend?: boolean;
    };
    url: '/api/player/autocomplete';
};
type ApiPlayerAutocompleteResponses = {
    /**
     * An array of players which usernames start with the provided term.
     */
    200: Array<string> | {
        result?: Array<LightUserOnline>;
    };
};
type ApiPlayerAutocompleteResponse = ApiPlayerAutocompleteResponses[keyof ApiPlayerAutocompleteResponses];
type ReadNoteData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/user/{username}/note';
};
type ReadNoteResponses = {
    /**
     * The list of notes you have added for this user
     */
    200: Array<UserNote>;
};
type ReadNoteResponse = ReadNoteResponses[keyof ReadNoteResponses];
type WriteNoteData = {
    body: {
        /**
         * The contents of the note
         */
        text: string;
    };
    path: {
        username: string;
    };
    query?: never;
    url: '/api/user/{username}/note';
};
type WriteNoteResponses = {
    /**
     * The note was successfully added.
     */
    200: Ok;
};
type WriteNoteResponse = WriteNoteResponses[keyof WriteNoteResponses];
type ApiUserFollowingData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/rel/following';
};
type ApiUserFollowingResponses = {
    /**
     * The list of users followed by a user.
     */
    200: UserExtended;
};
type ApiUserFollowingResponse = ApiUserFollowingResponses[keyof ApiUserFollowingResponses];
type FollowUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/rel/follow/{username}';
};
type FollowUserResponses = {
    /**
     * The player was successfully added.
     */
    200: Ok;
};
type FollowUserResponse = FollowUserResponses[keyof FollowUserResponses];
type UnfollowUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/rel/unfollow/{username}';
};
type UnfollowUserResponses = {
    /**
     * The player was successfully removed.
     */
    200: Ok;
};
type UnfollowUserResponse = UnfollowUserResponses[keyof UnfollowUserResponses];
type BlockUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/rel/block/{username}';
};
type BlockUserResponses = {
    /**
     * The player was successfully added.
     */
    200: Ok;
};
type BlockUserResponse = BlockUserResponses[keyof BlockUserResponses];
type UnblockUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/rel/unblock/{username}';
};
type UnblockUserResponses = {
    /**
     * The player was successfully removed.
     */
    200: Ok;
};
type UnblockUserResponse = UnblockUserResponses[keyof UnblockUserResponses];
type ApiStreamEventData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/stream/event';
};
type ApiStreamEventResponses = {
    /**
     * The stream of events reaching the logged in user.
     */
    200: GameStartEvent | GameFinishEvent | ChallengeEvent | ChallengeCanceledEvent | ChallengeDeclinedEvent;
};
type ApiStreamEventResponse = ApiStreamEventResponses[keyof ApiStreamEventResponses];
type ApiBoardSeekData = {
    /**
     * Parameters of the seek
     */
    body?: {
        /**
         * Whether the game is rated and impacts players ratings.
         */
        rated?: boolean;
        variant?: VariantKey;
        /**
         * The rating range of potential opponents. Better left empty.
         * Example: 1500-1800
         *
         */
        ratingRange?: string;
    } & ({
        /**
         * Clock initial time in minutes. Required for real-time seeks.
         */
        time: number;
        /**
         * Clock increment in seconds. Required for real-time seeks.
         */
        increment: number;
        /**
         * The color to play. Better left empty to automatically get 50% white.
         */
        color?: 'random' | 'white' | 'black';
    } | {
        /**
         * Days per turn. Required for correspondence seeks.
         */
        days: 1 | 2 | 3 | 5 | 7 | 10 | 14;
    });
    path?: never;
    query?: never;
    url: '/api/board/seek';
};
type ApiBoardSeekErrors = {
    /**
     * The creation of the seek failed.
     */
    400: _Error;
};
type ApiBoardSeekError = ApiBoardSeekErrors[keyof ApiBoardSeekErrors];
type ApiBoardSeekResponses = {
    /**
     * Only happens when doing a correspondence seek
     */
    200: {
        id: string;
    };
};
type ApiBoardSeekResponse = ApiBoardSeekResponses[keyof ApiBoardSeekResponses];
type BoardGameStreamData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/stream/{gameId}';
};
type BoardGameStreamErrors = {
    /**
     * The game was not found.
     */
    404: NotFound;
};
type BoardGameStreamError = BoardGameStreamErrors[keyof BoardGameStreamErrors];
type BoardGameStreamResponses = {
    /**
     * The stream of the game.
     */
    200: GameFullEvent | GameStateEvent | ChatLineEvent | OpponentGone;
};
type BoardGameStreamResponse = BoardGameStreamResponses[keyof BoardGameStreamResponses];
type BoardGameMoveData = {
    body?: never;
    path: {
        gameId: string;
        /**
         * The move to play, in UCI format
         */
        move: string;
    };
    query?: {
        /**
         * Whether to offer (or agree to) a draw
         */
        offeringDraw?: boolean;
    };
    url: '/api/board/game/{gameId}/move/{move}';
};
type BoardGameMoveErrors = {
    /**
     * The move failed.
     */
    400: _Error;
};
type BoardGameMoveError = BoardGameMoveErrors[keyof BoardGameMoveErrors];
type BoardGameMoveResponses = {
    /**
     * The move was successfully made.
     */
    200: Ok;
};
type BoardGameMoveResponse = BoardGameMoveResponses[keyof BoardGameMoveResponses];
type BoardGameChatGetData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/chat';
};
type BoardGameChatGetResponses = {
    /**
     * The messages posted in the chat.
     */
    200: GameChat;
};
type BoardGameChatGetResponse = BoardGameChatGetResponses[keyof BoardGameChatGetResponses];
type BoardGameChatPostData = {
    body: {
        room: 'player' | 'spectator';
        text: string;
    };
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/chat';
};
type BoardGameChatPostErrors = {
    /**
     * The posting of the message in the chat failed.
     */
    400: _Error;
};
type BoardGameChatPostError = BoardGameChatPostErrors[keyof BoardGameChatPostErrors];
type BoardGameChatPostResponses = {
    /**
     * The message was successfully posted in the chat.
     */
    200: Ok;
};
type BoardGameChatPostResponse = BoardGameChatPostResponses[keyof BoardGameChatPostResponses];
type BoardGameAbortData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/abort';
};
type BoardGameAbortErrors = {
    /**
     * The abortion of the game failed.
     */
    400: _Error;
};
type BoardGameAbortError = BoardGameAbortErrors[keyof BoardGameAbortErrors];
type BoardGameAbortResponses = {
    /**
     * The game successfully aborted.
     */
    200: Ok;
};
type BoardGameAbortResponse = BoardGameAbortResponses[keyof BoardGameAbortResponses];
type BoardGameResignData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/resign';
};
type BoardGameResignErrors = {
    /**
     * The resigning from the game failed.
     */
    400: _Error;
};
type BoardGameResignError = BoardGameResignErrors[keyof BoardGameResignErrors];
type BoardGameResignResponses = {
    /**
     * The game was successfully resigned.
     */
    200: Ok;
};
type BoardGameResignResponse = BoardGameResignResponses[keyof BoardGameResignResponses];
type BoardGameDrawData = {
    body?: never;
    path: {
        gameId: string;
        accept: boolean | 'yes';
    };
    query?: never;
    url: '/api/board/game/{gameId}/draw/{accept}';
};
type BoardGameDrawErrors = {
    /**
     * The draw offering failed.
     */
    400: _Error;
};
type BoardGameDrawError = BoardGameDrawErrors[keyof BoardGameDrawErrors];
type BoardGameDrawResponses = {
    /**
     * The draw offer was successfully sent.
     */
    200: Ok;
};
type BoardGameDrawResponse = BoardGameDrawResponses[keyof BoardGameDrawResponses];
type BoardGameTakebackData = {
    body?: never;
    path: {
        gameId: string;
        accept: boolean | 'yes';
    };
    query?: never;
    url: '/api/board/game/{gameId}/takeback/{accept}';
};
type BoardGameTakebackErrors = {
    /**
     * The takeback offering failed.
     */
    400: _Error;
};
type BoardGameTakebackError = BoardGameTakebackErrors[keyof BoardGameTakebackErrors];
type BoardGameTakebackResponses = {
    /**
     * The takeback offer was successfully sent.
     */
    200: Ok;
};
type BoardGameTakebackResponse = BoardGameTakebackResponses[keyof BoardGameTakebackResponses];
type BoardGameClaimVictoryData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/claim-victory';
};
type BoardGameClaimVictoryErrors = {
    /**
     * The victory claim has failed.
     */
    400: _Error;
};
type BoardGameClaimVictoryError = BoardGameClaimVictoryErrors[keyof BoardGameClaimVictoryErrors];
type BoardGameClaimVictoryResponses = {
    /**
     * The victory was successfully claimed.
     */
    200: Ok;
};
type BoardGameClaimVictoryResponse = BoardGameClaimVictoryResponses[keyof BoardGameClaimVictoryResponses];
type BoardGameBerserkData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/berserk';
};
type BoardGameBerserkErrors = {
    /**
     * The berserk has failed.
     */
    400: _Error;
};
type BoardGameBerserkError = BoardGameBerserkErrors[keyof BoardGameBerserkErrors];
type BoardGameBerserkResponses = {
    /**
     * The player successfully went berserk.
     */
    200: Ok;
};
type BoardGameBerserkResponse = BoardGameBerserkResponses[keyof BoardGameBerserkResponses];
type ApiBotOnlineData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * How many bot users to fetch
         */
        nb?: number;
    };
    url: '/api/bot/online';
};
type ApiBotOnlineResponses = {
    /**
     * The list of online bot users
     */
    200: User;
};
type ApiBotOnlineResponse = ApiBotOnlineResponses[keyof ApiBotOnlineResponses];
type BotAccountUpgradeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/bot/account/upgrade';
};
type BotAccountUpgradeErrors = {
    /**
     * The upgrade of the bot account failed.
     */
    400: _Error;
};
type BotAccountUpgradeError = BotAccountUpgradeErrors[keyof BotAccountUpgradeErrors];
type BotAccountUpgradeResponses = {
    /**
     * The bot account was successfully upgraded.
     */
    200: Ok;
};
type BotAccountUpgradeResponse = BotAccountUpgradeResponses[keyof BotAccountUpgradeResponses];
type BotGameStreamData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/stream/{gameId}';
};
type BotGameStreamErrors = {
    /**
     * The bot game was not found.
     */
    404: NotFound;
};
type BotGameStreamError = BotGameStreamErrors[keyof BotGameStreamErrors];
type BotGameStreamResponses = {
    /**
     * The stream of the bot game.
     */
    200: GameFullEvent | GameStateEvent | ChatLineEvent | OpponentGone;
};
type BotGameStreamResponse = BotGameStreamResponses[keyof BotGameStreamResponses];
type BotGameMoveData = {
    body?: never;
    path: {
        gameId: string;
        /**
         * The move to play, in UCI format
         */
        move: string;
    };
    query?: {
        /**
         * Whether to offer (or agree to) a draw
         */
        offeringDraw?: boolean;
    };
    url: '/api/bot/game/{gameId}/move/{move}';
};
type BotGameMoveErrors = {
    /**
     * The bot move failed.
     */
    400: _Error;
};
type BotGameMoveError = BotGameMoveErrors[keyof BotGameMoveErrors];
type BotGameMoveResponses = {
    /**
     * The bot move was successfully made.
     */
    200: Ok;
};
type BotGameMoveResponse = BotGameMoveResponses[keyof BotGameMoveResponses];
type BotGameChatGetData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/{gameId}/chat';
};
type BotGameChatGetResponses = {
    /**
     * The messages posted in the chat.
     */
    200: GameChat;
};
type BotGameChatGetResponse = BotGameChatGetResponses[keyof BotGameChatGetResponses];
type BotGameChatData = {
    body: {
        room: 'player' | 'spectator';
        text: string;
    };
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/{gameId}/chat';
};
type BotGameChatErrors = {
    /**
     * The posting of the  message in chat failed.
     */
    400: _Error;
};
type BotGameChatError = BotGameChatErrors[keyof BotGameChatErrors];
type BotGameChatResponses = {
    /**
     * The message was successfully posted in chat.
     */
    200: Ok;
};
type BotGameChatResponse = BotGameChatResponses[keyof BotGameChatResponses];
type BotGameAbortData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/{gameId}/abort';
};
type BotGameAbortErrors = {
    /**
     * The abortion of the game failed.
     */
    400: _Error;
};
type BotGameAbortError = BotGameAbortErrors[keyof BotGameAbortErrors];
type BotGameAbortResponses = {
    /**
     * The game was successfully aborted.
     */
    200: Ok;
};
type BotGameAbortResponse = BotGameAbortResponses[keyof BotGameAbortResponses];
type BotGameResignData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/{gameId}/resign';
};
type BotGameResignErrors = {
    /**
     * Resigning the game failed.
     */
    400: _Error;
};
type BotGameResignError = BotGameResignErrors[keyof BotGameResignErrors];
type BotGameResignResponses = {
    /**
     * The game was successfully resigned from.
     */
    200: Ok;
};
type BotGameResignResponse = BotGameResignResponses[keyof BotGameResignResponses];
type BotGameDrawData = {
    body?: never;
    path: {
        gameId: string;
        accept: boolean | 'yes';
    };
    query?: never;
    url: '/api/bot/game/{gameId}/draw/{accept}';
};
type BotGameDrawErrors = {
    /**
     * The draw offering failed.
     */
    400: _Error;
};
type BotGameDrawError = BotGameDrawErrors[keyof BotGameDrawErrors];
type BotGameDrawResponses = {
    /**
     * The draw offer was successfully sent.
     */
    200: Ok;
};
type BotGameDrawResponse = BotGameDrawResponses[keyof BotGameDrawResponses];
type BotGameTakebackData = {
    body?: never;
    path: {
        gameId: string;
        accept: boolean | 'yes';
    };
    query?: never;
    url: '/api/bot/game/{gameId}/takeback/{accept}';
};
type BotGameTakebackErrors = {
    /**
     * The takeback offering failed.
     */
    400: _Error;
};
type BotGameTakebackError = BotGameTakebackErrors[keyof BotGameTakebackErrors];
type BotGameTakebackResponses = {
    /**
     * The takeback offer was successfully sent.
     */
    200: Ok;
};
type BotGameTakebackResponse = BotGameTakebackResponses[keyof BotGameTakebackResponses];
type BotGameClaimVictoryData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/{gameId}/claim-victory';
};
type BotGameClaimVictoryErrors = {
    /**
     * The victory claim has failed.
     */
    400: _Error;
};
type BotGameClaimVictoryError = BotGameClaimVictoryErrors[keyof BotGameClaimVictoryErrors];
type BotGameClaimVictoryResponses = {
    /**
     * The victory was successfully claimed.
     */
    200: Ok;
};
type BotGameClaimVictoryResponse = BotGameClaimVictoryResponses[keyof BotGameClaimVictoryResponses];
type ChallengeListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/challenge';
};
type ChallengeListResponses = {
    /**
     * The list of challenges created by or targeted at the logged in user.
     */
    200: {
        /**
         * Incoming challenges i.e. targeted at you
         */
        in?: Array<ChallengeJson>;
        /**
         * Outgoing challenges i.e. created by you
         */
        out?: Array<ChallengeJson>;
    };
};
type ChallengeListResponse = ChallengeListResponses[keyof ChallengeListResponses];
type ChallengeCreateData = {
    /**
     * Parameters of the challenge
     */
    body?: {
        /**
         * Game is rated and impacts players ratings
         */
        rated?: boolean;
        /**
         * Clock initial time in seconds. If empty, a correspondence game is created. Valid values are 0, 15, 30, 45, 60, 90, and any multiple of 60 up to 10800 (3 hours).
         */
        'clock.limit'?: number;
        /**
         * Clock increment in seconds. If empty, a correspondence game is created.
         */
        'clock.increment'?: number;
        /**
         * Days per move, for correspondence games. Clock settings must be omitted.
         */
        days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
        /**
         * Which color you get to play
         */
        color?: 'random' | 'white' | 'black';
        variant?: VariantKey;
        fen?: FromPositionFen;
        /**
         * If set, the response is streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
         * The challenge is kept alive until the connection is closed by the client.
         * When the challenge is accepted, declined or canceled, a message of the form `{"done":"accepted"}` is sent,
         * then the connection is closed by the server.
         * If not set, the response is not streamed, and the challenge expires after 20s if not accepted.
         *
         */
        keepAliveStream?: boolean;
        /**
         * Extra game rules separated by commas.
         * Example: `noAbort,noRematch`
         *
         */
        rules?: 'noAbort' | 'noRematch' | 'noGiveTime' | 'noClaimWin' | 'noEarlyDraw';
    };
    path: {
        username: string;
    };
    query?: never;
    url: '/api/challenge/{username}';
};
type ChallengeCreateErrors = {
    /**
     * The creation of the challenge failed.
     */
    400: _Error;
};
type ChallengeCreateError = ChallengeCreateErrors[keyof ChallengeCreateErrors];
type ChallengeCreateResponses = {
    /**
     * The challenge was successfully created.
     */
    200: ChallengeJson;
};
type ChallengeCreateResponse = ChallengeCreateResponses[keyof ChallengeCreateResponses];
type ChallengeShowData = {
    body?: never;
    path: {
        /**
         * The challenge ID
         */
        challengeId: string;
    };
    query?: never;
    url: '/api/challenge/{challengeId}/show';
};
type ChallengeShowResponses = {
    /**
     * The challenge for that ID.
     */
    200: ChallengeJson;
};
type ChallengeShowResponse = ChallengeShowResponses[keyof ChallengeShowResponses];
type ChallengeAcceptData = {
    body?: never;
    path: {
        challengeId: string;
    };
    query?: never;
    url: '/api/challenge/{challengeId}/accept';
};
type ChallengeAcceptErrors = {
    /**
     * The challenge to accept was not found.
     */
    404: NotFound;
};
type ChallengeAcceptError = ChallengeAcceptErrors[keyof ChallengeAcceptErrors];
type ChallengeAcceptResponses = {
    /**
     * The challenge was successfully accepted.
     */
    200: Ok;
};
type ChallengeAcceptResponse = ChallengeAcceptResponses[keyof ChallengeAcceptResponses];
type ChallengeDeclineData = {
    /**
     * Details related to decline of challenge
     */
    body?: {
        /**
         * Reason challenge was declined. It will be translated to the player's language. See [the full list in the translation file](https://github.com/ornicar/lila/blob/master/translation/source/challenge.xml#L14).
         */
        reason?: 'generic' | 'later' | 'tooFast' | 'tooSlow' | 'timeControl' | 'rated' | 'casual' | 'standard' | 'variant' | 'noBot' | 'onlyBot';
    };
    path: {
        challengeId: string;
    };
    query?: never;
    url: '/api/challenge/{challengeId}/decline';
};
type ChallengeDeclineErrors = {
    /**
     * The challenge to decline was not found.
     */
    404: NotFound;
};
type ChallengeDeclineError = ChallengeDeclineErrors[keyof ChallengeDeclineErrors];
type ChallengeDeclineResponses = {
    /**
     * The challenge was successfully declined.
     */
    200: Ok;
};
type ChallengeDeclineResponse = ChallengeDeclineResponses[keyof ChallengeDeclineResponses];
type ChallengeCancelData = {
    body?: never;
    path: {
        challengeId: string;
    };
    query?: {
        /**
         * Optional `challenge:write` token of the opponent. If set, the game can be canceled even if both players have moved.
         */
        opponentToken?: string;
    };
    url: '/api/challenge/{challengeId}/cancel';
};
type ChallengeCancelErrors = {
    /**
     * The challenge to cancel was not found.
     */
    404: NotFound;
};
type ChallengeCancelError = ChallengeCancelErrors[keyof ChallengeCancelErrors];
type ChallengeCancelResponses = {
    /**
     * The challenge was successfully cancelled.
     */
    200: Ok;
};
type ChallengeCancelResponse = ChallengeCancelResponses[keyof ChallengeCancelResponses];
type ChallengeAiData = {
    /**
     * Parameters of the game
     */
    body: {
        /**
         * AI strength
         */
        level?: number;
        /**
         * Clock initial time in seconds. If empty, a correspondence game is created.
         */
        'clock.limit'?: number;
        /**
         * Clock increment in seconds. If empty, a correspondence game is created.
         */
        'clock.increment'?: number;
        /**
         * Days per move, for correspondence games. Clock settings must be omitted.
         */
        days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
        /**
         * Which color you get to play
         */
        color?: 'random' | 'white' | 'black';
        variant?: VariantKey;
        fen?: FromPositionFen;
    };
    path?: never;
    query?: never;
    url: '/api/challenge/ai';
};
type ChallengeAiErrors = {
    /**
     * The creation of a game with Lichess AI failed.
     */
    400: _Error;
};
type ChallengeAiError = ChallengeAiErrors[keyof ChallengeAiErrors];
type ChallengeAiResponses = {
    /**
     * The game with Lichess AI was successfully started.
     */
    201: GameJson;
};
type ChallengeAiResponse = ChallengeAiResponses[keyof ChallengeAiResponses];
type ChallengeOpenData = {
    /**
     * Parameters of the game
     */
    body?: {
        /**
         * Game is rated and impacts players ratings
         */
        rated?: boolean;
        /**
         * Clock initial time in seconds. If empty, a correspondence game is created.
         */
        'clock.limit'?: number;
        /**
         * Clock increment in seconds. If empty, a correspondence game is created.
         */
        'clock.increment'?: number;
        /**
         * Days per turn. For correspondence challenges.
         */
        days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
        variant?: VariantKey;
        fen?: FromPositionFen;
        /**
         * Optional name for the challenge, that players will see on the challenge page.
         */
        name?: string;
        /**
         * Extra game rules separated by commas.
         * Example: `noRematch,noGiveTime`
         * The `noAbort` rule is available for Lichess admins only
         *
         */
        rules?: 'noRematch' | 'noGiveTime' | 'noClaimWin' | 'noEarlyDraw' | 'noAbort';
        /**
         * Optional pair of usernames, separated by a comma.
         * If set, only these users will be allowed to join the game.
         * The first username gets the white pieces.
         * Example: `Username1,Username2`
         *
         */
        users?: string;
        /**
         * Timestamp in milliseconds to expire the challenge. Defaults to 24h after creation. Can't be more than 2 weeks after creation.
         */
        expiresAt?: number;
    };
    path?: never;
    query?: never;
    url: '/api/challenge/open';
};
type ChallengeOpenErrors = {
    /**
     * The creation of the challenge failed.
     */
    400: _Error;
};
type ChallengeOpenError = ChallengeOpenErrors[keyof ChallengeOpenErrors];
type ChallengeOpenResponses = {
    /**
     * The challenge was successfully created.
     */
    200: ChallengeOpenJson;
};
type ChallengeOpenResponse = ChallengeOpenResponses[keyof ChallengeOpenResponses];
type ChallengeStartClocksData = {
    body?: never;
    path: {
        /**
         * ID of the game
         */
        gameId: string;
    };
    query: {
        /**
         * OAuth token of a player
         */
        token1: string;
        /**
         * OAuth token of the other player. Omit for AI games that have only one player.
         */
        token2?: string;
    };
    url: '/api/challenge/{gameId}/start-clocks';
};
type ChallengeStartClocksResponses = {
    /**
     * The clock of a game was successfully started.
     */
    200: Ok;
};
type ChallengeStartClocksResponse = ChallengeStartClocksResponses[keyof ChallengeStartClocksResponses];
type BulkPairingListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/bulk-pairing';
};
type BulkPairingListResponses = {
    /**
     * The list of bulk pairing the logged in user created.
     */
    200: Array<BulkPairing>;
};
type BulkPairingListResponse = BulkPairingListResponses[keyof BulkPairingListResponses];
type BulkPairingCreateData = {
    /**
     * Parameters of the pairings
     */
    body: {
        /**
         * OAuth tokens of all the players to pair, with the syntax `tokenOfWhitePlayerInGame1:tokenOfBlackPlayerInGame1,tokenOfWhitePlayerInGame2:tokenOfBlackPlayerInGame2,...`.
         * The 2 tokens of the players of a game are separated with `:`. The first token gets the white pieces. Games are separated with `,`.
         * Up to 1000 tokens can be sent, for a max of 500 games.
         * Each token must be included at most once.
         * Example: `token1:token2,token3:token4,token5:token6`
         *
         */
        players?: string;
        /**
         * Clock initial time in seconds. Example: `600`
         *
         */
        'clock.limit'?: number;
        /**
         * Clock increment in seconds. Example: `2`
         *
         */
        'clock.increment'?: number;
        /**
         * Days per turn. For correspondence games only.
         */
        days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
        /**
         * Date at which the games will be created as a Unix timestamp in milliseconds.
         * Up to 7 days in the future.
         * Omit, or set to current date and time, to start the games immediately.
         * Example: `1612289869919`
         *
         */
        pairAt?: number;
        /**
         * Date at which the clocks will be automatically started as a Unix timestamp in milliseconds.
         * Up to 7 days in the future.
         * Note that the clocks can start earlier than specified, if players start making moves in the game.
         * If omitted, the clocks will not start automatically.
         * Example: `1612289869919`
         *
         */
        startClocksAt?: number;
        /**
         * Game is rated and impacts players ratings
         */
        rated?: boolean;
        variant?: VariantKey;
        fen?: FromPositionFen;
        /**
         * Message that will be sent to each player, when the game is created.  It is sent from your user account.
         * `{opponent}` and `{game}` are placeholders that will be replaced with the opponent and the game URLs.
         * You can omit this field to send the default message,
         * but if you set your own message, it must at least contain the `{game}` placeholder.
         *
         */
        message?: string;
        /**
         * Extra game rules separated by commas.
         * Example: `noAbort,noRematch`
         *
         */
        rules?: 'noAbort' | 'noRematch' | 'noGiveTime' | 'noClaimWin' | 'noEarlyDraw';
    };
    path?: never;
    query?: never;
    url: '/api/bulk-pairing';
};
type BulkPairingCreateErrors = {
    /**
     * The creation of the bulk pairings failed.
     */
    400: _Error;
};
type BulkPairingCreateError = BulkPairingCreateErrors[keyof BulkPairingCreateErrors];
type BulkPairingCreateResponses = {
    /**
     * The bulk pairing has been successfully created.
     */
    200: BulkPairing;
};
type BulkPairingCreateResponse = BulkPairingCreateResponses[keyof BulkPairingCreateResponses];
type BulkPairingStartClocksData = {
    body?: never;
    path: {
        /**
         * The ID of the bulk pairing
         */
        id: string;
    };
    query?: never;
    url: '/api/bulk-pairing/{id}/start-clocks';
};
type BulkPairingStartClocksErrors = {
    /**
     * The bulk pairing was not found.
     */
    404: NotFound;
};
type BulkPairingStartClocksError = BulkPairingStartClocksErrors[keyof BulkPairingStartClocksErrors];
type BulkPairingStartClocksResponses = {
    /**
     * The clocks of the games of a bulk pairing were successfully started.
     */
    200: Ok;
};
type BulkPairingStartClocksResponse = BulkPairingStartClocksResponses[keyof BulkPairingStartClocksResponses];
type BulkPairingDeleteData = {
    body?: never;
    path: {
        /**
         * The ID of the bulk pairing
         */
        id: string;
    };
    query?: never;
    url: '/api/bulk-pairing/{id}';
};
type BulkPairingDeleteErrors = {
    /**
     * The bulk pairing to delete was not found.
     */
    404: NotFound;
};
type BulkPairingDeleteError = BulkPairingDeleteErrors[keyof BulkPairingDeleteErrors];
type BulkPairingDeleteResponses = {
    /**
     * The bulk pairing was successfully deleted.
     */
    200: Ok;
};
type BulkPairingDeleteResponse = BulkPairingDeleteResponses[keyof BulkPairingDeleteResponses];
type BulkPairingGetData = {
    body?: never;
    path: {
        /**
         * The ID of the bulk pairing
         */
        id: string;
    };
    query?: never;
    url: '/api/bulk-pairing/{id}';
};
type BulkPairingGetErrors = {
    /**
     * The bulk pairing was not found.
     */
    404: NotFound;
};
type BulkPairingGetError = BulkPairingGetErrors[keyof BulkPairingGetErrors];
type BulkPairingGetResponses = {
    /**
     * The bulk pairing.
     */
    200: BulkPairing;
};
type BulkPairingGetResponse = BulkPairingGetResponses[keyof BulkPairingGetResponses];
type BulkPairingIdGamesGetData = {
    body?: never;
    path: {
        /**
         * The ID of the bulk pairing
         */
        id: string;
    };
    query?: {
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
    };
    url: '/api/bulk-pairing/{id}/games';
};
type BulkPairingIdGamesGetResponses = {
    /**
     * The representation of the games.
     */
    200: GamePgn;
};
type BulkPairingIdGamesGetResponse = BulkPairingIdGamesGetResponses[keyof BulkPairingIdGamesGetResponses];
type RoundAddTimeData = {
    body?: never;
    path: {
        /**
         * ID of the game
         */
        gameId: string;
        /**
         * How many seconds to give
         */
        seconds: string;
    };
    query?: never;
    url: '/api/round/{gameId}/add-time/{seconds}';
};
type RoundAddTimeResponses = {
    /**
     * Time was successfully added to the opponent's clock.
     */
    200: Ok;
};
type RoundAddTimeResponse = RoundAddTimeResponses[keyof RoundAddTimeResponses];
type AdminChallengeTokensData = {
    body: {
        /**
         * Usernames separated with commas
         */
        users: string;
        /**
         * User visible description of the token
         */
        description: string;
    };
    path?: never;
    query?: never;
    url: '/api/token/admin-challenge';
};
type AdminChallengeTokensErrors = {
    /**
     * The creation of the tokens failed.
     */
    400: _Error;
};
type AdminChallengeTokensError = AdminChallengeTokensErrors[keyof AdminChallengeTokensErrors];
type AdminChallengeTokensResponses = {
    /**
     * The `challenge:write` tokens of each user
     */
    200: {
        [key: string]: string;
    };
};
type AdminChallengeTokensResponse = AdminChallengeTokensResponses[keyof AdminChallengeTokensResponses];
type InboxUsernameData = {
    body: {
        text: string;
    };
    path: {
        username: string;
    };
    query?: never;
    url: '/inbox/{username}';
};
type InboxUsernameErrors = {
    /**
     * The sending of the private message has failed.
     */
    400: _Error;
};
type InboxUsernameError = InboxUsernameErrors[keyof InboxUsernameErrors];
type InboxUsernameResponses = {
    /**
     * The private message has been successfully sent.
     */
    200: Ok;
};
type InboxUsernameResponse = InboxUsernameResponses[keyof InboxUsernameResponses];
type ApiCloudEvalData = {
    body?: never;
    path?: never;
    query: {
        /**
         * FEN of the position
         */
        fen: string;
        /**
         * Number of variations
         */
        multiPv?: number;
        /**
         * Variant
         */
        variant?: VariantKey;
    };
    url: '/api/cloud-eval';
};
type ApiCloudEvalErrors = {
    /**
     * The position was not found in the cloud evaluation database.
     */
    404: {
        error?: string;
    };
};
type ApiCloudEvalError = ApiCloudEvalErrors[keyof ApiCloudEvalErrors];
type ApiCloudEvalResponses = {
    /**
     * The evaluation of the position.
     */
    200: CloudEval;
};
type ApiCloudEvalResponse = ApiCloudEvalResponses[keyof ApiCloudEvalResponses];
type ApiExternalEngineListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/external-engine';
};
type ApiExternalEngineListResponses = {
    /**
     * A list of external engines.
     */
    200: Array<ExternalEngine>;
};
type ApiExternalEngineListResponse = ApiExternalEngineListResponses[keyof ApiExternalEngineListResponses];
type ApiExternalEngineCreateData = {
    /**
     * A new external engine registration.
     */
    body: ExternalEngineRegistration;
    path?: never;
    query?: never;
    url: '/api/external-engine';
};
type ApiExternalEngineCreateResponses = {
    /**
     * The registered engine.
     */
    200: ExternalEngine;
};
type ApiExternalEngineCreateResponse = ApiExternalEngineCreateResponses[keyof ApiExternalEngineCreateResponses];
type ApiExternalEngineDeleteData = {
    body?: never;
    path: {
        /**
         * The external engine id.
         */
        id: string;
    };
    query?: never;
    url: '/api/external-engine/{id}';
};
type ApiExternalEngineDeleteResponses = {
    /**
     * Engine successfully deleted
     */
    200: Ok;
};
type ApiExternalEngineDeleteResponse = ApiExternalEngineDeleteResponses[keyof ApiExternalEngineDeleteResponses];
type ApiExternalEngineGetData = {
    body?: never;
    path: {
        /**
         * The external engine id.
         */
        id: string;
    };
    query?: never;
    url: '/api/external-engine/{id}';
};
type ApiExternalEngineGetResponses = {
    /**
     * A registered engine.
     */
    200: ExternalEngine;
};
type ApiExternalEngineGetResponse = ApiExternalEngineGetResponses[keyof ApiExternalEngineGetResponses];
type ApiExternalEnginePutData = {
    /**
     * A modified engine registration.
     */
    body: ExternalEngineRegistration;
    path: {
        /**
         * The external engine id.
         */
        id: string;
    };
    query?: never;
    url: '/api/external-engine/{id}';
};
type ApiExternalEnginePutResponses = {
    /**
     * A registered engine.
     */
    200: ExternalEngine;
};
type ApiExternalEnginePutResponse = ApiExternalEnginePutResponses[keyof ApiExternalEnginePutResponses];
type ApiExternalEngineAnalyseData = {
    /**
     * Engine credentials and analysis request.
     */
    body: {
        clientSecret: string;
        work: ExternalEngineWork;
    };
    path: {
        /**
         * The external engine id.
         */
        id: string;
    };
    query?: never;
    url: '/api/external-engine/{id}/analyse';
};
type ApiExternalEngineAnalyseResponses = {
    /**
     * Stream of analysis output
     */
    200: {
        /**
         * Number of milliseconds the search has been going on
         */
        time: number;
        /**
         * Current search depth
         */
        depth: number;
        /**
         * Number of nodes visited so far
         */
        nodes: number;
        /**
         * Information about up to 5 pvs, with the primary pv at index 0.
         */
        pvs: Array<{
            /**
             * Current search depth of the pv
             */
            depth: number;
            /**
             * Evaluation in centi-pawns, from White's point of view
             */
            cp?: number;
            /**
             * Evaluation in signed moves to mate, from White's point of view
             */
            mate?: number;
            /**
             * Variation in UCI notation
             */
            moves: Array<string>;
        }>;
    };
};
type ApiExternalEngineAnalyseResponse = ApiExternalEngineAnalyseResponses[keyof ApiExternalEngineAnalyseResponses];
type ApiExternalEngineAcquireData = {
    /**
     * Provider credentials.
     */
    body: {
        providerSecret?: string;
    };
    path?: never;
    query?: never;
    url: '/api/external-engine/work';
};
type ApiExternalEngineAcquireResponses = {
    /**
     * Analysis has been requested
     */
    200: {
        id: string;
        work: ExternalEngineWork;
        engine: ExternalEngine;
    };
    /**
     * No pending analysis
     */
    204: void;
};
type ApiExternalEngineAcquireResponse = ApiExternalEngineAcquireResponses[keyof ApiExternalEngineAcquireResponses];
type ApiExternalEngineSubmitData = {
    /**
     * Analysis results
     */
    body: string;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/external-engine/work/{id}';
};
type ApiExternalEngineSubmitResponses = {
    /**
     * Thanks
     */
    200: unknown;
};
type OauthData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be `code`.
         */
        response_type: string;
        /**
         * Arbitrary identifier that uniquely identifies your application.
         */
        client_id: string;
        /**
         * The absolute URL that the user should be redirected to with the authorization result.
         */
        redirect_uri: string;
        /**
         * Must be `S256`.
         */
        code_challenge_method: string;
        /**
         * Compute `BASE64URL(SHA256(code_verifier))`.
         */
        code_challenge: string;
        /**
         * Space separated list of requested OAuth scopes, if any.
         */
        scope?: string;
        /**
         * Hint that you want the user to log in with a specific Lichess username.
         */
        username?: string;
        /**
         * Arbitrary state that will be returned verbatim with the authorization result.
         */
        state?: string;
    };
    url: '/oauth';
};
type OauthResponses = {
    /**
     * Authorization prompt will be displayed to the user.
     */
    200: unknown;
};
type ApiTokenDeleteData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/token';
};
type ApiTokenDeleteResponses = {
    /**
     * Access token revoked.
     */
    204: void;
};
type ApiTokenDeleteResponse = ApiTokenDeleteResponses[keyof ApiTokenDeleteResponses];
type ApiTokenData = {
    body: {
        /**
         * Must be `authorization_code`.
         */
        grant_type?: string;
        /**
         * The authorization code that was sent in the `code` parameter to your `redirect_uri`.
         */
        code?: string;
        /**
         * A `code_challenge` was used to request the authorization code. This must be the `code_verifier` it was derived from.
         */
        code_verifier?: string;
        /**
         * Must match the `redirect_uri` used to request the authorization code.
         */
        redirect_uri?: string;
        /**
         * Must match the `client_id` used to request the authorization code.
         */
        client_id?: string;
    };
    path?: never;
    query?: never;
    url: '/api/token';
};
type ApiTokenErrors = {
    /**
     * Failed to obtain access token.
     */
    400: OAuthError;
};
type ApiTokenError = ApiTokenErrors[keyof ApiTokenErrors];
type ApiTokenResponses = {
    /**
     * Access token successfully obtained.
     */
    200: {
        token_type: string;
        access_token: string;
        expires_in: number;
    };
};
type ApiTokenResponse = ApiTokenResponses[keyof ApiTokenResponses];
type TokenTestData = {
    /**
     * OAuth tokens separated by commas. Up to 1000.
     */
    body: string;
    path?: never;
    query?: never;
    url: '/api/token/test';
};
type TokenTestResponses = {
    /**
     * The representation of the OAuth tokens.
     */
    200: {
        [key: string]: {
            userId?: string;
            /**
             * Comma-separated list of scopes. Empty string if the token has no scopes.
             */
            scopes?: string;
            /**
             * Unix-timestampe in milliseconds or null if the token never expires.
             */
            expires?: number | null;
        } | null;
    };
};
type TokenTestResponse = TokenTestResponses[keyof TokenTestResponses];
type OpeningExplorerMasterData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * FEN of the root position
         */
        fen?: string;
        /**
         * Comma separated sequence of legal moves in UCI notation.
         * Play additional moves starting from `fen`.
         * Required to find an opening name, if `fen` is not an exact match
         * for a named position.
         *
         */
        play?: string;
        /**
         * Include only games from this year or later
         */
        since?: number;
        /**
         * Include only games from this year or earlier
         */
        until?: number;
        /**
         * Number of most common moves to display
         */
        moves?: number;
        /**
         * Number of top games to display
         */
        topGames?: number;
    };
    url: '/masters';
};
type OpeningExplorerMasterResponses = {
    /**
     * Opening statistics and game references for the position.
     */
    200: OpeningExplorerMasters;
};
type OpeningExplorerMasterResponse = OpeningExplorerMasterResponses[keyof OpeningExplorerMasterResponses];
type OpeningExplorerLichessData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Variant
         */
        variant?: VariantKey;
        /**
         * FEN or EPD of the root position
         */
        fen?: string;
        /**
         * Comma separated sequence of legal moves in UCI notation.
         * Play additional moves starting from `fen`.
         * Required to find an opening name, if `fen` is not an exact match
         * for a named position.
         *
         */
        play?: string;
        /**
         * Comma separated list of game speeds to filter by
         */
        speeds?: Array<Speed>;
        /**
         * Comma separated list of ratings groups to filter by.
         * Each group ranges from its value to the next higher
         * group in the enum (`0` from 0 to 999, `1000` from 1000 to 1199,
         * ..., `2500` from 2500 to any rating above).
         *
         */
        ratings?: Array<0 | 1000 | 1200 | 1400 | 1600 | 1800 | 2000 | 2200 | 2500>;
        /**
         * Include only games from this month or later
         */
        since?: string;
        /**
         * Include only games from this month or earlier
         */
        until?: string;
        /**
         * Number of most common moves to display
         */
        moves?: number;
        /**
         * Number of top games to display
         */
        topGames?: number;
        /**
         * Number of recent games to display
         */
        recentGames?: number;
        /**
         * Optionally retrieve history
         */
        history?: boolean;
    };
    url: '/lichess';
};
type OpeningExplorerLichessResponses = {
    /**
     * Opening statistics and game references for the position.
     */
    200: OpeningExplorerLichess;
};
type OpeningExplorerLichessResponse = OpeningExplorerLichessResponses[keyof OpeningExplorerLichessResponses];
type OpeningExplorerPlayerData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Username or ID of the player
         */
        player: string;
        /**
         * Look for games with *player* on the given side
         */
        color: 'white' | 'black';
        /**
         * Variant
         */
        variant?: VariantKey;
        /**
         * FEN of the root position
         */
        fen?: string;
        /**
         * Comma separated sequence of legal moves in UCI notation.
         * Play additional moves starting from `fen`.
         * Required to find an opening name, if `fen` is not an exact match
         * for a named position.
         *
         */
        play?: string;
        /**
         * Comma separated list of game speeds to look for
         */
        speeds?: Array<Speed>;
        /**
         * Comma separated list of modes
         */
        modes?: Array<'casual' | 'rated'>;
        /**
         * Include only games from this month or later
         */
        since?: string;
        /**
         * Include only games from this month or earlier
         */
        until?: string;
        /**
         * Number of most common moves to display
         */
        moves?: number;
        /**
         * Number of recent games to display
         */
        recentGames?: number;
    };
    url: '/player';
};
type OpeningExplorerPlayerResponses = {
    /**
     * Opening statistics and game references for the position.
     */
    200: OpeningExplorerPlayer;
};
type OpeningExplorerPlayerResponse = OpeningExplorerPlayerResponses[keyof OpeningExplorerPlayerResponses];
type OpeningExplorerMasterGameData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/master/pgn/{gameId}';
};
type OpeningExplorerMasterGameResponses = {
    /**
     * The PGN representation of the game.
     */
    200: MasterGamePgn;
};
type OpeningExplorerMasterGameResponse = OpeningExplorerMasterGameResponses[keyof OpeningExplorerMasterGameResponses];
type TablebaseStandardData = {
    body?: never;
    path?: never;
    query: {
        /**
         * FEN of the position. Underscores allowed.
         */
        fen: string;
    };
    url: '/standard';
};
type TablebaseStandardResponses = {
    /**
     * The tablebase information for the position in standard chess.
     */
    200: TablebaseJson;
};
type TablebaseStandardResponse = TablebaseStandardResponses[keyof TablebaseStandardResponses];
type TablebaseAtomicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/atomic';
};
type TablebaseAtomicResponses = {
    /**
     * The tablebase information for the position in atomic chess.
     */
    200: string;
};
type TablebaseAtomicResponse = TablebaseAtomicResponses[keyof TablebaseAtomicResponses];
type AntichessAtomicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/antichess';
};
type AntichessAtomicResponses = {
    /**
     * The tablebase information for the position in antichess.
     */
    200: string;
};
type AntichessAtomicResponse = AntichessAtomicResponses[keyof AntichessAtomicResponses];
type ClientOptions = {
    baseUrl: 'https://lichess.org' | 'https://engine.lichess.ovh' | 'https://engine.lichess.ovh' | 'https://engine.lichess.ovh' | 'https://explorer.lichess.ovh' | 'https://explorer.lichess.ovh' | 'https://explorer.lichess.ovh' | 'https://explorer.lichess.ovh' | 'https://tablebase.lichess.ovh' | 'https://tablebase.lichess.ovh' | 'https://tablebase.lichess.ovh' | (string & {});
};

type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options$1<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};
/**
 * Get real-time users status
 * Read the `online`, `playing` and `streaming` flags of several users.
 * This API is very fast and cheap on lichess side.
 * So you can call it quite often (like once every 5 seconds).
 * Use it to track players and know when they're connected on lichess and playing games.
 *
 */
declare const apiUsersStatus: <ThrowOnError extends boolean = false>(options: Options<ApiUsersStatusData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    id: string;
    name: string;
    title?: string;
    online?: boolean;
    playing?: boolean;
    streaming?: boolean;
    patron?: boolean;
}[], unknown, ThrowOnError>;
/**
 * Get all top 10
 * Get the top 10 players for each speed and variant.
 * See <https://lichess.org/player>.
 *
 */
declare const player: <ThrowOnError extends boolean = false>(options?: Options<PlayerData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Get one leaderboard
 * Get the leaderboard for a single speed or variant (a.k.a. `perfType`).
 * There is no leaderboard for correspondence or puzzles.
 * See <https://lichess.org/player/top/200/bullet>.
 *
 */
declare const playerTopNbPerfType: <ThrowOnError extends boolean = false>(options: Options<PlayerTopNbPerfTypeData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Get user public data
 * Read public data of a user.
 *
 */
declare const apiUser: <ThrowOnError extends boolean = false>(options: Options<ApiUserData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<UserExtended, unknown, ThrowOnError>;
/**
 * Get rating history of a user
 * Read rating history of a user, for all perf types.
 * There is at most one entry per day.
 * Format of an entry is `[year, month, day, rating]`.
 * `month` starts at zero (January).
 *
 */
declare const apiUserRatingHistory: <ThrowOnError extends boolean = false>(options: Options<ApiUserRatingHistoryData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Get performance statistics of a user
 * Read performance statistics of a user, for a single performance.
 * Similar to the [performance pages on the website](https://lichess.org/@/thibault/perf/bullet).
 *
 */
declare const apiUserPerf: <ThrowOnError extends boolean = false>(options: Options<ApiUserPerfData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Get user activity
 * Read data to generate the activity feed of a user.
 *
 */
declare const apiUserActivity: <ThrowOnError extends boolean = false>(options: Options<ApiUserActivityData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<UserActivity, unknown, ThrowOnError>;
/**
 * Get the daily puzzle
 * Get the daily Lichess puzzle in JSON format.
 * Alternatively, you can [post it in your slack workspace](https://lichess.org/daily-puzzle-slack).
 *
 */
declare const apiPuzzleDaily: <ThrowOnError extends boolean = false>(options?: Options<ApiPuzzleDailyData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<PuzzleAndGame, unknown, ThrowOnError>;
/**
 * Get a puzzle by its ID
 * Get a single Lichess puzzle in JSON format.
 */
declare const apiPuzzleId: <ThrowOnError extends boolean = false>(options: Options<ApiPuzzleIdData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<PuzzleAndGame, unknown, ThrowOnError>;
/**
 * Get a new puzzle
 * Get a random Lichess puzzle in JSON format.
 *
 * If authenticated, only returns puzzles that the user has never seen before.
 *
 * **DO NOT** use this endpoint to enumerate puzzles for mass download. Instead, download the [full public puzzle database](https://database.lichess.org/#puzzles).
 *
 */
declare const apiPuzzleNext: <ThrowOnError extends boolean = false>(options?: Options<ApiPuzzleNextData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<PuzzleAndGame, unknown, ThrowOnError>;
/**
 * Get your puzzle activity
 * Download your puzzle activity in [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Puzzle activity is sorted by reverse chronological order (most recent first)
 * We recommend streaming the response, for it can be very long.
 *
 */
declare const apiPuzzleActivity: <ThrowOnError extends boolean = false>(options?: Options<ApiPuzzleActivityData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<PuzzleActivity, unknown, ThrowOnError>;
/**
 * Get puzzles to replay
 * Gets the puzzle IDs of remaining puzzles to re-attempt in JSON format.
 */
declare const apiPuzzleReplay: <ThrowOnError extends boolean = false>(options: Options<ApiPuzzleReplayData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<PuzzleReplay, {
    error?: string;
}, ThrowOnError>;
/**
 * Get your puzzle dashboard
 * Download your [puzzle dashboard](https://lichess.org/training/dashboard/30/dashboard) as JSON.
 * Also includes all puzzle themes played, with aggregated results.
 * Allows re-creating the [improvement/strengths](https://lichess.org/training/dashboard/30/improvementAreas) interfaces.
 *
 */
declare const apiPuzzleDashboard: <ThrowOnError extends boolean = false>(options: Options<ApiPuzzleDashboardData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<PuzzleDashboard, unknown, ThrowOnError>;
/**
 * Get the storm dashboard of a player
 * Download the [storm dashboard](https://lichess.org/storm/dashboard/mrbasso) of any player as JSON.
 * Contains the aggregated highscores, and the history of storm runs aggregated by days.
 * Use `?days=0` if you only care about the highscores.
 *
 */
declare const apiStormDashboard: <ThrowOnError extends boolean = false>(options: Options<ApiStormDashboardData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<PuzzleStormDashboard, unknown, ThrowOnError>;
/**
 * Create and join a puzzle race
 * Create a new private [puzzle race](https://lichess.org/racer).
 * The Lichess user who creates the race must join the race page,
 * and manually start the race when enough players have joined.
 * - <https://lichess.org/racer>
 *
 */
declare const racerPost: <ThrowOnError extends boolean = false>(options?: Options<RacerPostData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<PuzzleRacer, unknown, ThrowOnError>;
/**
 * Get users by ID
 * Get up to 300 users by their IDs. Users are returned in the same order as the IDs.
 * The method is `POST` to allow a longer list of IDs to be sent in the request body.
 * Please do not try to download all the Lichess users with this endpoint, or any other endpoint.
 * An API is not a way to fully export a website. We do not provide a full download of the Lichess users.
 * This endpoint is limited to 8,000 users every 10 minutes, and 120,000 every day.
 *
 */
declare const apiUsers: <ThrowOnError extends boolean = false>(options: Options<ApiUsersData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<User[], unknown, ThrowOnError>;
/**
 * Get my profile
 * Public information about the logged in user.
 *
 */
declare const accountMe: <ThrowOnError extends boolean = false>(options?: Options<AccountMeData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<UserExtended, unknown, ThrowOnError>;
/**
 * Get my email address
 * Read the email address of the logged in user.
 *
 */
declare const accountEmail: <ThrowOnError extends boolean = false>(options?: Options<AccountEmailData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    email?: string;
}, unknown, ThrowOnError>;
/**
 * Get my preferences
 * Read the preferences of the logged in user.
 * - <https://lichess.org/account/preferences/game-display>
 * - <https://github.com/ornicar/lila/blob/master/modules/pref/src/main/Pref.scala>
 *
 */
declare const account: <ThrowOnError extends boolean = false>(options?: Options<AccountData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    prefs?: UserPreferences;
    language?: string;
}, unknown, ThrowOnError>;
/**
 * Get my kid mode status
 * Read the kid mode status of the logged in user.
 * - <https://lichess.org/account/kid>
 *
 */
declare const accountKid: <ThrowOnError extends boolean = false>(options?: Options<AccountKidData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    kid?: boolean;
}, unknown, ThrowOnError>;
/**
 * Set my kid mode status
 * Set the kid mode status of the logged in user.
 * - <https://lichess.org/account/kid>
 *
 */
declare const accountKidPost: <ThrowOnError extends boolean = false>(options: Options<AccountKidPostData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Get my timeline
 * Get the timeline events of the logged in user.
 *
 */
declare const timeline: <ThrowOnError extends boolean = false>(options?: Options<TimelineData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Timeline, unknown, ThrowOnError>;
/**
 * Export one game
 * Download one game in either PGN or JSON format.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 *
 */
declare const gamePgn: <ThrowOnError extends boolean = false>(options: Options<GamePgnData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Export ongoing game of a user
 * Download the ongoing game, or the last game played, of a user.
 * Available in either PGN or JSON format.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 *
 */
declare const apiUserCurrentGame: <ThrowOnError extends boolean = false>(options: Options<ApiUserCurrentGameData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Export games of a user
 * Download all games of any user in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by reverse chronological order (most recent first).
 * We recommend streaming the response, for it can be very long.
 * <https://lichess.org/@/german11> for instance has more than 500,000 games.
 * The game stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 games per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
 * - Authenticated, downloading your own games: 60 games per second
 *
 */
declare const apiGamesUser: <ThrowOnError extends boolean = false>(options: Options<ApiGamesUserData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Export games by IDs
 * Download games by IDs in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
 * Games are sorted by reverse chronological order (most recent first)
 * The method is `POST` so a longer list of IDs can be sent in the request body.
 * 300 IDs can be submitted.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 *
 */
declare const gamesExportIds: <ThrowOnError extends boolean = false>(options: Options<GamesExportIdsData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Stream games of users
 * Stream the games played between a list of users, in real time.
 * Only games where **both players** are part of the list are included.
 * The stream emits an event each time a game is started or finished.
 * To also get all current ongoing games at the beginning of the stream, use the `withCurrentGames` flag.
 * Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Maximum number of users: 300.
 * The method is `POST` so a longer list of IDs can be sent in the request body.
 *
 */
declare const gamesByUsers: <ThrowOnError extends boolean = false>(options: Options<GamesByUsersData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Stream games by IDs
 * Creates a stream of games from an arbitrary streamId, and a list of game IDs.
 * The stream first outputs the games that already exists, then emits an event each time a game is started or finished.
 * Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Maximum number of games: 500 for anonymous requests, or 1000 for [OAuth2 authenticated](#section/Introduction/Authentication) requests.
 * While the stream is open, it is possible to [add new game IDs to watch](#operation/gamesByIdsAdd).
 *
 */
declare const gamesByIds: <ThrowOnError extends boolean = false>(options: Options<GamesByIdsData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Add game IDs to stream
 * Add new game IDs for [an existing stream](#operation/gamesByIds) to watch.
 * The stream will immediately outputs the games that already exists, then emit an event each time a game is started or finished.
 *
 */
declare const gamesByIdsAdd: <ThrowOnError extends boolean = false>(options: Options<GamesByIdsAddData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Get my ongoing games
 * Get the ongoing games of the current user.
 * Real-time and correspondence games are included.
 * The most urgent games are listed first.
 *
 */
declare const apiAccountPlaying: <ThrowOnError extends boolean = false>(options?: Options<ApiAccountPlayingData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    nowPlaying: Array<{
        fullId: string;
        gameId: string;
        fen: string;
        color: "white" | "black";
        lastMove: string;
        source: GameSource;
        status?: GameStatus;
        variant: Variant;
        speed: Speed;
        perf: PerfType;
        rated: boolean;
        hasMoved: boolean;
        opponent: {
            id: string;
            username: string;
            rating?: number;
            ratingDiff?: number;
            ai?: number;
        };
        isMyTurn: boolean;
        secondsLeft: number;
        tournamentId?: string;
        swissId?: string;
        winner?: "white" | "black";
        ratingDiff?: number;
    }>;
}, unknown, ThrowOnError>;
/**
 * Stream moves of a game
 * Stream positions and moves of any ongoing game, in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * A description of the game is sent as a first message.
 * Then a message is sent each time a move is played.
 * Finally a description of the game is sent when it finishes, and the stream is closed.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 * No more than 8 game streams can be opened at the same time from the same IP address.
 *
 */
declare const streamGame: <ThrowOnError extends boolean = false>(options: Options<StreamGameData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Import one game
 * Import a game from PGN. See <https://lichess.org/paste>.
 * Rate limiting: 200 games per hour for OAuth requests, 100 games per hour for anonymous requests.
 * To broadcast ongoing games, consider [pushing to a broadcast instead](#operation/broadcastPush).
 * To analyse a position or a line, just construct an analysis board URL:
 * [https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+](https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+)
 *
 */
declare const gameImport: <ThrowOnError extends boolean = false>(options: Options<GameImportData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    id?: string;
    url?: string;
}, unknown, ThrowOnError>;
/**
 * Export your imported games
 * Download all games imported by you. Games are exported in PGN format.
 */
declare const apiImportedGamesUser: <ThrowOnError extends boolean = false>(options?: Options<ApiImportedGamesUserData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Export your bookmarked games
 * Download all games bookmarked by you, in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by reverse chronological order (most recent first).
 * We recommend streaming the response, for it can be very long.
 *
 */
declare const apiExportBookmarks: <ThrowOnError extends boolean = false>(options?: Options<ApiExportBookmarksData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Get current TV games
 * Get basic info about the best games being played for each speed and variant,
 * but also computer games and bot games.
 * See [lichess.org/tv](https://lichess.org/tv).
 *
 */
declare const tvChannels: <ThrowOnError extends boolean = false>(options?: Options<TvChannelsData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    bot: TvGame;
    blitz: TvGame;
    racingKings: TvGame;
    ultraBullet: TvGame;
    bullet: TvGame;
    classical: TvGame;
    threeCheck: TvGame;
    antichess: TvGame;
    computer: TvGame;
    horde: TvGame;
    rapid: TvGame;
    atomic: TvGame;
    crazyhouse: TvGame;
    chess960: TvGame;
    kingOfTheHill: TvGame;
    best: TvGame;
}, unknown, ThrowOnError>;
/**
 * Stream current TV game
 * Stream positions and moves of the current [TV game](https://lichess.org/tv) in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Try it with `curl https://lichess.org/api/tv/feed`.
 *
 */
declare const tvFeed: <ThrowOnError extends boolean = false>(options?: Options<TvFeedData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<TvFeed, unknown, ThrowOnError>;
/**
 * Stream current TV game of a TV channel
 * Stream positions and moves of a current [TV channel's game](https://lichess.org/tv/rapid) in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Try it with `curl https://lichess.org/api/tv/rapid/feed`.
 *
 */
declare const tvChannelFeed: <ThrowOnError extends boolean = false>(options: Options<TvChannelFeedData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<TvFeed, unknown, ThrowOnError>;
/**
 * Get best ongoing games of a TV channel
 * Get a list of ongoing games for a given TV channel. Similar to [lichess.org/games](https://lichess.org/games).
 * Available in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
 *
 */
declare const tvChannelGames: <ThrowOnError extends boolean = false>(options: Options<TvChannelGamesData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Get current tournaments
 * Get recently active and finished tournaments.
 * This API is used to display the [Lichess tournament schedule](https://lichess.org/tournament).
 *
 */
declare const apiTournament: <ThrowOnError extends boolean = false>(options?: Options<ApiTournamentData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ArenaTournaments, unknown, ThrowOnError>;
/**
 * Create a new Arena tournament
 * Create a public or private Arena tournament.
 * This endpoint mirrors the form on <https://lichess.org/tournament/new>.
 * You can create up to 12 public tournaments per day, or 24 private tournaments.
 * A team battle can be created by specifying the `teamBattleByTeam` argument.
 * Additional restrictions:
 * - clockTime + clockIncrement > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 * - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150
 *
 */
declare const apiTournamentPost: <ThrowOnError extends boolean = false>(options: Options<ApiTournamentPostData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ArenaTournamentFull, _Error, ThrowOnError>;
/**
 * Get info about an Arena tournament
 * Get detailed info about recently finished, current, or upcoming tournament's duels, player standings, and other info.
 *
 */
declare const tournament: <ThrowOnError extends boolean = false>(options: Options<TournamentData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ArenaTournamentFull, unknown, ThrowOnError>;
/**
 * Update an Arena tournament
 * Update an Arena tournament.
 * Be mindful not to make important changes to ongoing tournaments.
 * Can be used to update a team battle.
 * Additional restrictions:
 * - clockTime + clockIncrement > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 * - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150
 *
 */
declare const apiTournamentUpdate: <ThrowOnError extends boolean = false>(options: Options<ApiTournamentUpdateData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ArenaTournamentFull, _Error, ThrowOnError>;
/**
 * Join an Arena tournament
 * Join an Arena tournament, possibly with a password and/or a team.
 * Also unpauses if you had previously [paused](#operation/apiTournamentWithdraw) the tournament.
 *
 */
declare const apiTournamentJoin: <ThrowOnError extends boolean = false>(options: Options<ApiTournamentJoinData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Pause or leave an Arena tournament
 * Leave a future Arena tournament, or take a break on an ongoing Arena tournament.
 * It's possible to join again later. Points and streaks are preserved.
 *
 */
declare const apiTournamentWithdraw: <ThrowOnError extends boolean = false>(options: Options<ApiTournamentWithdrawData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Terminate an Arena tournament
 * Terminate an Arena tournament
 *
 */
declare const apiTournamentTerminate: <ThrowOnError extends boolean = false>(options: Options<ApiTournamentTerminateData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Update a team battle
 * Set the teams and number of leaders of a team battle.
 * To update the other attributes of a team battle, use the [tournament update endpoint](#operation/apiTournamentUpdate).
 *
 */
declare const apiTournamentTeamBattlePost: <ThrowOnError extends boolean = false>(options: Options<ApiTournamentTeamBattlePostData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ArenaTournamentFull, _Error, ThrowOnError>;
/**
 * Export games of an Arena tournament
 * Download games of a tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by reverse chronological order (most recent first).
 * The game stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 games per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
 *
 */
declare const gamesByTournament: <ThrowOnError extends boolean = false>(options: Options<GamesByTournamentData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Get results of an Arena tournament
 * Players of an Arena tournament, with their score and performance, sorted by rank (best first).
 * **Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON)**, i.e. one JSON object per line.
 * If called on an ongoing tournament, results can be inconsistent
 * due to ranking changes while the players are being streamed.
 * Use on finished tournaments for guaranteed consistency.
 *
 */
declare const resultsByTournament: <ThrowOnError extends boolean = false>(options: Options<ResultsByTournamentData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    rank: number;
    score: number;
    rating: number;
    username: string;
    performance: number;
    title?: Title;
    team: string;
    flair?: Flair;
    sheet?: ArenaSheet;
}, unknown, ThrowOnError>;
/**
 * Get team standing of a team battle
 * Teams of a team battle tournament, with top players, sorted by rank (best first).
 *
 */
declare const teamsByTournament: <ThrowOnError extends boolean = false>(options: Options<TeamsByTournamentData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    id: string;
    teams: Array<{
        rank: number;
        id: string;
        score: number;
        players: Array<{
            user: LightUser;
            score?: number;
        }>;
    }>;
}, unknown, ThrowOnError>;
/**
 * Get tournaments created by a user
 * Get all tournaments created by a given user.
 * Tournaments are sorted by reverse chronological order of start date (last starting first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * The stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 tournaments per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 tournaments per second
 * - Authenticated, downloading your own tournaments: 50 games per second
 *
 */
declare const apiUserNameTournamentCreated: <ThrowOnError extends boolean = false>(options: Options<ApiUserNameTournamentCreatedData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ArenaTournament, unknown, ThrowOnError>;
/**
 * Get tournaments played by a user
 * Get all tournaments played by a given user.
 * Tournaments are sorted by reverse chronological order of start date (last played first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * The stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 tournaments per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 tournaments per second
 * - Authenticated, downloading your own tournaments: 50 games per second
 *
 */
declare const apiUserNameTournamentPlayed: <ThrowOnError extends boolean = false>(options: Options<ApiUserNameTournamentPlayedData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ArenaTournamentPlayed, unknown, ThrowOnError>;
/**
 * Create a new Swiss tournament
 * Create a Swiss tournament for your team.
 * This endpoint mirrors the Swiss tournament form from your team pagee.
 * You can create up to 12 tournaments per day.
 * Additional restrictions:
 * - clock.limit + clock.increment > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 *
 */
declare const apiSwissNew: <ThrowOnError extends boolean = false>(options: Options<ApiSwissNewData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<SwissTournament, _Error, ThrowOnError>;
/**
 * Get info about a Swiss tournament
 * Get detailed info about a Swiss tournament.
 *
 */
declare const swiss: <ThrowOnError extends boolean = false>(options: Options<SwissData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<SwissTournament, unknown, ThrowOnError>;
/**
 * Update a Swiss tournament
 * Update a Swiss tournament.
 * Be mindful not to make important changes to ongoing tournaments.
 * Additional restrictions:
 * - clock.limit + clock.increment > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 *
 */
declare const apiSwissUpdate: <ThrowOnError extends boolean = false>(options: Options<ApiSwissUpdateData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<SwissTournament, ApiSwissUpdateError, ThrowOnError>;
/**
 * Manually schedule the next round
 * Manually schedule the next round date and time of a Swiss tournament.
 * This sets the `roundInterval` field to `99999999`, i.e. manual scheduling.
 * All further rounds will need to be manually scheduled, unless the `roundInterval` field is changed back to automatic scheduling.
 *
 */
declare const apiSwissScheduleNextRound: <ThrowOnError extends boolean = false>(options: Options<ApiSwissScheduleNextRoundData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<void, ApiSwissScheduleNextRoundError, ThrowOnError>;
/**
 * Join a Swiss tournament
 * Join a Swiss tournament, possibly with a password.
 *
 */
declare const apiSwissJoin: <ThrowOnError extends boolean = false>(options: Options<ApiSwissJoinData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Pause or leave a swiss tournament
 * Leave a future Swiss tournament, or take a break on an ongoing Swiss tournament.
 * It's possible to join again later. Points are preserved.
 *
 */
declare const apiSwissWithdraw: <ThrowOnError extends boolean = false>(options: Options<ApiSwissWithdrawData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Terminate a Swiss tournament
 * Terminate a Swiss tournament
 *
 */
declare const apiSwissTerminate: <ThrowOnError extends boolean = false>(options: Options<ApiSwissTerminateData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Export TRF of a Swiss tournament
 * Download a tournament in the Tournament Report File format, the FIDE standard.
 * Documentation: <https://www.fide.com/FIDE/handbook/C04Annex2_TRF16.pdf>
 * Example: <https://lichess.org/swiss/j8rtJ5GL.trf>
 *
 */
declare const swissTrf: <ThrowOnError extends boolean = false>(options: Options<SwissTrfData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Export games of a Swiss tournament
 * Download games of a swiss tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by chronological order.
 * The game stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 games per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
 *
 */
declare const gamesBySwiss: <ThrowOnError extends boolean = false>(options: Options<GamesBySwissData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Get results of a swiss tournament
 * Players of a swiss tournament, with their score and performance, sorted by rank (best first).
 * Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * If called on an ongoing tournament, results can be inconsistent
 * due to ranking changes while the players are being streamed.
 * Use on finished tournaments for guaranteed consistency.
 *
 */
declare const resultsBySwiss: <ThrowOnError extends boolean = false>(options: Options<ResultsBySwissData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    absent?: boolean;
    rank: number;
    points: number;
    tieBreak: number;
    rating: number;
    username: string;
    title?: Title;
    performance: number;
}, unknown, ThrowOnError>;
/**
 * Get team swiss tournaments
 * Get all swiss tournaments of a team.
 * Tournaments are sorted by reverse chronological order of start date (last starting first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
declare const apiTeamSwiss: <ThrowOnError extends boolean = false>(options: Options<ApiTeamSwissData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<SwissTournament, unknown, ThrowOnError>;
/**
 * Export one study chapter
 * Download one study chapter in PGN format.
 *
 */
declare const studyChapterPgn: <ThrowOnError extends boolean = false>(options: Options<StudyChapterPgnData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Export all chapters
 * Download all chapters of a study in PGN format.
 *
 */
declare const studyAllChaptersPgn: <ThrowOnError extends boolean = false>(options: Options<StudyAllChaptersPgnData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Study metadata
 * Only get the study headers, including `Last-Modified`.
 *
 */
declare const studyAllChaptersHead: <ThrowOnError extends boolean = false>(options: Options<StudyAllChaptersHeadData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<void, unknown, ThrowOnError>;
/**
 * Import PGN into a study
 * Imports arbitrary PGN into an existing [study](https://lichess.org/study). Creates a new chapter in the study.
 * If the PGN contains multiple games (separated by 2 or more newlines)
 * then multiple chapters will be created within the study.
 * Note that a study can contain at most 64 chapters.
 *
 */
declare const apiStudyImportPgn: <ThrowOnError extends boolean = false>(options: Options<ApiStudyImportPgnData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<StudyImportPgnChapters, _Error, ThrowOnError>;
/**
 * Export all studies of a user
 * Download all chapters of all studies of a user in PGN format.
 * If authenticated, then all public, unlisted, and private studies are included.
 * If not, only public (non-unlisted) studies are included.
 *
 */
declare const studyExportAllPgn: <ThrowOnError extends boolean = false>(options: Options<StudyExportAllPgnData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * List studies of a user
 * Get metadata (name and dates) of all studies of a user.
 * If authenticated, then all public, unlisted, and private studies are included.
 * If not, only public (non-unlisted) studies are included.
 * Studies are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
declare const studyListMetadata: <ThrowOnError extends boolean = false>(options: Options<StudyListMetadataData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<StudyMetadata, unknown, ThrowOnError>;
/**
 * Delete a study chapter
 * Delete a chapter of a study you own. This is definitive.
 * A study must have at least one chapter; so if you delete the last chapter,
 * an empty one will be automatically created to replace it.
 *
 */
declare const apiStudyStudyIdChapterIdDelete: <ThrowOnError extends boolean = false>(options: Options<ApiStudyStudyIdChapterIdDeleteData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<void, unknown, ThrowOnError>;
/**
 * Get official broadcasts
 * Get all incoming, ongoing, and finished official broadcasts.
 * The broadcasts are sorted by start date, most recent first.
 * Broadcasts are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
declare const broadcastsOfficial: <ThrowOnError extends boolean = false>(options?: Options<BroadcastsOfficialData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<BroadcastWithRounds, unknown, ThrowOnError>;
/**
 * Get paginated top broadcast previews
 * The same data, in the same order, as can be seen on [https://lichess.org/broadcast](/broadcast).
 *
 */
declare const broadcastsTop: <ThrowOnError extends boolean = false>(options?: Options<BroadcastsTopData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<BroadcastTop, unknown, ThrowOnError>;
/**
 * Get broadcasts created by a user
 * Get all incoming, ongoing, and finished official broadcasts.
 * The broadcasts are sorted by created date, most recent first.
 *
 */
declare const broadcastsByUser: <ThrowOnError extends boolean = false>(options: Options<BroadcastsByUserData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    currentPage: number;
    maxPerPage: number;
    currentPageResults: Array<BroadcastByUser>;
    nbResults: number;
    previousPage: number | null;
    nextPage: number | null;
    nbPages: number;
}, unknown, ThrowOnError>;
/**
 * Create a broadcast tournament
 * Create a new broadcast tournament to relay external games.
 * This endpoint accepts the same form data as the [web form](https://lichess.org/broadcast/new).
 *
 */
declare const broadcastTourCreate: <ThrowOnError extends boolean = false>(options: Options<BroadcastTourCreateData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<BroadcastWithRounds, _Error, ThrowOnError>;
/**
 * Get a broadcast tournament
 * Get information about a broadcast tournament.
 *
 */
declare const broadcastTourGet: <ThrowOnError extends boolean = false>(options: Options<BroadcastTourGetData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<BroadcastWithRounds, unknown, ThrowOnError>;
/**
 * Get players of a broadcast
 * Get the list of players of a broadcast tournament, if available.
 *
 */
declare const broadcastPlayersGet: <ThrowOnError extends boolean = false>(options: Options<BroadcastPlayersGetData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<BroadcastPlayerEntry[], unknown, ThrowOnError>;
/**
 * Update your broadcast tournament
 * Update information about a broadcast tournament that you created.
 * This endpoint accepts the same form data as the web form.
 * All fields must be populated with data. Missing fields will override the broadcast with empty data.
 *
 */
declare const broadcastTourUpdate: <ThrowOnError extends boolean = false>(options: Options<BroadcastTourUpdateData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Create a broadcast round
 * Create a new broadcast round to relay external games.
 * This endpoint accepts the same form data as the web form.
 *
 * Choose one between `syncUrl`, `syncUrls`, `syncIds` and `syncUsers`, if it is missing, the broadcast needs to be fed by [pushing PGN to it](#operation/broadcastPush)
 *
 */
declare const broadcastRoundCreate: <ThrowOnError extends boolean = false>(options: Options<BroadcastRoundCreateData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<BroadcastRoundNew, _Error, ThrowOnError>;
/**
 * Get a broadcast round
 * Get information about a broadcast round.
 *
 */
declare const broadcastRoundGet: <ThrowOnError extends boolean = false>(options: Options<BroadcastRoundGetData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<BroadcastRound, unknown, ThrowOnError>;
/**
 * Update a broadcast round
 * Update information about a broadcast round.
 * This endpoint accepts the same form data as the web form.
 * All fields must be populated with data. Missing fields will override the broadcast with empty data.
 * For instance, if you omit `startDate`, then any pre-existing start date will be removed.
 *
 */
declare const broadcastRoundUpdate: <ThrowOnError extends boolean = false>(options: Options<BroadcastRoundUpdateData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Reset a broadcast round
 * Remove any games from the broadcast round and reset it to its initial state.
 *
 */
declare const broadcastRoundReset: <ThrowOnError extends boolean = false>(options: Options<BroadcastRoundResetData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Push PGN to a broadcast round
 * Update a broadcast with new PGN.
 * Only for broadcasts without a source URL.
 *
 */
declare const broadcastPush: <ThrowOnError extends boolean = false>(options: Options<BroadcastPushData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<BroadcastPgnPush, {
    error?: string;
}, ThrowOnError>;
/**
 * Stream an ongoing broadcast tournament as PGN
 * This streaming endpoint first sends all games of a broadcast tournament in PGN format.
 * Then, it waits for new moves to be played. As soon as it happens, the entire PGN of the game is sent to the stream.
 * The stream will also send PGNs when games are added to the tournament.
 * This is the best way to get updates about an ongoing tournament. Streaming means no polling,
 * and no pollings means no latency, and minimum impact on the server.
 *
 */
declare const broadcastStreamRoundPgn: <ThrowOnError extends boolean = false>(options: Options<BroadcastStreamRoundPgnData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Export one round as PGN
 * Download all games of a single round of a broadcast tournament in PGN format.
 * You *could* poll this endpoint to get updates about a tournament, but it would be slow,
 * and very inefficient.
 * Instead, consider [streaming the tournament](#operation/broadcastStreamRoundPgn) to get
 * a new PGN every time a game is updated, in real-time.
 *
 */
declare const broadcastRoundPgn: <ThrowOnError extends boolean = false>(options: Options<BroadcastRoundPgnData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Export all rounds as PGN
 * Download all games of all rounds of a broadcast in PGN format.
 * If a `study:read` [OAuth token](#tag/OAuth) is provided,
 * the private rounds where the user is a contributor will be available.
 * You may want to [download only the games of a single round](#operation/broadcastRoundPgn) instead.
 *
 */
declare const broadcastAllRoundsPgn: <ThrowOnError extends boolean = false>(options: Options<BroadcastAllRoundsPgnData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Get your broadcast rounds
 * Stream all broadcast rounds you are a member of.
 * Also includes broadcasts rounds you did not create, but were invited to.
 * Also includes broadcasts rounds where you're a non-writing member. See the `writeable` flag in the response.
 * Rounds are ordered by rank, which is roughly chronological, most recent first, slightly pondered with popularity.
 *
 */
declare const broadcastMyRoundsGet: <ThrowOnError extends boolean = false>(options?: Options<BroadcastMyRoundsGetData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<BroadcastMyRound, unknown, ThrowOnError>;
/**
 * Get a FIDE player
 * Get information about a FIDE player.
 *
 */
declare const fidePlayerGet: <ThrowOnError extends boolean = false>(options: Options<FidePlayerGetData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<FidePlayer, unknown, ThrowOnError>;
/**
 * Search FIDE players
 * List of FIDE players search results for a query.
 *
 */
declare const fidePlayerSearch: <ThrowOnError extends boolean = false>(options: Options<FidePlayerSearchData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<FidePlayer[], unknown, ThrowOnError>;
/**
 * Get current simuls
 * Get recently created, started, finished, simuls.
 * Created and finished simul lists are not exhaustives, only those with
 * strong enough host will be listed, the same filter is used to display simuls on https://lichess.org/simul.
 * When [authenticated with OAuth2](#section/Introduction/Authentication), the pending list will be populated with your created, but unstarted simuls.
 *
 */
declare const apiSimul: <ThrowOnError extends boolean = false>(options?: Options<ApiSimulData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    pending?: Array<Simul>;
    created?: Array<Simul>;
    started?: Array<Simul>;
    finished?: Array<Simul>;
}, unknown, ThrowOnError>;
/**
 * Get a single team
 * Public info about a team. Includes the list of publicly visible leaders.
 */
declare const teamShow: <ThrowOnError extends boolean = false>(options: Options<TeamShowData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Team, unknown, ThrowOnError>;
/**
 * Get popular teams
 * Paginator of the most popular teams.
 *
 */
declare const teamAll: <ThrowOnError extends boolean = false>(options?: Options<TeamAllData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<TeamPaginatorJson, unknown, ThrowOnError>;
/**
 * Teams of a player
 * All the teams a player is a member of.
 *
 */
declare const teamOfUsername: <ThrowOnError extends boolean = false>(options: Options<TeamOfUsernameData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Team[], unknown, ThrowOnError>;
/**
 * Search teams
 * Paginator of team search results for a keyword.
 *
 */
declare const teamSearch: <ThrowOnError extends boolean = false>(options?: Options<TeamSearchData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<TeamPaginatorJson, unknown, ThrowOnError>;
/**
 * Get members of a team
 * Members are sorted by reverse chronological order of joining the team (most recent first).
 * OAuth is only required if the list of members is private.
 * Up to 5,000 users are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
declare const teamIdUsers: <ThrowOnError extends boolean = false>(options: Options<TeamIdUsersData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    joinedTeamAt?: number;
    id: string;
    name: string;
    title?: Title;
    patron?: boolean;
}, unknown, ThrowOnError>;
/**
 * Get team Arena tournaments
 * Get all Arena tournaments relevant to a team.
 * Tournaments are sorted by reverse chronological order of start date (last starting first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
declare const apiTeamArena: <ThrowOnError extends boolean = false>(options: Options<ApiTeamArenaData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ArenaTournament, unknown, ThrowOnError>;
/**
 * Join a team
 * Join a team.
 * If the team requires a password but the `password` field is incorrect,
 * then the call fails with `403 Forbidden`.
 * Similarly, if the team join policy requires a confirmation but the
 * `message` parameter is not given, then the call fails with
 * `403 Forbidden`.
 *
 */
declare const teamIdJoin: <ThrowOnError extends boolean = false>(options: Options<TeamIdJoinData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Leave a team
 * Leave a team.
 * - <https://lichess.org/team>
 *
 */
declare const teamIdQuit: <ThrowOnError extends boolean = false>(options: Options<TeamIdQuitData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Get join requests
 * Get pending join requests of your team
 */
declare const teamRequests: <ThrowOnError extends boolean = false>(options: Options<TeamRequestsData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<TeamRequestWithUser[], unknown, ThrowOnError>;
/**
 * Accept join request
 * Accept someone's request to join your team
 */
declare const teamRequestAccept: <ThrowOnError extends boolean = false>(options: Options<TeamRequestAcceptData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Decline join request
 * Decline someone's request to join your team
 */
declare const teamRequestDecline: <ThrowOnError extends boolean = false>(options: Options<TeamRequestDeclineData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Kick a user from your team
 * Kick a member out of one of your teams.
 * - <https://lichess.org/team>
 *
 */
declare const teamIdKickUserId: <ThrowOnError extends boolean = false>(options: Options<TeamIdKickUserIdData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Message all members
 * Send a private message to all members of a team.
 * You must be a team leader with the "Messages" permission.
 *
 */
declare const teamIdPmAll: <ThrowOnError extends boolean = false>(options: Options<TeamIdPmAllData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Get live streamers
 * Get basic info about currently streaming users.
 * This API is very fast and cheap on lichess side.
 * So you can call it quite often (like once every 5 seconds).
 *
 */
declare const streamerLive: <ThrowOnError extends boolean = false>(options?: Options<StreamerLiveData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<LightUser[], unknown, ThrowOnError>;
/**
 * Get crosstable
 * Get total number of games, and current score, of any two users.
 * If the `matchup` flag is provided, and the users are currently playing, also gets the current match game number and scores.
 *
 */
declare const apiCrosstable: <ThrowOnError extends boolean = false>(options: Options<ApiCrosstableData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Autocomplete usernames
 * Provides autocompletion options for an incomplete username.
 *
 */
declare const apiPlayerAutocomplete: <ThrowOnError extends boolean = false>(options: Options<ApiPlayerAutocompleteData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string[] | {
    result?: Array<LightUserOnline>;
}, unknown, ThrowOnError>;
/**
 * Get notes for a user
 * Get the private notes that you have added for a user.
 *
 */
declare const readNote: <ThrowOnError extends boolean = false>(options: Options<ReadNoteData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<UserNote[], unknown, ThrowOnError>;
/**
 * Add a note for a user
 * Add a private note available only to you about this account.
 *
 */
declare const writeNote: <ThrowOnError extends boolean = false>(options: Options<WriteNoteData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Get users followed by the logged in user
 * Users are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
declare const apiUserFollowing: <ThrowOnError extends boolean = false>(options?: Options<ApiUserFollowingData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<UserExtended, unknown, ThrowOnError>;
/**
 * Follow a player
 * Follow a player, adding them to your list of Lichess friends.
 *
 */
declare const followUser: <ThrowOnError extends boolean = false>(options: Options<FollowUserData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Unfollow a player
 * Unfollow a player, removing them from your list of Lichess friends.
 *
 */
declare const unfollowUser: <ThrowOnError extends boolean = false>(options: Options<UnfollowUserData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Block a player
 * Block a player, adding them to your list of blocked Lichess users.
 *
 */
declare const blockUser: <ThrowOnError extends boolean = false>(options: Options<BlockUserData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Unblock a player
 * Unblock a player, removing them from your list of blocked Lichess users.
 *
 */
declare const unblockUser: <ThrowOnError extends boolean = false>(options: Options<UnblockUserData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Stream incoming events
 * Stream the events reaching a lichess user in real time as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 * An empty line is sent every 6 seconds for keep alive purposes.
 *
 * Each non-empty line is a JSON object containing a `type` field. Possible values are:
 * - `gameStart` Start of a game
 * - `gameFinish` Completion of a game
 * - `challenge` A player sends you a challenge or you challenge someone
 * - `challengeCanceled` A player cancels their challenge to you
 * - `challengeDeclined` The opponent declines your challenge
 *
 * When the stream opens, all current challenges and games are sent.
 *
 */
declare const apiStreamEvent: <ThrowOnError extends boolean = false>(options?: Options<ApiStreamEventData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<GameStartEvent | GameFinishEvent | ChallengeEvent | ChallengeCanceledEvent | ChallengeDeclinedEvent, unknown, ThrowOnError>;
/**
 * Create a seek
 * Create a public seek, to start a game with a random player.
 *
 * ### Real-time seek
 *
 * Specify the `time` and `increment` clock values.
 * The response is streamed but doesn't contain any information.
 *
 * **Keep the connection open to keep the seek active**.
 *
 * If the client closes the connection, the seek is canceled. This way, if the client terminates, the user won't be paired in a game they wouldn't play.
 * When the seek is accepted, or expires, the server closes the connection.
 *
 * **Make sure to also have an [Event stream](#operation/apiStreamEvent) open**, to be notified when a game starts.
 * We recommend opening the [Event stream](#operation/apiStreamEvent) first, then the seek stream. This way,
 * you won't miss the game event if the seek is accepted immediately.
 *
 * ### Correspondence seek
 *
 * Specify the `days` per turn value.
 * The response is not streamed, it immediately completes with the seek ID. The seek remains active on the server until it is joined by someone.
 *
 */
declare const apiBoardSeek: <ThrowOnError extends boolean = false>(options?: Options<ApiBoardSeekData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    id: string;
}, _Error, ThrowOnError>;
/**
 * Stream Board game state
 * Stream the state of a game being played with the Board API, as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 * Use this endpoint to get updates about the game in real-time, with a single request.
 *
 * Each line is a JSON object containing a `type` field. Possible values are:
 * - `gameFull` Full game data. All values are immutable, except for the `state` field.
 * - `gameState` Current state of the game. Immutable values not included. Sent when a move is played, a draw is offered, or when the game ends.
 * - `chatLine` Chat message sent by a user in the `room` "player" or "spectator".
 * - `opponentGone` Whether the opponent has left the game, and how long before you can claim a win or draw.
 *
 * The first line is always of type `gameFull`.
 *
 * The server closes the stream when the game ends, or if the game has already ended.
 *
 */
declare const boardGameStream: <ThrowOnError extends boolean = false>(options: Options<BoardGameStreamData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<GameFullEvent | GameStateEvent | ChatLineEvent | OpponentGone, NotFound, ThrowOnError>;
/**
 * Make a Board move
 * Make a move in a game being played with the Board API.
 * The move can also contain a draw offer/agreement.
 *
 */
declare const boardGameMove: <ThrowOnError extends boolean = false>(options: Options<BoardGameMoveData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Fetch the game chat
 * Get the messages posted in the game chat
 *
 */
declare const boardGameChatGet: <ThrowOnError extends boolean = false>(options: Options<BoardGameChatGetData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Write in the chat
 * Post a message to the player or spectator chat, in a game being played with the Board API.
 *
 */
declare const boardGameChatPost: <ThrowOnError extends boolean = false>(options: Options<BoardGameChatPostData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Abort a game
 * Abort a game being played with the Board API.
 *
 */
declare const boardGameAbort: <ThrowOnError extends boolean = false>(options: Options<BoardGameAbortData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Resign a game
 * Resign a game being played with the Board API.
 *
 */
declare const boardGameResign: <ThrowOnError extends boolean = false>(options: Options<BoardGameResignData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Handle draw offers
 * Create/accept/decline draw offers.
 * - `yes`: Offer a draw, or accept the opponent's draw offer.
 * - `no`: Decline a draw offer from the opponent.
 *
 */
declare const boardGameDraw: <ThrowOnError extends boolean = false>(options: Options<BoardGameDrawData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Handle takeback offers
 * Create/accept/decline takebacks.
 * - `yes`: Propose a takeback, or accept the opponent's takeback offer.
 * - `no`: Decline a takeback offer from the opponent.
 *
 */
declare const boardGameTakeback: <ThrowOnError extends boolean = false>(options: Options<BoardGameTakebackData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Claim victory of a game
 * Claim victory when the opponent has left the game for a while.
 *
 */
declare const boardGameClaimVictory: <ThrowOnError extends boolean = false>(options: Options<BoardGameClaimVictoryData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Berserk a tournament game
 * Go berserk on an arena tournament game. Halves the clock time, grants an extra point upon winning.
 * Only available in arena tournaments that allow berserk, and before each player has made a move.
 *
 */
declare const boardGameBerserk: <ThrowOnError extends boolean = false>(options: Options<BoardGameBerserkData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Get online bots
 * Stream the [online bot users](https://lichess.org/player/bots), as [ndjson](#section/Introduction/Streaming-with-ND-JSON). Throttled to 50 bot users per second.
 */
declare const apiBotOnline: <ThrowOnError extends boolean = false>(options?: Options<ApiBotOnlineData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<User, unknown, ThrowOnError>;
/**
 * Upgrade to Bot account
 * Upgrade a lichess player account into a Bot account. Only Bot accounts can use the Bot API.
 * The account **cannot have played any game** before becoming a Bot account. The upgrade is **irreversible**. The account will only be able to play as a Bot.
 * To upgrade an account to Bot, use the [official lichess-bot client](https://github.com/lichess-bot-devs/lichess-bot), or follow these steps:
 * - Create an [API access token](https://lichess.org/account/oauth/token/create?scopes[]=bot:play) with "Play bot moves" permission.
 * - `curl -d '' https://lichess.org/api/bot/account/upgrade -H "Authorization: Bearer <yourTokenHere>"`
 * To know if an account has already been upgraded, use the [Get my profile API](#operation/accountMe):
 * the `title` field should be set to `BOT`.
 *
 */
declare const botAccountUpgrade: <ThrowOnError extends boolean = false>(options?: Options<BotAccountUpgradeData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Stream Bot game state
 * Stream the state of a game being played with the Bot API, as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Use this endpoint to get updates about the game in real-time, with a single request.
 * Each line is a JSON object containing a `type` field. Possible values are:
 * - `gameFull` Full game data. All values are immutable, except for the `state` field.
 * - `gameState` Current state of the game. Immutable values not included.
 * - `chatLine` Chat message sent by a user (or the bot itself) in the `room` "player" or "spectator".
 * - `opponentGone` Whether the opponent has left the game, and how long before you can claim a win or draw.
 * The first line is always of type `gameFull`.
 *
 */
declare const botGameStream: <ThrowOnError extends boolean = false>(options: Options<BotGameStreamData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<GameFullEvent | GameStateEvent | ChatLineEvent | OpponentGone, NotFound, ThrowOnError>;
/**
 * Make a Bot move
 * Make a move in a game being played with the Bot API.
 * The move can also contain a draw offer/agreement.
 *
 */
declare const botGameMove: <ThrowOnError extends boolean = false>(options: Options<BotGameMoveData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Fetch the game chat
 * Get the messages posted in the game chat
 *
 */
declare const botGameChatGet: <ThrowOnError extends boolean = false>(options: Options<BotGameChatGetData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Write in the chat
 * Post a message to the player or spectator chat, in a game being played with the Bot API.
 *
 */
declare const botGameChat: <ThrowOnError extends boolean = false>(options: Options<BotGameChatData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Abort a game
 * Abort a game being played with the Bot API.
 *
 */
declare const botGameAbort: <ThrowOnError extends boolean = false>(options: Options<BotGameAbortData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Resign a game
 * Resign a game being played with the Bot API.
 *
 */
declare const botGameResign: <ThrowOnError extends boolean = false>(options: Options<BotGameResignData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Handle draw offers
 * Create/accept/decline draw offers with the Bot API.
 * - `yes`: Offer a draw, or accept the opponent's draw offer.
 * - `no`: Decline a draw offer from the opponent.
 *
 */
declare const botGameDraw: <ThrowOnError extends boolean = false>(options: Options<BotGameDrawData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Handle takeback offers
 * Create/accept/decline takebacks with the Bot API.
 * - `yes`: Propose a takeback, or accept the opponent's takeback offer.
 * - `no`: Decline a takeback offer from the opponent.
 *
 */
declare const botGameTakeback: <ThrowOnError extends boolean = false>(options: Options<BotGameTakebackData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Claim victory of a game
 * Claim victory when the opponent has left the game for a while.
 *
 */
declare const botGameClaimVictory: <ThrowOnError extends boolean = false>(options: Options<BotGameClaimVictoryData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * List your challenges
 * Get a list of challenges created by or targeted at you.
 *
 */
declare const challengeList: <ThrowOnError extends boolean = false>(options?: Options<ChallengeListData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    in?: Array<ChallengeJson>;
    out?: Array<ChallengeJson>;
}, unknown, ThrowOnError>;
/**
 * Create a challenge
 * Challenge someone to play. The targeted player can choose to accept or decline.
 * If the challenge is accepted, you will be notified on the [event stream](#operation/apiStreamEvent)
 * that a new game has started. The game ID will be the same as the challenge ID.
 * Challenges for realtime games (not correspondence) expire after 20s if not accepted.
 * To prevent that, use the `keepAliveStream` flag described below.
 *
 */
declare const challengeCreate: <ThrowOnError extends boolean = false>(options: Options<ChallengeCreateData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ChallengeJson, _Error, ThrowOnError>;
/**
 * Show one challenge
 * Get details about a challenge, even if it has been recently accepted, canceled or declined.
 *
 */
declare const challengeShow: <ThrowOnError extends boolean = false>(options: Options<ChallengeShowData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ChallengeJson, unknown, ThrowOnError>;
/**
 * Accept a challenge
 * Accept an incoming challenge.
 * You should receive a `gameStart` event on the [incoming events stream](#operation/apiStreamEvent).
 *
 */
declare const challengeAccept: <ThrowOnError extends boolean = false>(options: Options<ChallengeAcceptData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, NotFound, ThrowOnError>;
/**
 * Decline a challenge
 * Decline an incoming challenge.
 *
 */
declare const challengeDecline: <ThrowOnError extends boolean = false>(options: Options<ChallengeDeclineData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, NotFound, ThrowOnError>;
/**
 * Cancel a challenge
 * Cancel a challenge you sent, or aborts the game if the challenge was accepted, but the game was not yet played.
 * Note that the ID of a game is the same as the ID of the challenge that created it.
 * Works for user challenges and open challenges alike.
 *
 */
declare const challengeCancel: <ThrowOnError extends boolean = false>(options: Options<ChallengeCancelData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, NotFound, ThrowOnError>;
/**
 * Challenge the AI
 * Start a game with Lichess AI.
 * You will be notified on the [event stream](#operation/apiStreamEvent) that a new game has started.
 *
 */
declare const challengeAi: <ThrowOnError extends boolean = false>(options: Options<ChallengeAiData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<GameJson, _Error, ThrowOnError>;
/**
 * Open-ended challenge
 * Create a challenge that any 2 players can join.
 * Share the URL of the challenge. the first 2 players to click it will be paired for a game.
 * The response body also contains `whiteUrl` and `blackUrl`.
 * You can control which color each player gets by giving them these URLs,
 * instead of the main challenge URL.
 * Open challenges expire after 24h.
 * If the challenge creation is [authenticated with OAuth2](#section/Introduction/Authentication),
 * then you can use the [challenge cancel endpoint](#operation/challengeCancel) to cancel it.
 * To directly pair 2 known players, use [this endpoint](#operation/bulkPairingList) instead.
 *
 */
declare const challengeOpen: <ThrowOnError extends boolean = false>(options?: Options<ChallengeOpenData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ChallengeOpenJson, _Error, ThrowOnError>;
/**
 * Start clocks of a game
 * Start the clocks of a game immediately, even if a player has not yet made a move.
 * Requires the OAuth tokens of both players with `challenge:write` scope.
 * If the clocks have already started, the call will have no effect.
 *
 * For AI games with only one player, omit the `token2` parameter.
 *
 */
declare const challengeStartClocks: <ThrowOnError extends boolean = false>(options: Options<ChallengeStartClocksData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * View your bulk pairings
 * Get a list of bulk pairings you created.
 *
 */
declare const bulkPairingList: <ThrowOnError extends boolean = false>(options?: Options<BulkPairingListData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown[], unknown, ThrowOnError>;
/**
 * Create a bulk pairing
 * Schedule many games at once, up to 24h in advance.
 * OAuth tokens are required for all paired players, with the `challenge:write` scope.
 * You can schedule up to 500 games every 10 minutes. [Contact us](mailto:contact@lichess.org) if you need higher limits.
 * If games have a real-time clock, each player must have only one pairing.
 * For correspondence games, players can have multiple pairings within the same bulk.
 *
 * **The entire bulk is rejected if:**
 * - a token is missing
 * - a token is present more than once (except in correspondence)
 * - a token lacks the `challenge:write` scope
 * - a player account is closed
 * - a player is paired more than once (except in correspondence)
 * - a bulk is already scheduled to start at the same time with the same player
 * - you have 20 scheduled bulks
 * - you have 1000 scheduled games
 *
 * Partial bulks are never created. Either it all fails, or it all succeeds.
 * When it fails, it does so with an error message explaining the issue.
 * Failed bulks are not counted in the rate limiting, they are free.
 * Fix the issues, manually or programmatically, then retry to schedule the bulk.
 * A successful bulk creation returns a JSON bulk document. Its ID can be used for further operations.
 *
 */
declare const bulkPairingCreate: <ThrowOnError extends boolean = false>(options: Options<BulkPairingCreateData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, _Error, ThrowOnError>;
/**
 * Manually start clocks
 * Immediately start all clocks of the games of a bulk pairing.
 * This overrides the `startClocksAt` value of an existing bulk pairing.
 * If the games have not yet been created (`bulk.pairAt` is in the future), then this does nothing.
 * If the clocks have already started (`bulk.startClocksAt` is in the past), then this does nothing.
 *
 */
declare const bulkPairingStartClocks: <ThrowOnError extends boolean = false>(options: Options<BulkPairingStartClocksData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, NotFound, ThrowOnError>;
/**
 * Cancel a bulk pairing
 * Cancel and delete a bulk pairing that is scheduled in the future.
 * If the games have already been created, then this does nothing.
 * Canceling a bulk pairing does not refund the rate limit cost of that bulk pairing.
 *
 */
declare const bulkPairingDelete: <ThrowOnError extends boolean = false>(options: Options<BulkPairingDeleteData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, NotFound, ThrowOnError>;
/**
 * Show a bulk pairing
 * Get a single bulk pairing by its ID.
 *
 */
declare const bulkPairingGet: <ThrowOnError extends boolean = false>(options: Options<BulkPairingGetData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, NotFound, ThrowOnError>;
/**
 * Export games of a bulk pairing
 * Download games of a bulk in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
 *
 */
declare const bulkPairingIdGamesGet: <ThrowOnError extends boolean = false>(options: Options<BulkPairingIdGamesGetData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Add time to the opponent clock
 * Add seconds to the opponent's clock. Can be used to create games with time odds.
 *
 */
declare const roundAddTime: <ThrowOnError extends boolean = false>(options: Options<RoundAddTimeData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Admin challenge tokens
 * **This endpoint can only be used by Lichess administrators. It will not work if you do not have the appropriate permissions.** Tournament organizers should instead use [OAuth](#tag/OAuth) to obtain `challenge:write` tokens from users in order to perform bulk pairing.*
 * Create and obtain `challenge:write` tokens for multiple users.
 * If a similar token already exists for a user, it is reused. This endpoint is idempotent.
 *
 */
declare const adminChallengeTokens: <ThrowOnError extends boolean = false>(options: Options<AdminChallengeTokensData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    [key: string]: string;
}, _Error, ThrowOnError>;
/**
 * Send a private message
 * Send a private message to another player.
 *
 */
declare const inboxUsername: <ThrowOnError extends boolean = false>(options: Options<InboxUsernameData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, _Error, ThrowOnError>;
/**
 * Get cloud evaluation of a position.
 * Get the cached evaluation of a position, if available.
 * Opening positions have more chances of being available. There are about 15 million positions in the database.
 * Up to 5 variations may be available. Variants are supported.
 * Use this endpoint to fetch a few positions here and there.
 * If you want to download a lot of positions, [get the full list](https://database.lichess.org/#evals) from our exported database.
 *
 */
declare const apiCloudEval: <ThrowOnError extends boolean = false>(options: Options<ApiCloudEvalData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<CloudEval, {
    error?: string;
}, ThrowOnError>;
/**
 * List external engines
 * Lists all external engines that have been registered for the user,
 * and the credentials required to use them.
 *
 */
declare const apiExternalEngineList: <ThrowOnError extends boolean = false>(options?: Options<ApiExternalEngineListData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ExternalEngine[], unknown, ThrowOnError>;
/**
 * Create external engine
 * Registers a new external engine for the user. It can then be selected
 * and used on the analysis board.
 * After registering, the provider should start waiting for analyis requests.
 *
 */
declare const apiExternalEngineCreate: <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineCreateData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ExternalEngine, unknown, ThrowOnError>;
/**
 * Delete external engine
 * Unregisters an external engine.
 *
 */
declare const apiExternalEngineDelete: <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineDeleteData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<Ok, unknown, ThrowOnError>;
/**
 * Get external engine
 * Get properties and credentials of an external engine.
 *
 */
declare const apiExternalEngineGet: <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineGetData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ExternalEngine, unknown, ThrowOnError>;
/**
 * Update external engine
 * Updates the properties of an external engine.
 *
 */
declare const apiExternalEnginePut: <ThrowOnError extends boolean = false>(options: Options<ApiExternalEnginePutData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ExternalEngine, unknown, ThrowOnError>;
/**
 * Analyse with external engine
 * **Endpoint: `https://engine.lichess.ovh/api/external-engine/{id}/analyse`**
 * Request analysis from an external engine.
 * Response content is streamed as [newline delimited JSON](#section/Introduction/Streaming-with-ND-JSON).
 * The properties are based on the [UCI specification](https://backscattering.de/chess/uci/#engine).
 * Analysis stops when the client goes away, the requested limit
 * is reached, or the provider goes away.
 *
 */
declare const apiExternalEngineAnalyse: <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineAnalyseData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    time: number;
    depth: number;
    nodes: number;
    pvs: Array<{
        depth: number;
        cp?: number;
        mate?: number;
        moves: Array<string>;
    }>;
}, unknown, ThrowOnError>;
/**
 * Acquire analysis request
 * **Endpoint: `https://engine.lichess.ovh/api/external-engine/work`**
 * Wait for an analysis requests to any of the external engines that
 * have been registered with the given `secret`.
 * Uses long polling.
 * After acquiring a request, the provider should immediately
 * [start streaming the results](#tag/External-engine/operation/apiExternalEngineSubmit).
 *
 */
declare const apiExternalEngineAcquire: <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineAcquireData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<ApiExternalEngineAcquireResponse, unknown, ThrowOnError>;
/**
 * Answer analysis request
 * **Endpoint: `https://engine.lichess.ovh/api/external-engine/work/{id}`**
 * Submit a stream of analysis as [UCI output](https://backscattering.de/chess/uci/#engine-info).
 * * The engine should always be in `UCI_Chess960` mode.
 * * `UCI_AnalyseMode` enabled if available.
 * * It produces `info` with at least:
 * - `depth`
 * - `multipv` (between 1 and 5)
 * - `score`
 * - `nodes`
 * - `time`
 * - `pv`
 * The server may close the connection at any time, indicating that
 * the requester has gone away and analysis should be stopped.
 *
 */
declare const apiExternalEngineSubmit: <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineSubmitData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Request authorization code
 * OAuth2 authorization endpoint.
 * Start the OAuth2 Authorization Code Flow with PKCE by securely
 * generating two random strings unique to each authorization
 * request:
 *
 * * `code_verifier`
 * * `state`
 *
 * Store these in session storage. Make sure not to reveal `code_verifier`
 * to eavesdroppers. Do not show it in URLs, do not abuse `state` to store
 * it, do not send it over insecure connections. However it is fine if
 * the user themselves can extract `code_verifier`, which will always be
 * possible for fully client-side apps.
 * Then send the user to this endpoint. They will be prompted to grant
 * authorization and then be redirected back to the given `redirect_uri`.
 * If the authorization failed, the following query string parameters will
 * be appended to the redirection:
 *
 * * `error`, in particular with value `access_denied` if the user
 * cancelled authorization
 * * `error_description` to aid debugging
 * * `state`, exactly as passed in the `state` parameter
 *
 * If the authorization succeeded, the following query string parameters
 * will be appended to the redirection:
 *
 * * `code`, containing a fresh short-lived authorization code
 * * `state`, exactly as passed in the `state` parameter
 *
 * Next, to defend against cross site request forgery, check that the
 * returned `state` matches the `state` you originally generated.
 *
 * Finally, continue by using the authorization code to
 * [obtain an access token](#operation/apiToken).
 *
 */
declare const oauth: <ThrowOnError extends boolean = false>(options: Options<OauthData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Revoke access token
 * Revokes the access token sent as Bearer for this request.
 */
declare const apiTokenDelete: <ThrowOnError extends boolean = false>(options?: Options<ApiTokenDeleteData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<void, unknown, ThrowOnError>;
/**
 * Obtain access token
 * OAuth2 token endpoint. Exchanges an authorization code for an access token.
 *
 */
declare const apiToken: <ThrowOnError extends boolean = false>(options: Options<ApiTokenData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    token_type: string;
    access_token: string;
    expires_in: number;
}, OAuthError, ThrowOnError>;
/**
 * Test multiple OAuth tokens
 * For up to 1000 OAuth tokens,
 * returns their associated user ID and scopes,
 * or `null` if the token is invalid.
 * The method is `POST` so a longer list of tokens can be sent in the request body.
 *
 */
declare const tokenTest: <ThrowOnError extends boolean = false>(options: Options<TokenTestData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<{
    [key: string]: {
        userId?: string;
        scopes?: string;
        expires?: number | null;
    } | null;
}, unknown, ThrowOnError>;
/**
 * Masters database
 * **Endpoint: <https://explorer.lichess.ovh/masters>**
 *
 * Example: `curl https://explorer.lichess.ovh/masters?play=d2d4,d7d5,c2c4,c7c6,c4d5`
 *
 */
declare const openingExplorerMaster: <ThrowOnError extends boolean = false>(options?: Options<OpeningExplorerMasterData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<OpeningExplorerMasters, unknown, ThrowOnError>;
/**
 * Lichess games
 * **Endpoint: <https://explorer.lichess.ovh/lichess>**
 *
 * Games sampled from all Lichess players.
 *
 * Example: `curl https://explorer.lichess.ovh/lichess?variant=standard&speeds=blitz,rapid,classical&ratings=2200,2500&fen=rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR%20w%20KQkq%20-%200%201`
 *
 */
declare const openingExplorerLichess: <ThrowOnError extends boolean = false>(options?: Options<OpeningExplorerLichessData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<OpeningExplorerLichess, unknown, ThrowOnError>;
/**
 * Player games
 * **Endpoint: <https://explorer.lichess.ovh/player>**
 *
 * Games of a Lichess player.
 *
 * Responds with a stream of [newline delimited JSON](#section/Introduction/Streaming-with-ND-JSON). Will start indexing
 * on demand, immediately respond with the current results, and stream
 * more updates until indexing is complete. The stream is throttled
 * and deduplicated. Empty lines may be sent to avoid timeouts.
 *
 * Will index new games at most once per minute, and revisit previously
 * ongoing games at most once every day.
 *
 * Example: `curl https://explorer.lichess.ovh/player?player=revoof&color=white&play=d2d4,d7d5&recentGames=1`
 *
 */
declare const openingExplorerPlayer: <ThrowOnError extends boolean = false>(options: Options<OpeningExplorerPlayerData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<OpeningExplorerPlayer, unknown, ThrowOnError>;
/**
 * OTB master game
 * **Endpoint: `https://explorer.lichess.ovh/masters/pgn/{gameId}`**
 *
 * Example: `curl https://explorer.lichess.ovh/masters/pgn/aAbqI4ey`
 *
 */
declare const openingExplorerMasterGame: <ThrowOnError extends boolean = false>(options: Options<OpeningExplorerMasterGameData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError>;
/**
 * Tablebase lookup
 * **Endpoint: <https://tablebase.lichess.ovh>**
 * Example: `curl http://tablebase.lichess.ovh/standard?fen=4k3/6KP/8/8/8/8/7p/8_w_-_-_0_1`
 *
 */
declare const tablebaseStandard: <ThrowOnError extends boolean = false>(options: Options<TablebaseStandardData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<TablebaseJson, unknown, ThrowOnError>;
/**
 * Tablebase lookup for Atomic chess
 * **Endpoint: <https://tablebase.lichess.ovh>**
 *
 */
declare const tablebaseAtomic: <ThrowOnError extends boolean = false>(options?: Options<TablebaseAtomicData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;
/**
 * Tablebase lookup for Antichess
 * **Endpoint: <https://tablebase.lichess.ovh>**
 *
 */
declare const antichessAtomic: <ThrowOnError extends boolean = false>(options?: Options<AntichessAtomicData, ThrowOnError>) => _hey_api_client_fetch.RequestResult<string, unknown, ThrowOnError>;

declare const initialize: (apiToken: string) => void;

export { account, accountEmail, accountKid, accountKidPost, accountMe, adminChallengeTokens, antichessAtomic, apiAccountPlaying, apiBoardSeek, apiBotOnline, apiCloudEval, apiCrosstable, apiExportBookmarks, apiExternalEngineAcquire, apiExternalEngineAnalyse, apiExternalEngineCreate, apiExternalEngineDelete, apiExternalEngineGet, apiExternalEngineList, apiExternalEnginePut, apiExternalEngineSubmit, apiGamesUser, apiImportedGamesUser, apiPlayerAutocomplete, apiPuzzleActivity, apiPuzzleDaily, apiPuzzleDashboard, apiPuzzleId, apiPuzzleNext, apiPuzzleReplay, apiSimul, apiStormDashboard, apiStreamEvent, apiStudyImportPgn, apiStudyStudyIdChapterIdDelete, apiSwissJoin, apiSwissNew, apiSwissScheduleNextRound, apiSwissTerminate, apiSwissUpdate, apiSwissWithdraw, apiTeamArena, apiTeamSwiss, apiToken, apiTokenDelete, apiTournament, apiTournamentJoin, apiTournamentPost, apiTournamentTeamBattlePost, apiTournamentTerminate, apiTournamentUpdate, apiTournamentWithdraw, apiUser, apiUserActivity, apiUserCurrentGame, apiUserFollowing, apiUserNameTournamentCreated, apiUserNameTournamentPlayed, apiUserPerf, apiUserRatingHistory, apiUsers, apiUsersStatus, blockUser, boardGameAbort, boardGameBerserk, boardGameChatGet, boardGameChatPost, boardGameClaimVictory, boardGameDraw, boardGameMove, boardGameResign, boardGameStream, boardGameTakeback, botAccountUpgrade, botGameAbort, botGameChat, botGameChatGet, botGameClaimVictory, botGameDraw, botGameMove, botGameResign, botGameStream, botGameTakeback, broadcastAllRoundsPgn, broadcastMyRoundsGet, broadcastPlayersGet, broadcastPush, broadcastRoundCreate, broadcastRoundGet, broadcastRoundPgn, broadcastRoundReset, broadcastRoundUpdate, broadcastStreamRoundPgn, broadcastTourCreate, broadcastTourGet, broadcastTourUpdate, broadcastsByUser, broadcastsOfficial, broadcastsTop, bulkPairingCreate, bulkPairingDelete, bulkPairingGet, bulkPairingIdGamesGet, bulkPairingList, bulkPairingStartClocks, challengeAccept, challengeAi, challengeCancel, challengeCreate, challengeDecline, challengeList, challengeOpen, challengeShow, challengeStartClocks, fidePlayerGet, fidePlayerSearch, followUser, gameImport, gamePgn, gamesByIds, gamesByIdsAdd, gamesBySwiss, gamesByTournament, gamesByUsers, gamesExportIds, inboxUsername, initialize, oauth, openingExplorerLichess, openingExplorerMaster, openingExplorerMasterGame, openingExplorerPlayer, player, playerTopNbPerfType, racerPost, readNote, resultsBySwiss, resultsByTournament, roundAddTime, streamGame, streamerLive, studyAllChaptersHead, studyAllChaptersPgn, studyChapterPgn, studyExportAllPgn, studyListMetadata, swiss, swissTrf, tablebaseAtomic, tablebaseStandard, teamAll, teamIdJoin, teamIdKickUserId, teamIdPmAll, teamIdQuit, teamIdUsers, teamOfUsername, teamRequestAccept, teamRequestDecline, teamRequests, teamSearch, teamShow, teamsByTournament, timeline, tokenTest, tournament, tvChannelFeed, tvChannelGames, tvChannels, tvFeed, unblockUser, unfollowUser, writeNote };
export type { AccountData, AccountEmailData, AccountEmailResponse, AccountEmailResponses, AccountKidData, AccountKidPostData, AccountKidPostResponse, AccountKidPostResponses, AccountKidResponse, AccountKidResponses, AccountMeData, AccountMeResponse, AccountMeResponses, AccountResponse, AccountResponses, AdminChallengeTokensData, AdminChallengeTokensError, AdminChallengeTokensErrors, AdminChallengeTokensResponse, AdminChallengeTokensResponses, AntichessAtomicData, AntichessAtomicResponse, AntichessAtomicResponses, ApiAccountPlayingData, ApiAccountPlayingResponse, ApiAccountPlayingResponses, ApiBoardSeekData, ApiBoardSeekError, ApiBoardSeekErrors, ApiBoardSeekResponse, ApiBoardSeekResponses, ApiBotOnlineData, ApiBotOnlineResponse, ApiBotOnlineResponses, ApiCloudEvalData, ApiCloudEvalError, ApiCloudEvalErrors, ApiCloudEvalResponse, ApiCloudEvalResponses, ApiCrosstableData, ApiCrosstableResponse, ApiCrosstableResponses, ApiExportBookmarksData, ApiExportBookmarksResponse, ApiExportBookmarksResponses, ApiExternalEngineAcquireData, ApiExternalEngineAcquireResponse, ApiExternalEngineAcquireResponses, ApiExternalEngineAnalyseData, ApiExternalEngineAnalyseResponse, ApiExternalEngineAnalyseResponses, ApiExternalEngineCreateData, ApiExternalEngineCreateResponse, ApiExternalEngineCreateResponses, ApiExternalEngineDeleteData, ApiExternalEngineDeleteResponse, ApiExternalEngineDeleteResponses, ApiExternalEngineGetData, ApiExternalEngineGetResponse, ApiExternalEngineGetResponses, ApiExternalEngineListData, ApiExternalEngineListResponse, ApiExternalEngineListResponses, ApiExternalEnginePutData, ApiExternalEnginePutResponse, ApiExternalEnginePutResponses, ApiExternalEngineSubmitData, ApiExternalEngineSubmitResponses, ApiGamesUserData, ApiGamesUserResponse, ApiGamesUserResponses, ApiImportedGamesUserData, ApiImportedGamesUserResponse, ApiImportedGamesUserResponses, ApiPlayerAutocompleteData, ApiPlayerAutocompleteResponse, ApiPlayerAutocompleteResponses, ApiPuzzleActivityData, ApiPuzzleActivityResponse, ApiPuzzleActivityResponses, ApiPuzzleDailyData, ApiPuzzleDailyResponse, ApiPuzzleDailyResponses, ApiPuzzleDashboardData, ApiPuzzleDashboardResponse, ApiPuzzleDashboardResponses, ApiPuzzleIdData, ApiPuzzleIdResponse, ApiPuzzleIdResponses, ApiPuzzleNextData, ApiPuzzleNextResponse, ApiPuzzleNextResponses, ApiPuzzleReplayData, ApiPuzzleReplayError, ApiPuzzleReplayErrors, ApiPuzzleReplayResponse, ApiPuzzleReplayResponses, ApiSimulData, ApiSimulResponse, ApiSimulResponses, ApiStormDashboardData, ApiStormDashboardResponse, ApiStormDashboardResponses, ApiStreamEventData, ApiStreamEventResponse, ApiStreamEventResponses, ApiStudyImportPgnData, ApiStudyImportPgnError, ApiStudyImportPgnErrors, ApiStudyImportPgnResponse, ApiStudyImportPgnResponses, ApiStudyStudyIdChapterIdDeleteData, ApiStudyStudyIdChapterIdDeleteResponse, ApiStudyStudyIdChapterIdDeleteResponses, ApiSwissJoinData, ApiSwissJoinError, ApiSwissJoinErrors, ApiSwissJoinResponse, ApiSwissJoinResponses, ApiSwissNewData, ApiSwissNewError, ApiSwissNewErrors, ApiSwissNewResponse, ApiSwissNewResponses, ApiSwissScheduleNextRoundData, ApiSwissScheduleNextRoundError, ApiSwissScheduleNextRoundErrors, ApiSwissScheduleNextRoundResponse, ApiSwissScheduleNextRoundResponses, ApiSwissTerminateData, ApiSwissTerminateError, ApiSwissTerminateErrors, ApiSwissTerminateResponse, ApiSwissTerminateResponses, ApiSwissUpdateData, ApiSwissUpdateError, ApiSwissUpdateErrors, ApiSwissUpdateResponse, ApiSwissUpdateResponses, ApiSwissWithdrawData, ApiSwissWithdrawResponse, ApiSwissWithdrawResponses, ApiTeamArenaData, ApiTeamArenaResponse, ApiTeamArenaResponses, ApiTeamSwissData, ApiTeamSwissResponse, ApiTeamSwissResponses, ApiTokenData, ApiTokenDeleteData, ApiTokenDeleteResponse, ApiTokenDeleteResponses, ApiTokenError, ApiTokenErrors, ApiTokenResponse, ApiTokenResponses, ApiTournamentData, ApiTournamentJoinData, ApiTournamentJoinError, ApiTournamentJoinErrors, ApiTournamentJoinResponse, ApiTournamentJoinResponses, ApiTournamentPostData, ApiTournamentPostError, ApiTournamentPostErrors, ApiTournamentPostResponse, ApiTournamentPostResponses, ApiTournamentResponse, ApiTournamentResponses, ApiTournamentTeamBattlePostData, ApiTournamentTeamBattlePostError, ApiTournamentTeamBattlePostErrors, ApiTournamentTeamBattlePostResponse, ApiTournamentTeamBattlePostResponses, ApiTournamentTerminateData, ApiTournamentTerminateError, ApiTournamentTerminateErrors, ApiTournamentTerminateResponse, ApiTournamentTerminateResponses, ApiTournamentUpdateData, ApiTournamentUpdateError, ApiTournamentUpdateErrors, ApiTournamentUpdateResponse, ApiTournamentUpdateResponses, ApiTournamentWithdrawData, ApiTournamentWithdrawError, ApiTournamentWithdrawErrors, ApiTournamentWithdrawResponse, ApiTournamentWithdrawResponses, ApiUserActivityData, ApiUserActivityResponse, ApiUserActivityResponses, ApiUserCurrentGameData, ApiUserCurrentGameResponse, ApiUserCurrentGameResponses, ApiUserData, ApiUserFollowingData, ApiUserFollowingResponse, ApiUserFollowingResponses, ApiUserNameTournamentCreatedData, ApiUserNameTournamentCreatedResponse, ApiUserNameTournamentCreatedResponses, ApiUserNameTournamentPlayedData, ApiUserNameTournamentPlayedResponse, ApiUserNameTournamentPlayedResponses, ApiUserPerfData, ApiUserPerfResponse, ApiUserPerfResponses, ApiUserRatingHistoryData, ApiUserRatingHistoryResponse, ApiUserRatingHistoryResponses, ApiUserResponse, ApiUserResponses, ApiUsersData, ApiUsersResponse, ApiUsersResponses, ApiUsersStatusData, ApiUsersStatusResponse, ApiUsersStatusResponses, ArenaPerf, ArenaPlayerPerformance, ArenaPosition, ArenaRatingObj, ArenaSheet, ArenaStatus, ArenaStatusName, ArenaTournament, ArenaTournamentFull, ArenaTournamentPlayed, ArenaTournaments, BlockUserData, BlockUserResponse, BlockUserResponses, BoardGameAbortData, BoardGameAbortError, BoardGameAbortErrors, BoardGameAbortResponse, BoardGameAbortResponses, BoardGameBerserkData, BoardGameBerserkError, BoardGameBerserkErrors, BoardGameBerserkResponse, BoardGameBerserkResponses, BoardGameChatGetData, BoardGameChatGetResponse, BoardGameChatGetResponses, BoardGameChatPostData, BoardGameChatPostError, BoardGameChatPostErrors, BoardGameChatPostResponse, BoardGameChatPostResponses, BoardGameClaimVictoryData, BoardGameClaimVictoryError, BoardGameClaimVictoryErrors, BoardGameClaimVictoryResponse, BoardGameClaimVictoryResponses, BoardGameDrawData, BoardGameDrawError, BoardGameDrawErrors, BoardGameDrawResponse, BoardGameDrawResponses, BoardGameMoveData, BoardGameMoveError, BoardGameMoveErrors, BoardGameMoveResponse, BoardGameMoveResponses, BoardGameResignData, BoardGameResignError, BoardGameResignErrors, BoardGameResignResponse, BoardGameResignResponses, BoardGameStreamData, BoardGameStreamError, BoardGameStreamErrors, BoardGameStreamResponse, BoardGameStreamResponses, BoardGameTakebackData, BoardGameTakebackError, BoardGameTakebackErrors, BoardGameTakebackResponse, BoardGameTakebackResponses, BotAccountUpgradeData, BotAccountUpgradeError, BotAccountUpgradeErrors, BotAccountUpgradeResponse, BotAccountUpgradeResponses, BotGameAbortData, BotGameAbortError, BotGameAbortErrors, BotGameAbortResponse, BotGameAbortResponses, BotGameChatData, BotGameChatError, BotGameChatErrors, BotGameChatGetData, BotGameChatGetResponse, BotGameChatGetResponses, BotGameChatResponse, BotGameChatResponses, BotGameClaimVictoryData, BotGameClaimVictoryError, BotGameClaimVictoryErrors, BotGameClaimVictoryResponse, BotGameClaimVictoryResponses, BotGameDrawData, BotGameDrawError, BotGameDrawErrors, BotGameDrawResponse, BotGameDrawResponses, BotGameMoveData, BotGameMoveError, BotGameMoveErrors, BotGameMoveResponse, BotGameMoveResponses, BotGameResignData, BotGameResignError, BotGameResignErrors, BotGameResignResponse, BotGameResignResponses, BotGameStreamData, BotGameStreamError, BotGameStreamErrors, BotGameStreamResponse, BotGameStreamResponses, BotGameTakebackData, BotGameTakebackError, BotGameTakebackErrors, BotGameTakebackResponse, BotGameTakebackResponses, BroadcastAllRoundsPgnData, BroadcastAllRoundsPgnResponse, BroadcastAllRoundsPgnResponses, BroadcastByUser, BroadcastForm, BroadcastGroup, BroadcastGroupTour, BroadcastMyRound, BroadcastMyRoundsGetData, BroadcastMyRoundsGetResponse, BroadcastMyRoundsGetResponses, BroadcastPgnPush, BroadcastPgnPushTags, BroadcastPlayerEntry, BroadcastPlayersGetData, BroadcastPlayersGetResponse, BroadcastPlayersGetResponses, BroadcastPushData, BroadcastPushError, BroadcastPushErrors, BroadcastPushResponse, BroadcastPushResponses, BroadcastRound, BroadcastRoundCreateData, BroadcastRoundCreateError, BroadcastRoundCreateErrors, BroadcastRoundCreateResponse, BroadcastRoundCreateResponses, BroadcastRoundForm, BroadcastRoundFormName, BroadcastRoundGame, BroadcastRoundGetData, BroadcastRoundGetResponse, BroadcastRoundGetResponses, BroadcastRoundInfo, BroadcastRoundNew, BroadcastRoundPgnData, BroadcastRoundPgnResponse, BroadcastRoundPgnResponses, BroadcastRoundResetData, BroadcastRoundResetResponse, BroadcastRoundResetResponses, BroadcastRoundStudyInfo, BroadcastRoundUpdateData, BroadcastRoundUpdateError, BroadcastRoundUpdateErrors, BroadcastRoundUpdateResponse, BroadcastRoundUpdateResponses, BroadcastStreamRoundPgnData, BroadcastStreamRoundPgnResponse, BroadcastStreamRoundPgnResponses, BroadcastTop, BroadcastTour, BroadcastTourCreateData, BroadcastTourCreateError, BroadcastTourCreateErrors, BroadcastTourCreateResponse, BroadcastTourCreateResponses, BroadcastTourGetData, BroadcastTourGetResponse, BroadcastTourGetResponses, BroadcastTourUpdateData, BroadcastTourUpdateError, BroadcastTourUpdateErrors, BroadcastTourUpdateResponse, BroadcastTourUpdateResponses, BroadcastWithLastRound, BroadcastWithRounds, BroadcastsByUserData, BroadcastsByUserResponse, BroadcastsByUserResponses, BroadcastsOfficialData, BroadcastsOfficialResponse, BroadcastsOfficialResponses, BroadcastsTopData, BroadcastsTopResponse, BroadcastsTopResponses, BulkPairing, BulkPairingCreateData, BulkPairingCreateError, BulkPairingCreateErrors, BulkPairingCreateResponse, BulkPairingCreateResponses, BulkPairingDeleteData, BulkPairingDeleteError, BulkPairingDeleteErrors, BulkPairingDeleteResponse, BulkPairingDeleteResponses, BulkPairingGetData, BulkPairingGetError, BulkPairingGetErrors, BulkPairingGetResponse, BulkPairingGetResponses, BulkPairingIdGamesGetData, BulkPairingIdGamesGetResponse, BulkPairingIdGamesGetResponses, BulkPairingListData, BulkPairingListResponse, BulkPairingListResponses, BulkPairingStartClocksData, BulkPairingStartClocksError, BulkPairingStartClocksErrors, BulkPairingStartClocksResponse, BulkPairingStartClocksResponses, ChallengeAcceptData, ChallengeAcceptError, ChallengeAcceptErrors, ChallengeAcceptResponse, ChallengeAcceptResponses, ChallengeAiData, ChallengeAiError, ChallengeAiErrors, ChallengeAiResponse, ChallengeAiResponses, ChallengeCancelData, ChallengeCancelError, ChallengeCancelErrors, ChallengeCancelResponse, ChallengeCancelResponses, ChallengeCanceledEvent, ChallengeCanceledJson, ChallengeCreateData, ChallengeCreateError, ChallengeCreateErrors, ChallengeCreateResponse, ChallengeCreateResponses, ChallengeDeclineData, ChallengeDeclineError, ChallengeDeclineErrors, ChallengeDeclineResponse, ChallengeDeclineResponses, ChallengeDeclinedEvent, ChallengeEvent, ChallengeJson, ChallengeListData, ChallengeListResponse, ChallengeListResponses, ChallengeOpenData, ChallengeOpenError, ChallengeOpenErrors, ChallengeOpenJson, ChallengeOpenResponse, ChallengeOpenResponses, ChallengeShowData, ChallengeShowResponse, ChallengeShowResponses, ChallengeStartClocksData, ChallengeStartClocksResponse, ChallengeStartClocksResponses, ChallengeUser, ChatLineEvent, ClientOptions, Clock, CloudEval, Count, Crosstable, ExternalEngine, ExternalEngineRegistration, ExternalEngineWork, FidePlayer, FidePlayerGetData, FidePlayerGetResponse, FidePlayerGetResponses, FidePlayerSearchData, FidePlayerSearchResponse, FidePlayerSearchResponses, Flair, FollowUserData, FollowUserResponse, FollowUserResponses, FromPositionFen, GameChat, GameEventInfo, GameEventPlayer, GameFinishEvent, GameFullEvent, GameImportData, GameImportResponse, GameImportResponses, GameJson, GameMoveAnalysis, GamePgn, GamePgnData, GamePgnResponse, GamePgnResponses, GameSource, GameStartEvent, GameStateEvent, GameStatus, GameStream, GameUser, GamesByIdsAddData, GamesByIdsAddResponse, GamesByIdsAddResponses, GamesByIdsData, GamesByIdsResponse, GamesByIdsResponses, GamesBySwissData, GamesBySwissResponse, GamesBySwissResponses, GamesByTournamentData, GamesByTournamentResponse, GamesByTournamentResponses, GamesByUsersData, GamesByUsersResponse, GamesByUsersResponses, GamesExportIdsData, GamesExportIdsResponse, GamesExportIdsResponses, InboxUsernameData, InboxUsernameError, InboxUsernameErrors, InboxUsernameResponse, InboxUsernameResponses, Leaderboard, LightUser, LightUserOnline, MasterGamePgn, Move, MoveStream, NotFound, OAuthError, OauthData, OauthResponses, Ok, OpeningExplorerGamePlayer, OpeningExplorerLichess, OpeningExplorerLichessData, OpeningExplorerLichessGame, OpeningExplorerLichessResponse, OpeningExplorerLichessResponses, OpeningExplorerMasterData, OpeningExplorerMasterGameData, OpeningExplorerMasterGameResponse, OpeningExplorerMasterGameResponses, OpeningExplorerMasterResponse, OpeningExplorerMasterResponses, OpeningExplorerMasters, OpeningExplorerMastersGame, OpeningExplorerOpening, OpeningExplorerPlayer, OpeningExplorerPlayerData, OpeningExplorerPlayerGame, OpeningExplorerPlayerResponse, OpeningExplorerPlayerResponses, OpponentGone, Options, Perf, PerfStat, PerfType, Perfs, PlayTime, PlayerData, PlayerResponse, PlayerResponses, PlayerTopNbPerfTypeData, PlayerTopNbPerfTypeResponse, PlayerTopNbPerfTypeResponses, Profile, PuzzleActivity, PuzzleAndGame, PuzzleDashboard, PuzzleModePerf, PuzzlePerformance, PuzzleRacer, PuzzleReplay, PuzzleStormDashboard, RacerPostData, RacerPostResponse, RacerPostResponses, RatingHistory, ReadNoteData, ReadNoteResponse, ReadNoteResponses, ResultsBySwissData, ResultsBySwissResponse, ResultsBySwissResponses, ResultsByTournamentData, ResultsByTournamentResponse, ResultsByTournamentResponses, RoundAddTimeData, RoundAddTimeResponse, RoundAddTimeResponses, Simul, Speed, StreamGameData, StreamGameResponse, StreamGameResponses, StreamerLiveData, StreamerLiveResponse, StreamerLiveResponses, StudyAllChaptersHeadData, StudyAllChaptersHeadResponse, StudyAllChaptersHeadResponses, StudyAllChaptersPgnData, StudyAllChaptersPgnResponse, StudyAllChaptersPgnResponses, StudyChapterPgnData, StudyChapterPgnResponse, StudyChapterPgnResponses, StudyExportAllPgnData, StudyExportAllPgnResponse, StudyExportAllPgnResponses, StudyImportPgnChapters, StudyListMetadataData, StudyListMetadataResponse, StudyListMetadataResponses, StudyMetadata, StudyPgn, SwissData, SwissFromPositionFen, SwissResponse, SwissResponses, SwissStatus, SwissTournament, SwissTrfData, SwissTrfResponse, SwissTrfResponses, SwissUnauthorisedEdit, TablebaseAtomicData, TablebaseAtomicResponse, TablebaseAtomicResponses, TablebaseJson, TablebaseStandardData, TablebaseStandardResponse, TablebaseStandardResponses, Team, TeamAllData, TeamAllResponse, TeamAllResponses, TeamIdJoinData, TeamIdJoinResponse, TeamIdJoinResponses, TeamIdKickUserIdData, TeamIdKickUserIdResponse, TeamIdKickUserIdResponses, TeamIdPmAllData, TeamIdPmAllError, TeamIdPmAllErrors, TeamIdPmAllResponse, TeamIdPmAllResponses, TeamIdQuitData, TeamIdQuitResponse, TeamIdQuitResponses, TeamIdUsersData, TeamIdUsersResponse, TeamIdUsersResponses, TeamOfUsernameData, TeamOfUsernameResponse, TeamOfUsernameResponses, TeamPaginatorJson, TeamRequest, TeamRequestAcceptData, TeamRequestAcceptResponse, TeamRequestAcceptResponses, TeamRequestDeclineData, TeamRequestDeclineResponse, TeamRequestDeclineResponses, TeamRequestWithUser, TeamRequestsData, TeamRequestsResponse, TeamRequestsResponses, TeamSearchData, TeamSearchResponse, TeamSearchResponses, TeamShowData, TeamShowResponse, TeamShowResponses, TeamsByTournamentData, TeamsByTournamentResponse, TeamsByTournamentResponses, Timeline, TimelineData, TimelineEntryBlogPost, TimelineEntryFollow, TimelineEntryForumPost, TimelineEntryGameEnd, TimelineEntryPlanRenew, TimelineEntryPlanStart, TimelineEntrySimul, TimelineEntryStreamStart, TimelineEntryStudyLike, TimelineEntryTeamCreate, TimelineEntryTeamJoin, TimelineEntryTourJoin, TimelineEntryUblogPost, TimelineEntryUblogPostLike, TimelineResponse, TimelineResponses, Title, TokenTestData, TokenTestResponse, TokenTestResponses, Top10S, TournamentData, TournamentResponse, TournamentResponses, TvChannelFeedData, TvChannelFeedResponse, TvChannelFeedResponses, TvChannelGamesData, TvChannelGamesResponse, TvChannelGamesResponses, TvChannelsData, TvChannelsResponse, TvChannelsResponses, TvFeed, TvFeedData, TvFeedResponse, TvFeedResponses, TvGame, UciVariant, UnblockUserData, UnblockUserResponse, UnblockUserResponses, UnfollowUserData, UnfollowUserResponse, UnfollowUserResponses, User, UserActivity, UserActivityCorrespondenceGame, UserActivityFollowList, UserActivityScore, UserExtended, UserNote, UserPreferences, Variant, VariantKey, Verdicts, WriteNoteData, WriteNoteResponse, WriteNoteResponses, _Error };
